{"meta":{"title":"zhumenger ❤ blog","subtitle":null,"description":"穿过落雁修竹, 看过日升月暮<br/>你说有一天你会名扬天下实现你的抱负!","author":"zhumenger","url":"http://zhumenger.top","root":"/"},"pages":[{"title":"404","date":"2019-06-10T10:17:33.000Z","updated":"2019-06-10T10:17:33.852Z","comments":true,"path":"404/index.html","permalink":"http://zhumenger.top/404/index.html","excerpt":"","text":""},{"title":"about","date":"2019-06-10T10:18:02.000Z","updated":"2019-06-10T10:18:02.435Z","comments":true,"path":"about/index-1.html","permalink":"http://zhumenger.top/about/index-1.html","excerpt":"","text":""},{"title":"search","date":"2019-06-10T10:17:29.000Z","updated":"2019-06-10T10:17:29.558Z","comments":true,"path":"search/index.html","permalink":"http://zhumenger.top/search/index.html","excerpt":"","text":""},{"title":"about","date":"2019-06-10T09:53:05.000Z","updated":"2019-06-13T16:20:19.020Z","comments":true,"path":"about/index.html","permalink":"http://zhumenger.top/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-06-10T10:18:41.000Z","updated":"2019-06-10T10:18:41.392Z","comments":true,"path":"categories/index-1.html","permalink":"http://zhumenger.top/categories/index-1.html","excerpt":"","text":""},{"title":"categories","date":"2019-06-10T09:52:55.000Z","updated":"2019-06-13T15:56:59.460Z","comments":true,"path":"categories/index.html","permalink":"http://zhumenger.top/categories/index.html","excerpt":"","text":""},{"title":"timeline","date":"2019-06-13T16:10:01.000Z","updated":"2019-06-13T16:10:01.213Z","comments":true,"path":"timeline/index.html","permalink":"http://zhumenger.top/timeline/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-10T10:18:32.000Z","updated":"2019-06-10T10:18:32.868Z","comments":true,"path":"tags/index-1.html","permalink":"http://zhumenger.top/tags/index-1.html","excerpt":"","text":""},{"title":"guestbook","date":"2019-06-13T15:51:50.000Z","updated":"2019-06-13T15:51:50.980Z","comments":true,"path":"guestbook/index.html","permalink":"http://zhumenger.top/guestbook/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-10T09:52:42.000Z","updated":"2019-06-10T11:04:57.276Z","comments":true,"path":"tags/index.html","permalink":"http://zhumenger.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"树的重心(dfs)","slug":"树的重心","date":"2019-06-14T09:50:40.000Z","updated":"2019-06-14T13:31:40.286Z","comments":true,"path":"2019/06/14/树的重心/","link":"","permalink":"http://zhumenger.top/2019/06/14/树的重心/","excerpt":"","text":"题目描述 给定一颗树，树中包含n个结点（编号1~n）和n-1条无向边。请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。 输入格式 第一行包含整数n，表示树的结点数。接下来n-1行，每行包含两个整数a和b，表示点a和点b之前存在一条边。 输出格式 输出一个整数m，表示重心的所有的子树中最大的子树的结点数目。 数据范围 1≤n≤105 输入样例 9 1 21 71 42 82 54 33 94 6 输出样例： 4 解题思路： 这道题就是树的深度优先遍历，我们只需套用模板，遍历每个点的同时，返回该子树的点的个数，以及计算去掉该点时连通块点的最大值即可，最后用ans取去掉每个点之后的最大联通块的最小值就是最后的答案。具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int h[N], e[N], ne[N], idx, n;int ans = N; //答案bool vis[N]; //判断是否遍历过void add(int a, int b) //邻接表存树与图&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;int dfs(int cur)&#123; vis[cur] = true; int res = 0, sum = 1; //res表示去掉cur这个节点，联通块点的最大值， sum表示该子树点的个数 for(int i = h[cur]; i != -1; i = ne[i])&#123; //遍历树 int u = e[i]; if(!vis[u])&#123; int s = dfs(u); res = max(res, s); sum += s; &#125; &#125; res = max(res, n - sum); // sum是该子树的点的个数， n - sum表示它的父节点所连接的联通块点的个数 ans = min(res, ans); //取最大连通块点的最小值 return sum;&#125;int main()&#123; int a, b; cin &gt;&gt; n; //初始化 memset(h, -1, sizeof h); memset(vis, false, sizeof vis); for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; a &gt;&gt; b; //建树，双向图 add(a, b); add(b, a); &#125; dfs(1); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/categories/搜索/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"树与图的深度优先遍历(dfs)","slug":"树与图的深度优先遍历","date":"2019-06-14T09:47:20.000Z","updated":"2019-06-14T09:56:49.156Z","comments":true,"path":"2019/06/14/树与图的深度优先遍历/","link":"","permalink":"http://zhumenger.top/2019/06/14/树与图的深度优先遍历/","excerpt":"","text":"树与图的深度优先遍历: 树其实也是图的一种图: 分为有向图和无向图图的储存: 第一种：邻接矩阵，就是一个二维数组，缺点：当点和边特别多的时候，存不下，一般用的比较少，而且非常浪费空间第二种：邻接表:由n个单链表组成，也可以用vector动态数组来实现，但vector有很大的缺点，当点和边非常大时，用vector动态数组的方法很容易超时，所以我们常用n个但链表的方式来存储图 邻接表如何存图呢：假设有这样一个图:那么我们可以给每个节点开一个单链表，如下图所示：这样我们就把图用邻接表的方法存了下来树与图深度优先遍历的大致流程：一条路走到黑，直到撞到南墙，走不通了，然后往回走，只要有分支就继续往下走，示例图如下: 树与图的遍历模板： 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int h[N], e[N], ne[N], idx, n;//这里跟单链表一样，只不过这里是N个头节点，H[N]bool vis[N]; //判断是否遍历过void add(int a, int b) //邻接表存树与图&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;void dfs(int cur)&#123; vis[cur] = true; for(int i = h[cur]; i != -1; i = ne[i])&#123; //遍历树 int u = e[i]; if(!vis[u])&#123; dfs(u); &#125; &#125;&#125;int main()&#123; int a, b; cin &gt;&gt; n; //初始化 memset(h, -1, sizeof h); memset(vis, false, sizeof vis); for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; a &gt;&gt; b; //建树，双向图 add(a, b); add(b, a); &#125; dfs(1); return 0;&#125; 这样我们就遍历了每个点。","categories":[{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/categories/搜索/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"字符串哈希","slug":"字符串哈希","date":"2019-06-13T01:45:46.000Z","updated":"2019-06-13T02:51:28.815Z","comments":true,"path":"2019/06/13/字符串哈希/","link":"","permalink":"http://zhumenger.top/2019/06/13/字符串哈希/","excerpt":"","text":"字符串哈希：简介：为了方便的找到某个字符串，我们可以把该字符串转化为一个数值，每一个字符串都有一个唯一确定的编号，这样在绝大多数情况下可以在O(1)的时间复杂度中完成对字符串元素的查找 字符串哈希函数：为每一个字符串赋予唯一确定的数值或编号。 题目描述给定一个长度为n的字符串，再给定m个询问，每个询问包含四个整数l1,r1,l2,r2l1,r1,l2,r2，请你判断[l1,r1l1,r1]和[l2,r2l2,r2]这两个区间所包含的字符串子串是否完全相同。 字符串中只包含大小写英文字母和数字。 输入格式第一行包含整数n和m，表示字符串长度和询问次数。 第二行包含一个长度为n的字符串，字符串中只包含大小写英文字母和数字。 接下来m行，每行包含四个整数l1,r1,l2,r2l1,r1,l2,r2，表示一次询问所涉及的两个区间。 注意，字符串的位置从1开始编号。 输出格式对于每个询问输出一个结果，如果两个字符串子串完全相同则输出“Yes”，否则输出“No”。 每个结果占一行。 数据范围1≤n,m≤1051≤n,m≤105 输入样例： 8 3aabbaabb1 3 5 71 3 6 81 2 1 2 输出样例： YesNoYes 代码如下： 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef unsigned long long ULL;const int N = 1e6 + 10, base = 131;ULL h[N], p[N];char s[N];ULL solve(int l, int r)&#123; return h[r] - h[l - 1] * p[r - l + 1];&#125;int main()&#123; int n, m; int a, b, c, d; cin &gt;&gt; n &gt;&gt; m; cin &gt;&gt; (s + 1); p[0] = 1; for(int i = 1; i &lt;= n; i++) &#123; h[i] = h[i - 1] * base + s[i] - 'a' + 1; p[i] = p[i - 1] * base; &#125; while(m--)&#123; cin &gt;&gt; a&gt;&gt; b &gt;&gt; c &gt;&gt; d; if(solve(a, b) == solve(c, d))cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"字符串哈希","slug":"字符串哈希","permalink":"http://zhumenger.top/tags/字符串哈希/"}]},{"title":"哈希表(散列表)","slug":"哈希表-散列表","date":"2019-06-11T16:08:08.000Z","updated":"2019-06-13T03:21:42.542Z","comments":true,"path":"2019/06/12/哈希表-散列表/","link":"","permalink":"http://zhumenger.top/2019/06/12/哈希表-散列表/","excerpt":"","text":"简介： 哈希表又称为散列表，是实现字典操作的一种有效的数据结构。通过哈希函数将关键字映射到表中的某个位置上进行存放，以实现快速插入和查询的。时间复杂度可达到O(n).为什么要用到哈希：比如说有n(1&lt;=n&lt;=1e6)个数,当给你一个非常大的数时，为了方便查找这个数是否出现过，我们可以给这个数重新编号到1~n，这样我们就可以快速的找到想要的答案。 题目描述 维护一个集合，支持如下几种操作：“I x”，插入一个数x；“Q x”，询问数x是否在集合中出现过；现在要进行N次操作，对于每个询问操作输出对应的结果。 输入格式 第一行包含整数N，表示操作数量。接下来N行，每行包含一个操作指令，操作指令为”I x”，”Q x”中的一种。 输出格式 对于每个询问指令“Q x”，输出一个询问结果，如果x在集合中出现过，则输出“Yes”，否则输出“No”。每个结果占一行。 数据范围 1≤N≤105−109≤x≤109 输入样例： 5 I 1I 2I 3Q 2Q 5 输出样例： YesNo 题解： 拉链法： ​ 先找出编号的数据范围MOD，最好是一个质数，这样冲突的几率是最小的，让输入的数字x%mod，这样就可以让x重新编号到0~mod - 1， 有的时候我们得到的余数是一样的，我们可以以这个余数为head， 把这些余数相同的储存到一个链表当中，具体代码如下： 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10, mod = 100003;int h[N], e[N], ne[N], idx = 1;void insert(int x)&#123; int k = (x % mod + mod) % mod; //得到余数head e[idx] = x, ne[idx] = h[k], h[k] = idx++;//在以head为头结点的链表中插入数值&#125;bool Find(int x)&#123; int k = (x % mod + mod) % mod; for(int i = h[k]; i != -1; i = ne[i]) //在以head为头结点的链表中查找x if(e[i] == x)return true; return false;&#125;int main()&#123; int n, x; string s; memset(h, -1, sizeof h); cin &gt;&gt; n; while(n--)&#123; cin &gt;&gt; s &gt;&gt;x; if(s == \"I\")&#123; insert(x); &#125; else &#123; if(Find(x))cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; &#125; return 0;&#125; 开放寻址法： ​ 这种方法也是先让x对mod取模， 得到x应该去到哪个坑里，如果这个坑已经被占了，就继续往下遍历直到寻找到一个没有人的坑位，数据范围往往开到n的俩到三倍。 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 200003, Max = 0x3f3f3f3f;int h[N];int Find(int x)&#123; int k = (x % N + N) % N; //取模 while(h[k] != Max &amp;&amp; h[k] != x)&#123; //找到一个没有人的坑位 k++; if(k == N)k = 0; //如果到头了，就从0重新开始遍历，因为一共就只有n个数，所以肯定有剩余的 //坑位供x使用 &#125; return k; //返回坑位的下标&#125;int main()&#123; int n, x; string s; cin &gt;&gt; n; memset(h, Max, sizeof h);//初始化，开始的时候都没有人 while(n--)&#123; cin &gt;&gt; s &gt;&gt; x; if(s == \"I\")&#123; int k = Find(x); h[k] = x; //把x放到该坑位 &#125; else &#123; int k = Find(x); if(h[k] != Max)cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"哈希","slug":"哈希","permalink":"http://zhumenger.top/tags/哈希/"}]},{"title":"最大异或对","slug":"最大异或对","date":"2019-06-11T03:37:08.000Z","updated":"2019-06-11T03:45:19.192Z","comments":true,"path":"2019/06/11/最大异或对/","link":"","permalink":"http://zhumenger.top/2019/06/11/最大异或对/","excerpt":"","text":"Acwing-&gt;143.最大异或对 题目描述在给定的N个整数A1，A2……AN中选出两个进行xor（异或）运算，得到的结果最大是多少？ 输入格式 第一行输入一个整数N。第二行输入N个整数A1～AN。 输出格式 输出一个整数表示答案。 数据范围 1≤N≤105,0≤Ai&lt;231 输入样例： 3 1 2 3 输出样例： 3 题解：异或+前缀+字典树其实来说,一个整数,是可以转化成为一个32位的二进制数,而也就可以变成长度为32位的二进制字符串.既然如此话,那么我们可以这么做,每一次检索的时候,我们都走与当前Ai的二进制位的数值相反的位置走,这样就可以让Xor值最大,如果说没有路可以走的话,那么就走相同的路.时间复杂度：位数*n，所以是O(32 * n) 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int a[N], trie[N * 32][5], idx;void insert(int x) //建树&#123; int p = 1; for(int i = 30; i &gt;= 0; i--)&#123; int u = x &gt;&gt; i &amp; 1; if(!trie[p][u])trie[p][u] = idx++; p = trie[p][u]; &#125;&#125;int search(int x)//找最大的&#123; int p = 1, ans = 0; for(int i = 30; i &gt;= 0; i--)&#123; int u = x &gt;&gt; i &amp;1; if(trie[p][u^1])&#123; p = trie[p][u^1]; ans +=(1 &lt;&lt; i); &#125; else p = trie[p][u]; &#125; return ans;&#125;int main()&#123; int n; cin &gt;&gt; n; idx =2; for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; a[i]; insert(a[i]); &#125; int res = 0; for(int i = 0; i &lt; n; i++)res = max(res, search(a[i])); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"Trie","slug":"Trie","permalink":"http://zhumenger.top/tags/Trie/"}]},{"title":"Trie-字典树","slug":"Trie-字典树","date":"2019-06-11T00:57:01.000Z","updated":"2019-06-11T03:13:20.709Z","comments":true,"path":"2019/06/11/Trie-字典树/","link":"","permalink":"http://zhumenger.top/2019/06/11/Trie-字典树/","excerpt":"","text":"Trie(字典树): 一种用于实现字符串快速检索的多叉树结构 Trie插入： 当需要插入一个字符串s时，我们令一个指针P起始指向根节点。然后，依次扫描S中的每个字符c：若P的c字符指针指向一个已经存在的节点Q，则令P = Q。若P的c字符指针指向空，则新建一个节点Q，令P的c字符指针指向Q，然后令P = Q。当S中的字符扫描完毕时，在当前节点P上标记它是一个字符串的结尾。 检索： 当需要检索一个字符串S在Trie中是否存在时，我们令一个指针P起初指向根节点，然后依次扫描S中的每个字符c：若P的c字符指针指向空，则说明S没有被插入过Trie，结束检索。若P的c字符指针指向一个已经存在的节点Q，则令P = Q。当S中的字符扫描完毕时，若当前节点P被标记为一个字符串的结尾，则说明S在Trie中存在，否则说明S没有被插入过Trie。 问题描述 “I x”向集合中插入一个字符串x；“Q x”询问一个字符串在集合中出现了多少次。共有N个操作，输入的字符串总长度不超过 105，字符串仅包含小写英文字母。 输入格式 第一行包含整数N，表示操作数。接下来N行，每行包含一个操作指令，指令为”I x”或”Q x”中的一种。 输出格式 对于每个询问指令”Q x”，都要输出一个整数作为结果，表示x在集合中出现的次数。每个结果占一行。 数据范围 1≤N≤2∗104 输入样例： 5 I abcQ abcQ abI abQ ab 输出样例： 1 01 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int trie[N][26], cnt[N], idx;char str[N], c;void insert(char *str)&#123; int len = strlen(str), p = 1; //从根节点开始 for(int i = 0; i &lt; len; i++)&#123; int u = str[i] - 'a'; if(!trie[p][u])//如果没有节点，便创造一个节点 trie[p][u] = idx++; //对每个字符串进行编号 p = trie[p][u]; //p等于该节点，继续往下遍历 &#125; cnt[p]++;// 统计编号为p的字符串的个数&#125;int search(char *str)&#123; int len = strlen(str), p = 1; for(int i = 0; i &lt; len; i++)&#123; int u = str[i] - 'a'; if(!trie[p][u])return 0; //如果该节点为空，说明该字符串没有出现 p = trie[p][u]; &#125; return cnt[p];&#125;int main()&#123; int n; cin &gt;&gt; n; idx = 1; while(n--)&#123; cin &gt;&gt; c &gt;&gt; str; if(c == 'I')insert(str); else cout &lt;&lt; search(str) &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"Trie","slug":"Trie","permalink":"http://zhumenger.top/tags/Trie/"}]},{"title":"单链表","slug":"单链表","date":"2019-06-10T14:32:06.000Z","updated":"2019-06-10T14:33:06.797Z","comments":true,"path":"2019/06/10/单链表/","link":"","permalink":"http://zhumenger.top/2019/06/10/单链表/","excerpt":"","text":"题目描述实现一个单链表，链表初始为空，支持三种操作： (1) 向链表头插入一个数； (2) 删除第k个插入的数后面的数； (3) 在第k个插入的数后插入一个数 现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。 注意:题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。 输入格式 第一行包含整数M，表示操作次数。接下来M行，每行包含一个操作命令，操作命令可能为以下几种：(1) “H x”，表示向链表头插入一个数x。(2) “D k”，表示删除第k个输入的数后面的数（当k为0时，表示删除头结点）。(3) “I k x”，表示在第k个输入的数后面插入一个数x（此操作中k均大于0）。 输出格式 共一行，将整个链表从头到尾输出。 数据范围 1≤M≤100000所有操作保证合法。 输入样例： 10H 9I 1 1D 1D 0H 6I 3 6I 4 5I 4 5I 3 4D 6 输出样例： 6 4 6 5 1.单链表的简单介绍 单链表是一种链式存取的数据结构，用一组任意地址空间（地址空间即存储单元）来存放线性表的数据元素。单链表中的数据是以节点的形式来表示，而节点是用结构体来描述，每个节点都是由元素和指针构成，即该结构体中包含两个成员变量：存放元素的成员变量和存放下一个节点地址的成员变量。 2.顺序表与链表的区别 顺序表的特点为：逻辑相邻的两节点其物理地址也是相邻的；链表的特点为：逻辑相邻的两节点其物理地址不相邻。顺序表的存储方式是：节点元素连续存放在存储单元；链表的存储方式是：节点元素随机存放在存储单元。 链表的插入和删除操作：代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int head; //表示头结点int idx; //表示当前是第几个数int e[N]; //表示第i个数所存储的值int ne[N]; //i的下一个节点void init()&#123; head = -1; //初始化 idx = 0; //下标从0开始&#125;//插入到头结点//1.先用e[idx]存储该值//2.将ne[idx]即第idx个数的下一个节点指向头结点//3.头结点head更新为idx;//4.idx++;void add_to_head(int x)&#123; e[idx] = x, ne[idx] = head, head = idx, idx++; &#125;// 将x插入到第k个数的后面//1.先用e[idx]存储该值x//2.将ne[idx]即第idx个数的下一个节点指向第k个数的下一个节点//3.将ne[k]指向idx;//4.idx++;void add(int k, int x)&#123; e[idx] = x, ne[idx] = ne[k], ne[k] = idx, idx++;&#125;//删除第k个数后面的数//直接让ne[k] = ne[ne[k]]即可void move(int k)&#123; ne[k] = ne[ne[k]];&#125;int main()&#123; int t; init(); cin &gt;&gt; t; while(t--)&#123; char c; int k, x; cin &gt;&gt; c; if(c == 'H')&#123; cin &gt;&gt; x; add_to_head(x); &#125; else if(c == 'D')&#123; cin &gt;&gt; k; if(!k)head = ne[head]; //如果k == 0, 要删除头结点，即让head等于下一个节点 else move(k - 1); &#125; else if(c == 'I')&#123; cin &gt;&gt; k &gt;&gt; x; add(k - 1, x); &#125; &#125; for(int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; ' ' ; cout &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"单链表","slug":"单链表","permalink":"http://zhumenger.top/tags/单链表/"}]},{"title":"直方图中最大的矩形（单调栈2）","slug":"直方图中最大的矩形（单调栈2）","date":"2019-06-10T14:16:22.000Z","updated":"2019-06-10T14:24:55.938Z","comments":true,"path":"2019/06/10/直方图中最大的矩形（单调栈2）/","link":"","permalink":"http://zhumenger.top/2019/06/10/直方图中最大的矩形（单调栈2）/","excerpt":"","text":"题目描述直方图是由在公共基线处对齐的一系列矩形组成的多边形。 矩形具有相等的宽度，但可以具有不同的高度。 例如，图例左侧显示了由高度为2,1,4,5,1,3,3的矩形组成的直方图，矩形的宽度都为1:通常，直方图用于表示离散分布，例如，文本中字符的频率。 现在，请你计算在公共基线处对齐的直方图中最大矩形的面积。 图例右图显示了所描绘直方图的最大对齐矩形。 输入格式 输入包含几个测试用例。每个测试用例占据一行，用以描述一个直方图，并以整数n开始，表示组成直方图的矩形数目。然后跟随n个整数h1，…，hn。这些数字以从左到右的顺序表示直方图的各个矩形的高度。每个矩形的宽度为1。同行数字用空格隔开。当输入用例为n=0时，结束输入，且该用例不用考虑。 输出格式 对于每一个测试用例，输出一个整数，代表指定直方图中最大矩形的区域面积。每个数据占一行。请注意，此矩形必须在公共基线处对齐。 数据范围 1≤n≤100000,0≤hi≤1000000000 输入样例： 7 2 1 4 5 1 3 34 1000 1000 1000 10000 输出样例： 8 4000 题解： 以H[ i ]为高的矩形向左右扩展，找到能够到达的最远距离，即找到左右边界第一个小于H[ i ]的位置， 实际上就是一道单调栈的问题，用一个栈来维护一个单调递增的序列，如果栈中的某个元素比当前的数值的小，那么该元素之后的元素肯定是用不到了，所以就可以直接丢出栈， 并将该值加入栈中，遍历一遍，用ans记录最大值即可 代码如下: 123456789101112131415161718192021222324252627282930313233//这样就形成了一个单调栈#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e6 + 10;typedef long long int ll;int l[N], r[N], h[N], q[N];int n;void get(int a[])&#123; int t = 0; h[0] = -1; for(int i = 1; i &lt;= n; i++)&#123; while(h[q[t]] &gt;= h[i])t--; //找到栈中第一个比该值小的位置 a[i] = q[t]; //记录以H[i]为高能够到达的左右边界 q[++t] = i; //加入栈中 &#125;&#125;int main()&#123; while(cin &gt;&gt; n &amp;&amp; n)&#123; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; h[i]; get(l); //get左边界 reverse(h + 1, h + 1 + n); //翻转 get(r); //get有边界 ll ans = 0; for(int i = 1, j = n; i &lt;= n; i++, j--) ans = max(ans, (ll)h[i] * (n - r[i] - l[j])); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"栈","slug":"栈","permalink":"http://zhumenger.top/tags/栈/"},{"name":"单调栈","slug":"单调栈","permalink":"http://zhumenger.top/tags/单调栈/"}]},{"title":"堆","slug":"堆","date":"2019-06-10T11:07:00.000Z","updated":"2019-06-10T14:24:17.724Z","comments":true,"path":"2019/06/10/堆/","link":"","permalink":"http://zhumenger.top/2019/06/10/堆/","excerpt":"","text":"堆：一种支持插入，删除，查询最值的数据结构，是一颗完全二叉树，实际上就是一个优先队列priority_queue,这里我们用数组的实现这个堆大根堆：树中的任意一个节点的权值都小于等于其父节点小根堆：树中的任意一个节点的权值都大于等于其父节点如何实现堆： 直接用一个数组来保存二叉堆， 逐层的从左到右依次编号，将此编号作为节点在数组中存储的位置。所以，父亲点编号等于子节点编号除以2，左子节点编号等于父节点编号乘以2，又子节点等于父节点编号乘2加1 堆的基本操作： 1求集合中的最小值：h[ 1 ]2.插入一个数：h[++n] = x;up(n); //up函数将x向上调整，找到x的位置，保证堆的有序性3.删除最小值：h[1] = h[n–];down(1) //down函数，将x向下调整，找到x的位置，保证堆的有序性4.删除任意一个元素：h[x] = h[n–];down(x);up(x);//因为不确定x的大小，所以可能是向上调整，也可能是向下调整，这俩个函数虽然都写上了，但实际上只会执行一个，5.修改任意一个元素：h[k] = x;down(k);up(k)//跟4同理时间复杂度：与堆的高度有关，所以是O（logN）代码如下： 题目描述 输入一个长度为n的整数数列，从小到大输出前m小的数。 输入格式 第一行包含整数n和m。第二行包含n个整数，表示整数数列。 输出格式 共一行，包含m个整数，表示整数数列中前m小的数。 数据范围 1≤m≤n≤105，1≤数列中元素≤109 输入样例： 5 34 5 1 3 2 输出样例： 1 2 3 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int h[N], n ,m;void down(int p) //向上调整&#123; int s = 2 * p; //子节点 while(s &lt;= n)&#123; if(s &lt; n &amp;&amp; h[s] &gt; h[s + 1])s++; //找到左右子节点的最小值 if(h[s] &lt; h[p])&#123; //如果子节点比父节点小 swap(h[s], h[p]); //则交换 p = s; //继续向下调整 s = 2 * p; &#125; else break; &#125;&#125;void up(int p) //向上调整，&#123; while(p &gt; 1)&#123; if(h[p] &lt; h[p / 2])&#123; //如果子节点小于父节点 swap(h[p], h[p / 2]); //则交换 p /= 2; //继续向上调整 &#125; else break; &#125;&#125;int main()&#123; cin&gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; h[i]; for(int i = n / 2; i &gt;= 1; i--)down(i); while(m--)&#123; cout &lt;&lt; h[1] &lt;&lt; ' '; h[1] = h[n--]; down(1); &#125; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"堆","slug":"堆","permalink":"http://zhumenger.top/tags/堆/"}]}]}