{"meta":{"title":"zhumenger ❤ blog","subtitle":null,"description":"穿过落雁修竹, 看过日升月暮<br/>你说总有一天你会名扬天下实现你的抱负!","author":"zhumenger","url":"http://zhumenger.top","root":"/"},"pages":[{"title":"about","date":"2019-06-10T09:53:05.000Z","updated":"2019-07-09T07:13:35.130Z","comments":true,"path":"about/index.html","permalink":"http://zhumenger.top/about/index.html","excerpt":"","text":"人生是一个很长很长的梦 每个人都想着把这个梦做得完美 却奈何，奇怪的东西总是会出现在梦里 而我们只会不断沉迷，越陷越深 早已忘却了 这，只是一场梦…"},{"title":"categories","date":"2019-06-10T09:52:55.000Z","updated":"2019-07-09T07:11:48.278Z","comments":true,"path":"categories/index.html","permalink":"http://zhumenger.top/categories/index.html","excerpt":"","text":""},{"title":"guestbook","date":"2019-06-13T15:51:50.000Z","updated":"2019-06-13T15:51:50.980Z","comments":true,"path":"guestbook/index.html","permalink":"http://zhumenger.top/guestbook/index.html","excerpt":"","text":""},{"title":"timeline","date":"2019-06-13T16:10:01.000Z","updated":"2019-07-08T07:17:59.989Z","comments":true,"path":"timeline/index.html","permalink":"http://zhumenger.top/timeline/index.html","excerpt":"","text":""},{"title":"404","date":"2019-06-10T10:17:33.000Z","updated":"2019-06-10T10:17:33.852Z","comments":true,"path":"404/index.html","permalink":"http://zhumenger.top/404/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-10T10:18:32.000Z","updated":"2019-06-10T10:18:32.868Z","comments":true,"path":"tags/index-1.html","permalink":"http://zhumenger.top/tags/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-10T09:52:42.000Z","updated":"2019-07-09T07:11:22.321Z","comments":true,"path":"tags/index.html","permalink":"http://zhumenger.top/tags/index.html","excerpt":"","text":""},{"title":"search","date":"2019-07-09T07:07:01.000Z","updated":"2019-07-09T07:07:01.839Z","comments":true,"path":"search/index-1.html","permalink":"http://zhumenger.top/search/index-1.html","excerpt":"","text":""},{"title":"search","date":"2019-06-10T10:17:29.000Z","updated":"2019-06-10T10:17:29.558Z","comments":true,"path":"search/index.html","permalink":"http://zhumenger.top/search/index.html","excerpt":"","text":""}],"posts":[{"title":"加成序列(迭代加深)","slug":"搜索/加成序列","date":"2019-07-30T04:36:17.000Z","updated":"2019-07-30T04:39:11.478Z","comments":true,"path":"2019/07/30/搜索/加成序列/","link":"","permalink":"http://zhumenger.top/2019/07/30/搜索/加成序列/","excerpt":"","text":"题目描述满足如下条件的序列X（序列中元素被标号为1、2、3…m）被称为“加成序列”： 1、X[1]=1 2、X[m]=n 3、X[1]&lt;X[2]&lt;…&lt;X[m-1]&lt;X[m] 4、对于每个 kk（2≤k≤m2≤k≤m）都存在两个整数 ii 和 jj （1≤i,j≤k−11≤i,j≤k−1，ii 和 jj 可相等），使得X[k]=X[i]+X[j]。 你的任务是：给定一个整数n，找出符合上述条件的长度m最小的“加成序列”。 如果有多个满足要求的答案，只需要找出任意一个可行解。 输入格式输入包含多组测试用例。 每组测试用例占据一行，包含一个整数n。 当输入为单行的0时，表示输入结束。 输出格式对于每个测试用例，输出一个满足需求的整数序列，数字之间用空格隔开。 每个输出占一行。 数据范围1≤n≤100 输入样例： 571215770 输出样例： 1 2 4 51 2 4 6 71 2 4 8 121 2 4 5 10 151 2 4 8 9 17 34 68 77 迭代加深搜索:如果我们想要的答案在一个比较浅的节点上,而树的深度比较深，那么我们进行深度优先搜索的时候便会浪费大量的时间此时，我们可以限制搜索的深度,如果在当前深度找不到答案,就把深度的限制增加,重新搜索，直到找到答案为止,这道题便是这样的一个思路 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 110;int a[N];bool vis[N];int n, k;bool dfs(int u, int k)&#123; if(u == k)return a[u - 1] == n; //暴力枚举 for(int i = u - 1; i &gt;= 0; i--)&#123; for(int j = i; j &gt;= 0; j--)&#123; int s = a[i] + a[j]; if(vis[s] || s &gt; n || s &lt;= a[u - 1])continue; a[u] = s; if(dfs(u + 1, k))return true; &#125; &#125; return false;&#125;int main()&#123; a[0] = 1; while(cin &gt;&gt; n &amp;&amp; n)&#123; int k = 1; //如果不成功，增加搜索深度的限制 while(!dfs(1, k))&#123; memset(vis, false, sizeof vis); k++; &#125; for(int i = 0; i &lt; k; i++)cout &lt;&lt; a[i] &lt;&lt; ' '; cout &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/categories/搜索/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"木棒(学会剪枝)","slug":"搜索/木棒","date":"2019-07-30T04:24:56.000Z","updated":"2019-07-30T14:54:33.383Z","comments":true,"path":"2019/07/30/搜索/木棒/","link":"","permalink":"http://zhumenger.top/2019/07/30/搜索/木棒/","excerpt":"","text":"题目描述乔治拿来一组等长的木棒，将它们随机地砍断，使得每一节木棍的长度都不超过50个长度单位。 然后他又想把这些木棍恢复到为裁截前的状态，但忘记了初始时有多少木棒以及木棒的初始长度。 请你设计一个程序，帮助乔治计算木棒的可能最小长度。 每一节木棍的长度都用大于零的整数表示。 注意: 数据中可能包含长度大于50的木棒，请在处理时忽略这些木棒。 输入格式输入包含多组数据，每组数据包括两行。 第一行是一个不超过64的整数，表示砍断之后共有多少节木棍。 第二行是截断以后，所得到的各节木棍的长度。 在最后一组数据之后，是一个零。 输出格式为每组数据，分别输出原始木棒的可能最小长度，每组数据占一行。 输入样例： 95 2 1 5 2 1 5 2 141 2 3 40 输出样例： 65 题解： 从小到大枚举len, len应该是木棍长度总和sum的约数,并且原始木棍的根数ans = sum / len 搜索的3个状态dfs(int stick, int cnt, int last),stick表示当前正在拼接的原始木棍(前stick - 1个原始木棍已经拼接完成),cnt 表示当前正在拼接的原始木棍的长度,last表示已经拼接到当前原始木棍中的上一个小木棍,暴力枚举就行 如何剪枝，优化时间:一.优化搜索顺序把木棍的长度从大到小排序，优先尝试较长的木棍,减少尝试的次数二.排除等效冗余的情况(1).保证加入到原始木棍中的小木棍的长度是递减的，也就是深搜的时候从当前木棍的下一个木棍开始(2).对于当前的原始木棍，记录当前尝试拼接的小木棍，如果搜索失败,回溯时不再搜索跟其长度相等的木棍(必定也会失败)(3).如果第一次尝试拼入木棍就失败的话,那么这个分治必然也是失败的,因为在拼入这些木棍前,面对的原始木棍都是还没有拼接的,他们都是等效的. 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;const int N = 100;bool vis[N];int n, a[N], len, ans;bool dfs(int stick, int cnt, int last)&#123; if(stick &gt; ans)return true;//全部拼接完毕 if(cnt == len) return dfs(stick + 1, 0, 0);////第stick个原始木棍拼接完毕，拼接下一个 int fail = 0;//用来记录最近一次拼接并且搜索失败的木棍 for(int i = last; i &lt; n; i++)&#123; //没有被访问过，并且可以加上当前小木棍，并且长度和上一次失败的长度不一样 if(!vis[i] &amp;&amp; cnt + a[i] &lt;= len &amp;&amp; fail != a[i])&#123; vis[i] = true;//被访问过 if(dfs(stick, cnt + a[i], i + 1))return true;//如果搜索成功 //搜索失败 vis[i] = 0;//不选这个点 fail = a[i];//记录失败的木棍的长度 ////如果cnt为0,或者相加正好是len,但是失败了,那么一定是失败了 if(cnt == 0 || cnt + a[i] == len)return false; &#125; &#125; return false;&#125;int main()&#123; while(cin &gt;&gt; n &amp;&amp; n)&#123; int sum = 0, val = 0; int k = 0, x; for(int i = 0; i &lt; n; i++)&#123; scanf(\"%d\", &amp;x); if(x &lt;= 50)&#123; a[k++] = x; sum += x;//记录总长度 val = max(val, x); &#125; &#125; n = k; //从大到小排序 sort(a, a + n); reverse(a, a + n); for(len = val; len &lt;= sum; len++)&#123; if(sum % len == 0)&#123; ans = sum / len; memset(vis, false, sizeof vis); if(dfs(1, 0, 0))break; &#125; &#125; printf(\"%d\\n\", len); &#125; return 0;&#125;","categories":[{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/categories/搜索/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"数独(dfs)","slug":"搜索/数独","date":"2019-07-29T10:46:22.000Z","updated":"2019-07-29T11:02:16.611Z","comments":true,"path":"2019/07/29/搜索/数独/","link":"","permalink":"http://zhumenger.top/2019/07/29/搜索/数独/","excerpt":"","text":"题目描述数独是一种传统益智游戏，你需要把一个9 × 9的数独补充完整，使得图中每行、每列、每个3 × 3的九宫格内数字1~9均恰好出现一次。 请编写一个程序填写数独。 输入格式输入包含多组测试用例。 每个测试用例占一行，包含81个字符，代表数独的81个格内数据（顺序总体由上到下，同行由左到右）。 每个字符都是一个数字（1-9）或一个”.”（表示尚未填充）。 您可以假设输入中的每个谜题都只有一个解决方案。 文件结尾处为包含单词“end”的单行，表示输入结束。 输出格式每个测试用例，输出一行数据，代表填充完全后的数独。 输入样例： .2738..1..1…6735…….293.5692.8………..6.1745.364…….9518…7..8..6534.……52..8.4……3…9…5.1…6..2..7……..3…..6…1……….7.4…….3.end 输出样例： 527389416819426735436751829375692184194538267268174593643217958951843672782965341416837529982465371735129468571298643293746185864351297647913852359682714128574936 *题解: * 1.使用二进制初始化行、列和九宫格中能够填入的数有哪些；使用一个数组记录每个数的二进制下都多少个1；2.再使用一个数组记录二进制下1表示的是选的哪个数，使用lowbit运算可以返回能够填入九宫格中的数是哪个3.初始化完毕后，读入字符串，并使用位运算处理出行、列和九宫格中已经填入的数有哪些4.考虑时间的优化，我们每次从九宫格中可以填入的数最少的那个开始，这样我们的选择填入的数就会比较少，减少了时间的复杂度 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;using namespace std;const int N = 9;int r[N], c[N], cell[3][3];//使用位运算来表示行，列和九宫格已经出现了的数char str[100];int ones[1 &lt;&lt; N], map[1 &lt;&lt; N];//ones表示i的二进制中有多少个1inline int lowbit(int x)//lowbit运算，返回最低位的1以及后面的0&#123; return x &amp; (~x + 1);&#125;inline int get(int x, int y)//获得x行y列还有哪些数可以选&#123; return r[x] &amp; c[y] &amp; cell[x / 3][y / 3];//位运算相与&#125;void init()&#123; //预处理，将行，列，九宫格都初始化为二进制111111111，表示1~9都可以填 for(int i = 0; i &lt; 9; i++)r[i] = c[i] = (1 &lt;&lt; N) - 1; for(int i = 0; i &lt; 3; i ++) for(int j = 0; j &lt; 3; j++) cell[i][j] = (1 &lt;&lt; N ) -1; &#125;bool dfs(int cnt)&#123; if(cnt == 0)return true; //找出可选方案数最少的格子 int minv = 10; int x, y; for(int i = 0; i &lt; N; i++)&#123; for(int j = 0; j &lt; N; j++)&#123; if(str[i * 9 + j] == '.')&#123; int t = ones[get(i, j)]; if(t &lt; minv)&#123; minv = t; x = i, y = j; &#125; &#125; &#125; &#125; for(int i = get(x, y); i; i -= lowbit(i))&#123; int t = map[lowbit(i)]; r[x] -= 1 &lt;&lt; t; c[y] -= 1 &lt;&lt; t; cell[x / 3][y / 3] -= 1 &lt;&lt; t; str[x * 9 + y] = '1' + t; if(dfs(cnt - 1))return true; r[x] += 1 &lt;&lt; t; c[y] += 1 &lt;&lt; t; cell[x / 3][y / 3] += 1 &lt;&lt; t; str[x * 9 + y] = '.'; &#125; return false;&#125;int main()&#123; for(int i = 0; i &lt; N; i++)map[1 &lt;&lt; i] = i;//map映射1左移i位对应的是哪个数可以填在九宫格里 //枚举所有的状态，求出i的二进制中有多少个1 for(int i = 0; i &lt; 1 &lt;&lt; N ; i++)&#123; int s = 0; for(int j = i; j != 0; j -=lowbit(j))s++; ones[i] = s;//求出i的二进制中有多少个1 &#125; while(cin &gt;&gt; str &amp;&amp; str[0] != 'e')&#123; init();//初始化 int cnt = 0; for(int i = 0, k = 0; i &lt; 9; i++)&#123; for(int j = 0; j &lt; 9; j++, k++)&#123; if(str[k] != '.')&#123;//如果这个数已经填在了九宫格里，则需要在行，列和九空格中去掉该数 int t = str[k] - '1'; //让该位的二进制为0即可 r[i] -= 1 &lt;&lt; t; c[j] -= 1 &lt;&lt; t; cell[i / 3][j / 3] -= 1 &lt;&lt; t; &#125; else cnt++; &#125; &#125; dfs(cnt); cout &lt;&lt; str &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/categories/搜索/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"},{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/tags/搜索/"}]},{"title":"可达性统计","slug":"搜索/可达性统计","date":"2019-07-28T00:39:15.000Z","updated":"2019-07-28T00:46:55.395Z","comments":true,"path":"2019/07/28/搜索/可达性统计/","link":"","permalink":"http://zhumenger.top/2019/07/28/搜索/可达性统计/","excerpt":"","text":"题目描述 给定一张N个点M条边的有向无环图，分别统计从每个点出发能够到达的点的数量。 输入格式 第一行两个整数N,M，接下来M行每行两个整数x,y，表示从x到y的一条有向边。 输出格式 输出共N行，表示每个点能够到达的点的数量。 数据范围 1≤N,M≤30000 输入样例： 10 103 82 32 55 95 92 33 94 82 104 9 输出样例： 1633211111 题解： x点能到的点的个数等于该点加上它的所有子节点可以达到的点个数，我们可以先拓扑排序，然后从后往前遍历,用位运算求出所有点能够达到的点的数量，位运算我们使用bitset来做： C++ bitset 用法1.C++的 bitset 在 bitset 头文件中，它是一种类似数组的结构，它的每一个元素只能是０或１，每个元素仅用１bit空间。可以用下标的形式对其进行访问 1234567891011bitset&lt;8&gt; foo (&quot;10011011&quot;);cout &lt;&lt; foo.count() &lt;&lt; endl; //5 （count函数用来求bitset中1的位数，foo中共有５个１cout &lt;&lt; foo.size() &lt;&lt; endl; //8 （size函数用来求bitset的大小，一共有８位cout &lt;&lt; foo.test(0) &lt;&lt; endl; //true （test函数用来查下标处的元素是０还是１，并返回false或true，此处foo[0]为１，返回truecout &lt;&lt; foo.test(2) &lt;&lt; endl; //false （同理，foo[2]为０，返回falsecout &lt;&lt; foo.any() &lt;&lt; endl; //true （any函数检查bitset中是否有１cout &lt;&lt; foo.none() &lt;&lt; endl; //false （none函数检查bitset中是否没有１cout &lt;&lt; foo.all() &lt;&lt; endl; //false （all函数检查bitset中是全部为１ 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;bitset&gt;#include&lt;queue&gt;using namespace std;const int N = 3e4 + 10;int n, m;int h[N], e[N], ne[N], idx;int d[N], seq[N];bitset&lt;N&gt; f[N];//bitsetvoid add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;void topsort()&#123; queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i++) if(!d[i])q.push(i); int k = 0; while(q.size())&#123; int t = q.front(); q.pop(); seq[k++] = t; for(int i = h[t]; i != -1; i = ne[i])&#123; int u = e[i]; d[u]--; if(!d[u])q.push(u); &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof h); for(int i = 0; i &lt; m; i++)&#123; int a, b; cin &gt;&gt;a &gt;&gt; b; add(a, b); d[b]++; &#125; topsort(); for(int i = n - 1; i &gt;= 0; i--)&#123; int u = seq[i]; f[u][u] = 1; for(int j = h[u]; j != -1; j = ne[j])&#123; f[u] |= f[e[j]]; &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; cout &lt;&lt; f[i].count() &lt;&lt; endl;//求f[i]中1的个数 &#125;&#125;","categories":[{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/categories/搜索/"}],"tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"生日礼物","slug":"数据结构基础/生日礼物","date":"2019-07-27T05:18:43.000Z","updated":"2019-07-27T05:21:30.468Z","comments":true,"path":"2019/07/27/数据结构基础/生日礼物/","link":"","permalink":"http://zhumenger.top/2019/07/27/数据结构基础/生日礼物/","excerpt":"","text":"生日礼物题目描述 翰翰18岁生日的时候，达达给她看了一个神奇的序列 A1,A2,…,ANA1,A2,…,AN。 她被允许从中选择不超过 M 个连续的部分作为自己的生日礼物。 翰翰想要知道选择元素之和的最大值。 你能帮助她吗？ 输入格式 第一行包含两个整数N,M。 第二行包含N个整数A1A1~ANAN。 输出格式 输出一个整数，表示答案。 数据范围 1≤N,M≤105|Ai|≤104 输入样例： 5 22 -3 2 -1 2 输出样例： 5 题解： 1.将整个序列分为正负交替的序: 如果数x与前面的符号相同，就加起来，否则新开一个空间存储当前的数x2.统计正数的个数cnt，如果cnt &lt;= m,把所有正数加起来，输出便是我们的答案3.如果cnt &gt; m, 必须减少正数的个数，有俩种做法 1.直接删去最小的正数,2.将俩个正数合并为1个连续子序列，中间必有一个负数，还需要加上负数的值 4.删去正数,或者加上负数，都可以看成减去他们的绝对值，可以用堆来存储他们 的绝对值，以及他们的下标5.如果删除的是正数，正数的俩边都是负数，需要将俩边的负数合并，重新放到堆中。 并删除左右节点，6.如果删除的是负数，负数的俩边都是正数，需要将俩边的正数合并，重新放到堆中。 并删除左右节点， 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#include&lt;queue&gt;#include&lt;vector&gt;const int N = 1e5 + 10;int n, m;int a[N], l[N], r[N];bool vis[N];typedef pair&lt;int, int&gt; p;void remove(int x)&#123; l[r[x]] = l[x]; r[l[x]] = r[x]; vis[x] = true;&#125;int main()&#123; int k = 0; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)&#123; int x; cin &gt;&gt; x; if(x == 0)continue; if(a[k] * x &gt; 0)a[k] += x; else a[++k] = x; &#125; int cnt = 0, res = 0; priority_queue&lt;p, vector&lt;p&gt;, greater&lt;p&gt; &gt; q; for(int i = 1; i &lt;= k; i++)&#123; if(a[i] &gt; 0)&#123; cnt++; res += a[i]; &#125; l[i] = i - 1; r[i] = i + 1; q.push(&#123;abs(a[i]), i&#125;); &#125; while(cnt &gt; m)&#123; while(vis[q.top().second])q.pop(); p t = q.top(); q.pop(); int v = t.first, point = t.second; if(l[point] != 0 &amp;&amp; r[point] != k + 1 || a[point] &gt; 0)&#123; res -= v; cnt--; int left = l[point], right = r[point]; a[point] += a[left] + a[right]; q.push(&#123;abs(a[point]), point&#125;); remove(left); remove(right); &#125; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"二叉堆","slug":"二叉堆","permalink":"http://zhumenger.top/tags/二叉堆/"},{"name":"链表","slug":"链表","permalink":"http://zhumenger.top/tags/链表/"}]},{"title":"黑盒子(堆)","slug":"数据结构基础/黑盒子-堆","date":"2019-07-27T05:13:55.000Z","updated":"2019-07-27T05:14:41.478Z","comments":true,"path":"2019/07/27/数据结构基础/黑盒子-堆/","link":"","permalink":"http://zhumenger.top/2019/07/27/数据结构基础/黑盒子-堆/","excerpt":"","text":"题目描述 黑盒子代表一个原始的数据库。 它可以用来储存整数数组，并且它拥有一个特殊变量i。 在最开始，黑盒子是空的，并且i=0。 现在对黑盒子进行一系列的操作处理，操作包括以下两种： 1、ADD(x)：表示将x加入到黑盒子中。2、GET：使i增加1，输出黑盒子中第i小的数值（即将所有数按升序排序后的第i个数）。 1、A(1),A(2),…,A(M)：这个序列由加入到黑盒子内的所有元素按加入顺序排列后得到， 2、u(1),u(2),…,u(N): 这个序列的第i项表示的是第i次GET操作时，盒子内元素的数量。 现在请你根据给出的序列A和u求出操作过程中输出的所有数值。 输入格式 输入包括三行。 第一行包含两个整数M和N，表示A序列和u序列的长度。 第二行包含M个整数，表示A序列的每一个元素。 第三行包含N个整数，表示u序列的每一个元素。 同行每个数之间用空格隔开。 输出格式 输出操作过程中所有GET操作输出的数值。 每个数值占一行。 数据范围 |A(i)|&lt;=2∗1091≤N≤M≤30000,对于所有p（1≤p≤N）, p≤u(p)≤M成立 输入样例： 7 43 1 -4 2 8 -1000 21 2 6 6 输出样例： 3312 题解： 输出序列中第i小的数，我们可以用堆来做： 1.首先定义俩个堆，一个大根堆，一个小根堆，大根堆用来存储前x - 1小的数，小根堆用来存剩下的数 2.俩个堆满足：大根堆中的最大值一定是小于小根堆中的最小值的，这样我们输出第x小的数时，直接输出小根堆的堆顶即可 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int N = 30010;int a[N];int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; priority_queue&lt;int&gt; q1;//大根堆,维护前x - 1个最小值， priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q2;//小根堆，堆顶是第x个最小值 int k = 1; for(int i = 1; i &lt;= m; i++)&#123; int x; cin &gt;&gt; x; while(k &lt;= x)&#123; //如果盒子内的元素个数小于get时的元素个数时 q2.push(a[k]); //大根堆的最大值一定是小于小根堆中的最小值，如果不是，则交换 //这样可以用大根堆维护前x - 1个最小值 if(!q1.empty() &amp;&amp; q1.top() &gt; q2.top())&#123; int u = q1.top(); q1.pop(); q2.push(u); int t = q2.top(); q2.pop(); q1.push(t); &#125; k++; &#125; cout &lt;&lt; q2.top() &lt;&lt; endl; q1.push(q2.top()); q2.pop(); &#125; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"堆","slug":"堆","permalink":"http://zhumenger.top/tags/堆/"}]},{"title":"奶牛矩阵（二维KMP）","slug":"数据结构基础/奶牛矩阵（二维KMP）","date":"2019-07-27T04:44:57.000Z","updated":"2019-07-27T04:45:57.370Z","comments":true,"path":"2019/07/27/数据结构基础/奶牛矩阵（二维KMP）/","link":"","permalink":"http://zhumenger.top/2019/07/27/数据结构基础/奶牛矩阵（二维KMP）/","excerpt":"","text":"题目描述 每天早上，农夫约翰的奶牛们被挤奶的时候，都会站成一个R行C列的方阵。 现在在每个奶牛的身上标注表示其品种的大写字母，则所有奶牛共同构成了一个R行C列的字符矩阵。 现在给定由所有奶牛构成的矩阵，求它的最小覆盖子矩阵的面积是多少。 如果一个子矩阵无限复制扩张之后得到的矩阵能包含原来的矩阵，则称该子矩阵为覆盖子矩阵。 输入格式 第1行：输入两个用空格隔开的整数，R和C。 第2..R+1行：描绘由奶牛构成的R行C列的矩阵，每行C个字符，字符之间没有空格。 输出格式 输出最小覆盖子矩阵的面积。（每个字符的面积为1） 数据范围 1≤R≤10000,1≤C≤75 输入样例： 2 5ABABAABABA 输出样例： 2 提示 样例中给出的矩阵的最小覆盖子矩阵为AB，面积为2。 题解：KMP中Next数组的应用，如果n是n - Next[n]的倍数，那么n - Next[n]便是该字符串的循环节 1.可以把每一行看成一个字符，求出行的Next数组,并求出循环节 2.把每一列看做一个字符，求出列的Next数组，并求出循环节 3.俩个循环节的乘积便是该矩阵循环节的面积的大小 代码如下： 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 10010, M = 80;int Next[N];char s1[N][M], s2[M][N];int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; s1[i]; for(int i = 1; i &lt;= n; i++) for(int j = 0; j &lt; m; j++) s2[j + 1][i - 1] = s1[i][j];//将数组翻转，用来求列的Next数组 for(int i = 2, j = 0; i &lt;= n; i++)&#123;//求出行的Next数组 while(j &amp;&amp; strcmp(s1[i], s1[j + 1]))j = Next[j]; if(!strcmp(s1[i], s1[j + 1]))j++; Next[i] = j; &#125; int a = n - Next[n]; Next[1] = 0; for(int i = 2, j = 0; i &lt;= m; i++)&#123;//求出列的Next数组 while(j &amp;&amp; strcmp(s2[i], s2[j + 1]))j = Next[j]; if(!strcmp(s2[i], s2[j + 1]))j++; Next[i] = j; &#125; int b = m - Next[m]; cout &lt;&lt; a * b &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"kmp","slug":"kmp","permalink":"http://zhumenger.top/tags/kmp/"}]},{"title":"树的最小表示","slug":"数据结构基础/树的最小表示","date":"2019-07-27T04:34:19.000Z","updated":"2019-07-27T04:35:29.017Z","comments":true,"path":"2019/07/27/数据结构基础/树的最小表示/","link":"","permalink":"http://zhumenger.top/2019/07/27/数据结构基础/树的最小表示/","excerpt":"","text":"树的最小表示题目描述 给你两个字符串，字符串由01组成，0表示向远离起点并且没有走过的一条路走去，1表示原路返回 请你求出这俩个字符串是否是一个线路图 输入格式 第一行输入一个正整数n，代表测试用例数量。 每个测试用例由两行组成，每行输入一个由字符“0”和“1”构成的字符串，长度最多为3000， 两个字符串都描述了一种线路图的探索路线。 输出格式 对于每个测试用例，如果两个字符串描述的线路图可以视为同一个线路图，则输出same。 否则，输出different。 每行输出一个结果。 输入样例： 20010011101001011010001101100101101001011001001110011000111010101 输出样例： samedifferent 题解： 树的最小表示，将所有子节点的dfs序从小到大排序，并连接起来，比较他们的最小表示是否相同即可 代码如下： 123456789101112131415161718192021222324252627282930313233// 树的最小表示可以递归实现，求出所有子树的dfs序，然后从小到大排序拼接起来#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;string dfs(string seq, int &amp;u)//防止内存超限&#123; vector&lt;string &gt; seqs; u++; while(seq[u] == '0')seqs.push_back(dfs(seq, u)); u++; sort(seqs.begin(), seqs.end()); string s= \"0\"; for( auto res : seqs)s += res; s += \"1\"; return s;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; string a, b; cin &gt;&gt; a &gt;&gt; b; a = '0' + a + '1'; b = '0' + b + '1'; int ua = 0, ub = 0; if(dfs(a, ua) == dfs(b, ub))puts(\"same\"); else puts(\"different\"); &#125; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"树的最小表示","slug":"树的最小表示","permalink":"http://zhumenger.top/tags/树的最小表示/"}]},{"title":"矩阵(二维数组哈希)","slug":"数据结构基础/矩阵(二维数组哈希) ","date":"2019-07-27T04:18:40.000Z","updated":"2019-07-27T04:21:21.340Z","comments":true,"path":"2019/07/27/数据结构基础/矩阵(二维数组哈希) /","link":"","permalink":"http://zhumenger.top/2019/07/27/数据结构基础/矩阵(二维数组哈希) /","excerpt":"","text":"题目描述 给定一个M行N列的01矩阵（只包含数字0或1的矩阵），再执行Q次询问，每次询问给出一个A行B列的01矩阵，求该矩阵是否在原矩阵中出现过。 输入格式 第一行四个整数M,N,A,B。 接下来一个M行N列的01矩阵，数字之间没有空格。 接下来一个整数Q。 接下来Q个A行B列的01矩阵，数字之间没有空格。 输出格式 对于每个询问，输出1表示出现过，0表示没有出现过。 数据范围 A≤100，M,N,B≤1000，Q≤1000 输入样例： 3 3 2 21110001113110011110011 输出样例： 101 题解： 二维数组哈希 1.先预处理出每一行的哈希值，这样可以在O(1)的时间内获得任意子段的哈希值 2.二维数组哈希的进制位数从子矩阵的右下角开始，比如长和宽都为2子矩阵的哈希值为:h = a[0] [0] * p^3 + a[0] [1] * p^2 + a[1] [0] * p^1 + a[1] [1] * p^0 3.假设要求一个a行b列的子矩阵是否出现过，用S来表示子矩阵的哈希值；先枚举每一列，维护一个长度为b的矩阵，再枚举每一行，获得每一行长度为b的哈希值，那么原先子矩阵的所有位数都要扩大P^b, 那么此时的子矩阵的哈希值S = S * p ^ b + hash(i, l, r) 4.如果矩阵的行数大于a行，还需要减去最上面的那一行，此时子矩阵的哈希值S = S - hash(i - a + 1, l, r) * p ^ (a*b) 5.获得每个子矩阵的hash值后，用哈希表来存储即可 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;unordered_map&gt;using namespace std;typedef unsigned long long ULL;const int N = 1010, base = 131;int n, m, a, b;ULL h[N][N], p[N * N];char s[N];ULL get(ULL f[], int l, int r)&#123; return f[r] - f[l - 1] * p[r - l + 1];&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b; p[0] = 1; for(int i = 1; i &lt;= n * m; i++) p[i] =p[i - 1] * base; for(int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; (s + 1); //预处理每一行的哈希值 for(int j = 1; j &lt;= m; j++)h[i][j] = h[i][j - 1] * base + s[j] - '0'; &#125; unordered_map&lt;ULL, int&gt; S; for(int i = b; i &lt;= m; i++)&#123; ULL ans = 0; int l = i - b + 1, r = i; for(int j = 1; j &lt;= n; j++)&#123; //每处理一行，前面的数的位数都要提升b位,再加上本行的哈希值 //便是这个矩阵的哈希值 ans = ans * p[b] + get(h[j], l, r); //如果j &gt; a, 还需要减去之前的一行，保证这个矩阵是a * b的 //也就是减去之前一行的哈希值乘以它的位数，即h[j - a]这一行 //在l到r这个区间的a * b位 if(j &gt; a)ans -= get(h[j - a], l, r) * p[a * b]; if(j &gt;= a)S[ans]++; &#125; &#125; int k; cin &gt;&gt; k; while(k--)&#123; ULL ans = 0; for(int i = 0; i &lt; a; i++)&#123; cin &gt;&gt; s; for(int j = 0; j &lt; b; j++)ans = ans * base + s[j] - '0'; &#125; if(S[ans])puts(\"1\"); else puts(\"0\"); &#125; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"哈希","slug":"哈希","permalink":"http://zhumenger.top/tags/哈希/"},{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"}]},{"title":"城市游戏","slug":"数据结构基础/城市游戏(二维单调栈)","date":"2019-07-27T03:50:46.000Z","updated":"2019-07-27T03:52:05.892Z","comments":true,"path":"2019/07/27/数据结构基础/城市游戏(二维单调栈)/","link":"","permalink":"http://zhumenger.top/2019/07/27/数据结构基础/城市游戏(二维单调栈)/","excerpt":"","text":"题目描述 有一天，小猫rainbow和freda来到了湘西张家界的天门山玉蟾宫，玉蟾宫宫主蓝兔盛情地款待了它们，并赐予它们一片土地。 这片土地被分成N*M个格子，每个格子里写着’R’或者’F’，R代表这块土地被赐予了rainbow，F代表这块土地被赐予了freda。 现在freda要在这里卖萌。。。它要找一块矩形土地，要求这片土地都标着’F’并且面积最大。 但是rainbow和freda的OI水平都弱爆了，找不出这块土地，而蓝兔也想看freda卖萌（她显然是不会编程的……），所以它们决定，如果你找到的土地面积为S，它们将给你3*S两银子。 输入格式 第一行包括两个整数N,M，表示矩形土地有N行M列。 接下来N行，每行M个用空格隔开的字符’F’或’R’，描述了矩形土地。 每行末尾没有多余空格。 输出格式 输出一个整数，表示你能得到多少银子，即(3*最大’F’矩形土地面积)的值。 数据范围 1≤N,M≤1000 输入样例： 5 6R F F F F FF F F F F FR R R F F FF F F F F FF F F F F F 输出样例： 45 题解： 二维数组单调栈问题，这个可以参考Acwing131.直方图中最大的矩形，俩个题的解题思路大致一样，只不过这里需要转化为Acwing131题的形式： 1.首先预处理出每一列连续的F的个数 2.枚举每一行，表示以该行为底，以H(i, j)为高的矩阵可以求得的面积最大值 时间复杂度为O(n * m) 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int h[N][N], l[N], r[N], q[N], t;char a[N][N];int n, m;void get(int h[], int l[])&#123; int t = 0; for(int i = 1; i &lt;= m; i++)&#123; while(t &gt; 0 &amp;&amp; h[q[t]] &gt;= h[i])t--; l[i] = q[t] + 1; q[++t] = i; &#125;&#125;int work(int h[])&#123; get(h, l); reverse(h + 1, h + 1 + m); get(h, r); reverse(h + 1, h + 1 + m); int res = 0; for(int i = 1; i &lt;= m; i++)&#123; res = max(res, h[i] * (m + 1 - r[m + 1 - i] - l[i] + 1)); &#125; return res;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; cin &gt;&gt; a[i][j]; if(a[i][j] == 'F') h[i][j] = 1 + h[i - 1][j]; &#125; &#125; int ans = 0; for(int i = 1; i &lt;= n; i++) ans = max(ans, work(h[i])); cout &lt;&lt; ans * 3 &lt;&lt; endl;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"栈","slug":"栈","permalink":"http://zhumenger.top/tags/栈/"}]},{"title":"括号配对问题","slug":"数据结构基础/括号配对问题","date":"2019-07-27T03:47:40.000Z","updated":"2019-07-27T03:54:56.202Z","comments":true,"path":"2019/07/27/数据结构基础/括号配对问题/","link":"","permalink":"http://zhumenger.top/2019/07/27/数据结构基础/括号配对问题/","excerpt":"","text":"一.括号配对问题问题描述 现在，有一行括号序列，请你检查这行括号是否配对。 输入格式 第一行输入一个数N（0&lt;N&lt;=100）,表示有N组测试数据。后面的N行输入多组输入数据 每组输入数据都是一个字符串S(S的长度小于10000，且S不是空串）， 测试数据组数少于5组。数据保证S中只含有”[“, “]”, “(“, “)” 四种字符 输出格式 每组输入数据的输出占一行，如果该字符串中所含的括号是配对的，则输出Yes,如果不配对则输出No 输入样例 3[(])(])([[] ()]) 输出样例 NoNoYes 题解： 栈的应用，如果栈顶与当前的元素匹配，则弹出栈，否则就入栈，最后看看栈中的元素是否为空即可 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e5 + 10;char st[N];int t;string s;int main()&#123; int n; cin &gt;&gt; n; while(n--)&#123; t = 0; cin &gt;&gt; s; int len = s.size(); for(int i = 0; i &lt; len; i++)&#123; if(t &gt; 0 &amp;&amp; s[i] == ')' &amp;&amp; st[t] == '(')t--; else if(t &gt; 0 &amp;&amp; s[i] == '&#125;' &amp;&amp; st[t] == '&#123;')t--; else if(t &gt; 0 &amp;&amp; s[i] == ']' &amp;&amp; st[t] == '[')t--; else st[++t] = s[i]; &#125; if(t &gt; 0)cout &lt;&lt; \"No\" &lt;&lt; endl; else cout &lt;&lt; \"Yes\" &lt;&lt; endl; &#125; return 0;&#125; 二.括号最长匹配长度题目描述 达达是一名漫画家，她有一个奇特的爱好，就是在纸上画括号。 这一天，刚刚起床的达达画了一排括号序列，其中包含小括号( )、中括号[ ]和大括号{ }，总长度为N。 这排随意绘制的括号序列显得杂乱无章，于是达达定义了什么样的括号序列是美观的： (1) 空的括号序列是美观的； (2) 若括号序列A是美观的，则括号序列 (A)、[A]、{A} 也是美观的； (3) 若括号序列A、B都是美观的，则括号序列AB也是美观的。 例如 [(){}]() 是美观的括号序列，而)({)[}]( 则不是。 现在达达想在她绘制的括号序列中，找出其中连续的一段，满足这段子序列是美观的，并且长度尽量大。 你能帮帮她吗？ 输入格式 输入一行由括号组成的字符串。 输出格式 输出一个整数，表示最长的美观的子段的长度。 数据范围 字符串长度不超过100000。 输入样例：1(&#123;(&#123;((&#123;()&#125;&#125;)&#125;&#123;())&#125;)&#125;)[)&#123;&#123;&#123;([)()((()]]&#125;])[&#123;)]&#125;&#123;[&#125;&#123;) 输出样例： 4 题解： 栈的应用：如果栈顶的与当前的元素能匹配，则出栈，并记录当前能匹配的最长长度，如果不能匹配，则出栈，重新记录长度，找到最大值即可 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e5 + 10;char s[N];stack&lt;int&gt; st;int main()&#123; cin &gt;&gt; s; int ans = 0; int len =strlen(s); for(int i = 0; i &lt; len; i++)&#123; if(s[i] == ')' &amp;&amp; st.size() &amp;&amp; s[st.top()] == '(')st.pop(); else if(s[i] == ']' &amp;&amp; st.size() &amp;&amp; s[st.top()] == '[')st.pop(); else if(s[i] == '&#125;' &amp;&amp; st.size() &amp;&amp; s[st.top()] == '&#123;')st.pop(); else st.push(i); if(st.size())ans = max(ans, i - st.top()); else ans = max(ans, i + 1); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"栈","slug":"栈","permalink":"http://zhumenger.top/tags/栈/"}]},{"title":"表达式计算","slug":"数据结构基础/表达式计算","date":"2019-07-23T01:46:38.000Z","updated":"2019-07-23T01:48:30.689Z","comments":true,"path":"2019/07/23/数据结构基础/表达式计算/","link":"","permalink":"http://zhumenger.top/2019/07/23/数据结构基础/表达式计算/","excerpt":"","text":"表达式计算4题目描述 给出一个表达式,其中运算符仅包含+,-,*,/,^（加 减 乘 整除 乘方）要求求出表达式的最终值。 数据可能会出现括号情况，还有可能出现多余括号情况。 数据保证不会出现大于或等于231231的答案。 数据可能会出现负数情况。 输入格式 输入仅一行，即为表达式。 输出格式 输出仅一行，既为表达式算出的结果。 输入样例： (2+2)^(1+1) 输出样例： 16 题解： 栈的应用：用俩个栈分别存数字和运算符 1.因为有多余括号的情况，所以所限要在字符串前加上字符串长度大小的‘（’进行预处理 2.如果当前字符为数字，则直接存进nums栈中 3.如果当前字符为加或减，首先判断减是否为负号，如果不是，其他运算符的优先级都是大于等于加或减的，所以就可以把括号中所有的元素进行一次操作，直到遇到’(‘为止 4.如果当前字符为乘或除，加、减的优先级都是低于乘除的，所以不能进运算，能进行运算的是乘除和乘方 5.当前运算符为乘方，只有栈顶为乘方才能进行运算 6.如果当前字符为‘(’,直接添加到栈中 7.如果当前元素为’)’，则将括号中所有的元素进行运算，并弹出’(‘ 8.最后输出栈顶元素即可 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;stack&lt;int&gt; nums;stack&lt;char&gt; ops;int qmi(int a, int k)&#123; int res = 1; while (k -- ) res *= a; return res;&#125;void cal()&#123; int a = nums.top(); nums.pop(); int b = nums.top(); nums.pop(); char c = ops.top(); ops.pop(); int d; if (c == '+') d = b + a; else if (c == '-') d = b - a; else if (c == '*') d = b * a; else if (c == '/') d = b / a; else d = qmi(b, a); nums.push(d);&#125;int main()&#123; string str; cin &gt;&gt; str; string left; for (int i = 0; i &lt; str.size(); i ++ ) left += '('; str = left + str + ')'; for (int i = 0; i &lt; str.size(); i ++ ) &#123; if (str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9')//如果是数字 &#123; int j = i, t = 0; while (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')//可能有多位 &#123; t = t * 10 + str[j] - '0'; j ++ ; &#125; nums.push(t); i = j - 1; &#125; else//如果是运算符 &#123; char c = str[i]; if (c == '(') ops.push(c); else if (c == '+' || c == '-') &#123; if (c == '-' &amp;&amp; i &amp;&amp; !(str[i - 1] &gt;= '0' &amp;&amp; str[i - 1] &lt;= '9') &amp;&amp; str[i - 1] != ')')//如果是负号的话 &#123; int j = i + 1, t = 0; while (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')//可能有多位 &#123; t = t * 10 + str[j] - '0'; j ++ ; &#125; nums.push(-t);//添加-t i = j - 1; &#125; else &#123; while (ops.top() != '(') cal(); ops.push(c); &#125; &#125; else if (c == '*' || c == '/') &#123; while (ops.top() == '*' || ops.top() == '/' || ops.top() == '^') cal(); ops.push(c); &#125; else if (c == '^') &#123; while (ops.top() == '^') cal(); ops.push(c); &#125; else if (c == ')') &#123; while (ops.top() != '(') cal(); ops.pop(); &#125; else cout &lt;&lt; \"invalid operator!\" &lt;&lt; endl; &#125; &#125; cout &lt;&lt; nums.top() &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"栈","slug":"栈","permalink":"http://zhumenger.top/tags/栈/"}]},{"title":"没有上司的舞会","slug":"动态规划/没有上司的舞会","date":"2019-07-22T02:55:39.000Z","updated":"2019-07-22T03:19:54.930Z","comments":true,"path":"2019/07/22/动态规划/没有上司的舞会/","link":"","permalink":"http://zhumenger.top/2019/07/22/动态规划/没有上司的舞会/","excerpt":"","text":"题目描述 Ural大学有N名职员，编号为1~N。 他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。 每个职员有一个快乐指数，用整数 HiHi 给出，其中 1≤i≤N。 现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。 在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。 输入格式 第一行一个整数N。 接下来N行，第 i 行表示 i 号职员的快乐指数Hi。 接下来N-1行，每行输入一对整数L, K,表示K是L的直接上司。 最后一行输入0,0。 输出格式输出最大的快乐指数。 数据范围1≤N≤6000−128≤Hi≤127 输入样例： 711111111 32 36 47 44 53 50 0 输出样例： 5 *树形DP: * 就是在树或图上的一种DP，一般是某个父节点或子节点有特殊要求的时候用的一种DP 首先是建图，在图上遍历的时候进行DP操作，对于这道题来说我们用F(i, j)来表示i这个节点，状态为 j (用0来表示不选，用1来表示选)值的最大值，对于每个节点我们有俩种操作： 1.选当前这个节点，j 状态为1，它的子节点只能不选，所以f(i, 1) = f(i, 1) + f(u, 0)(u表示 i 的子节点) 2.不选当前这个节点，j 的状态为0，它的子节点可以选，也可以不选，取俩者的最大值 所以f(i, 0) = f(i, 0) + max(f(u, 1), f(u, 0))(u表示 i 的子节点) 3.从任意一个跟节点开始搜索，所以还需要一个数组来储存哪些节点有父节点 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 6010;int n;int happy[N];int h[N], e[N], ne[N], idx;//邻接表建图int f[N][2];bool vis[N];void add(int a, int b)//添加边&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;void dfs(int cur)//搜索，树形DP&#123; f[cur][1] = happy[cur]; for(int i = h[cur]; i != -1; i = ne[i])&#123;//遍历子节点 int j = e[i]; dfs(j); f[cur][0] += max(f[j][0], f[j][1]); f[cur][1] += f[j][0]; &#125;&#125;int main()&#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++)cin &gt;&gt; happy[i];//输入 memset(h, -1, sizeof h); for(int i = 0; i &lt; n - 1; i++)&#123; int a, b; cin &gt;&gt; a &gt;&gt; b; vis[a] = true; //表示a有父节点 add(b, a); &#125; int root = 1; while(vis[root])root++;///找到一个根节点 dfs(root); cout &lt;&lt; max(f[root][0], f[root][1]); return 0;&#125;","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/categories/动态规划/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"树形DP","slug":"树形DP","permalink":"http://zhumenger.top/tags/树形DP/"}]},{"title":"滑雪","slug":"搜索/滑雪","date":"2019-07-22T02:36:56.000Z","updated":"2019-07-22T02:50:40.818Z","comments":true,"path":"2019/07/22/搜索/滑雪/","link":"","permalink":"http://zhumenger.top/2019/07/22/搜索/滑雪/","excerpt":"","text":"滑雪题目描述 给定一个R行C列的矩阵，表示一个矩形网格滑雪场。 矩阵中第 i 行第 j 列的点表示滑雪场的第 i 行第 j 列区域的高度。 一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。 当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。 下面给出一个矩阵作为例子： 1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9 在给定矩阵中，一条可行的滑行轨迹为24-17-2-1。 在给定矩阵中，最长的滑行轨迹为25-24-23-…-3-2-1，沿途共经过25个区域。 现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。 输入格式 第一行包含两个整数R和C。 接下来R行，每行包含C个整数，表示完整的二维矩阵。 输出格式 输出一个整数，表示可完成的最长滑雪长度。 数据范围 1≤R,C≤3000≤矩阵中整数≤10000 输入样例： 5 51 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9 输出样例： 25 题解： 所谓记忆化搜索是指在搜索过程中，用一个数组来储存已经得到的结果，当我们再次经过这一状态时，直接返回该结果即可，不必再次深度搜索，大大的节省了时间 *代码如下： * 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 310, INF = 0x3f3f3f3f;int a[N][N], f[N][N];int n, m;int dx[]= &#123;0, 1, 0, -1&#125;;int dy[] = &#123;1, 0, -1, 0&#125;;int dfs(int x, int y)&#123; if(f[x][y])return f[x][y]; f[x][y] = 1; //最小是1 for(int k = 0; k &lt; 4; k++)&#123; int i = x + dx[k]; int j = y + dy[k]; if(a[i][j] &lt; a[x][y] &amp;&amp; i &gt;= 1 &amp;&amp; j &gt;= 1 &amp;&amp; i &lt;= n &amp;&amp; j &lt;= m) f[x][y] = max(f[x][y], dfs(i, j) + 1); &#125; return f[x][y];&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; memset(a, INF, sizeof a); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) cin &gt;&gt; a[i][j]; int ans = 0; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) ans = max(ans, dfs(i, j)); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/categories/搜索/"}],"tags":[{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"http://zhumenger.top/tags/记忆化搜索/"}]},{"title":"动态规划之子序列问题","slug":"动态规划/动态规划之子序列问题","date":"2019-07-22T02:24:20.000Z","updated":"2019-07-22T02:26:20.516Z","comments":true,"path":"2019/07/22/动态规划/动态规划之子序列问题/","link":"","permalink":"http://zhumenger.top/2019/07/22/动态规划/动态规划之子序列问题/","excerpt":"","text":"一.最长递增子序列I题目描述 给定一个长度为N的数列，求数值严格单调递增的子序列的长度最长是多少。 输入格式 第一行包含整数N。 第二行包含N个整数，表示完整序列。 输出格式 输出一个整数，表示最大长度。 数据范围 1≤N≤1000，−109≤数列中的数≤109 输入样例： 73 1 2 1 8 5 6 输出样例： 4 思路： 采用动态规划的思想，用dp[ i ]来表示序列中第i个元素结尾的最长上升子序列的长度那么状态转移方程为： if (a[i] &gt; a[j]) dp[i] = MAX (dp[i], dp[j] + 1); 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;const int N = 1010;int d[N], a[N];int main()&#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; int ans = 0; for(int i = 0; i &lt; n; i++)&#123; d[i] = 1; for(int j = 0; j &lt; i; j++)&#123; if(a[i] &gt; a[j]) d[i] = max(d[i], d[j] + 1); &#125; ans = max(ans, d[i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 二. 最长递增子序列II给定一个长度为N的数列，求数值严格单调递增的子序列的长度最长是多少。 输入格式第一行包含整数N。 第二行包含N个整数，表示完整序列。 输出格式输出一个整数，表示最大长度。 数据范围1≤N≤100000 −109≤数列中的数≤109 输入样例： 73 1 2 1 8 5 6 输出样例： 4 题解： 这里的数据范围很大,不能再用上面的那个方法来做这道题 nlgn做法 定义：a[1..n]为原始序列，d[k]表示长度为k的不下降子序列末尾元素的最小值，len表示当前已知的最长子序列的长度 考虑两个数a[x]和a[y]，x&lt;y且a[x]&lt;a[y],且dp[x]=dp[y]，当a[t]要选择时，到底取哪一个构成最优的呢？显然选取a[x]更有潜力，因为可能存在a[x]&lt;a[z]&lt;a[y]，这样a[t]可以获得更优的值。在这里给我们一个启示，当dp[t]一样时，尽量选择更小的a[x]. ​ 按dp[t]=k来分类，只需保留dp[t]=k的所有a[t]中的最小值，设d[k]记录这个值，d[k]=min{a[t],dp[t]=k}。 ​ 这时注意到d的两个特点（重要）： *1. d[k]在计算过程中单调不升； * 2. d数组是有序的，d[1]&lt;d[2]&lt;..d[n]。 ** 利用这两个性质，可以很方便的求解：** 1.设当前已求出的最长上升子序列的长度为len（初始时为1），每次读入一个新元素x： 2.若x&gt;d[len]，则直接加入到d的末尾，且len++；（利用性质2） 3.否则，在d中二分查找，找到第一个比x小的数d[k]，并d[k+1]=x，在这里x&lt;=d[k+1]一定成立（性质1,2）。 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;const int N = 1e5 +10;int a[N], q[N];int main()&#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt;n; i++) cin &gt;&gt; a[i]; int len = 0; for(int i = 0; i &lt; n; i++)&#123; int l = 0, r = len; while(l &lt; r)&#123; int mid = l + r + 1 &gt;&gt; 1; if(q[mid] &lt; a[i])l = mid; //找到小于a[i]的第一个数 else r = mid - 1; &#125; //r + 1 表示大于等于a[i]的的第一个数,并将该数替换掉 len = max(len, r + 1); q[r + 1] = a[i]; &#125; cout &lt;&lt; len &lt;&lt; endl; &#125; 二.数字和最大的递增子序列 题目描述：给定你一个数字序列，找出数字和最大的递增子序列 思路：跟前一个思路一样采用dp的思想，现在dp【i】的含义表示为序列中第i个元素结尾的数字和的最大值 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;#define maxn 100000int max(int a,int b)&#123; if(a&gt;b)return a; else return b;&#125;int a[maxn+5];int dp[maxn+5];int main()&#123; int n,Max=0; scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;a[i]); dp[i]=a[i]; &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;i;j++)&#123; if(a[i]&gt;a[j])dp[i] = max(dp[j]+a[i], dp[i]);//dp【i】表示以第i个元素结尾的数字和的最大值 &#125; Max=max(Max,dp[i]); //记录最大的数字和 &#125; printf(\"%d\\n\",Max); return 0;&#125; 三.连续子数组最大和例题：杭电OJ 1003 问题描述：给你一个数字序列，里面有正数，也有负数，求出这个序列中连续某一段的和的最大值，并求出是从什么地方开始到什么地方结束 思路：dp的思想，dp【i】依然表示的是序列中以第i个元素结尾的连续数组的最大值，从第二项依次遍历，如果前一项&lt;0,则不加，若大于0就加上. 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#define maxn 100000int a[maxn+5];int main()&#123; int t,n,p=1; scanf(\"%d\",&amp;t); while(t--)&#123; a[0]=0; int start=1,end=0,fstart=1,fend=1,Max=-1e9; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++)scanf(\"%d\",&amp;a[i]); for(int i=1;i&lt;=n;i++)&#123; if(a[i-1]&lt;0)&#123; start=i; end=i; &#125; else &#123; a[i]+=a[i-1]; end=i; &#125; if(a[i]&gt;Max)&#123; //Max，fstart，fend分别表示和的最大值以及对应的起始位置 Max=a[i]; fstart=start; fend=end; &#125; &#125; printf(\"Case %d:\\n\",p); printf(\"%d %d %d\\n\",Max,fstart,fend); p++; if(t!=0)printf(\"\\n\"); &#125;&#125;","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/categories/动态规划/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"子序列","slug":"子序列","permalink":"http://zhumenger.top/tags/子序列/"}]},{"title":"Java基础之类的构造方法和this简介","slug":"Java/Java基础之类的构造方法和this简介","date":"2019-07-20T11:37:21.000Z","updated":"2019-07-20T11:39:01.496Z","comments":true,"path":"2019/07/20/Java/Java基础之类的构造方法和this简介/","link":"","permalink":"http://zhumenger.top/2019/07/20/Java/Java基础之类的构造方法和this简介/","excerpt":"","text":"一.构造方法构造方法的本质是将类中的变量通过参数的形式进行赋值 要点： 1.通过new关键字调用 2.构造器有返回值，但是不能定义返回值，不能再构造器中使用return返回某个值 3.如果没有定义构造器，则编译器会自动顶一个无参的构造函数 4.构造器的方法名必须和类名一致 123456789101112131415161718192021222324252627282930public class Main &#123; public static void main(String[] args) &#123; Point p1 = new Point(1, 2); Point p2 = new Point(3, 4); //如果自己添加了构造器，创建对象的时候， //形式一定要和构造器的形式一样，否则会报错 //Point p3 = new Point();报错 System.out.println(p1.sum(p2)); System.out.println(p2.sum(p1)); &#125; &#125;class Point&#123; int x, y; //构造方法的名称必须和类的名称一致 //构造方法的本质是将类中的变量通过参数的形式进行赋值 public Point(int a, int b) &#123; x = a; y = b; &#125; public int sum(Point p) &#123; return p.x + p.y; &#125;&#125; 二.this简介1.this表示“创建好的对象的地址”，在构造方法中也可以使用this代表当前的对象 2.this不能用于static方法中 12345678910111213141516171819202122public class Main &#123; int a, b, c; Main(int a, int b)&#123; //this表示此类 //this.a表示此类中a这个成员变量 this.a = a; this.b = b; &#125; Main(int a, int b, int c)&#123; //调用构造器 //构造器的调用必须放在第一句 this(a, b); this.c = c; &#125; public static void main(String[] args) &#123; &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/tags/Java/"}]},{"title":"Java基础之对象和内存分析","slug":"Java/Java基础之对象和内存分析","date":"2019-07-20T11:02:15.000Z","updated":"2019-07-20T11:03:07.925Z","comments":true,"path":"2019/07/20/Java/Java基础之对象和内存分析/","link":"","permalink":"http://zhumenger.top/2019/07/20/Java/Java基础之对象和内存分析/","excerpt":"","text":"一.Java基础之对象1.什么是对象：是某种类的声明，可以通过该对象调用与之对应的类的属性和属性值，被访问的属性属于成员变量，在类中，又在方法之外的变量 2.对象的创建 通过new运算符来创建一个类的对象，，语法为：类名 变量 = new 类名()； 123456789101112131415161718192021public class Main &#123; int a; int b; //表示一个方法 void play() &#123; System.out.println(\"~~~~~^_^~~~~~\"); &#125; //构造方法，用于创建这个类的对象。无参的构造方法可以 //由系统自动生成，方法名必须和类名一致 //这里可以不写 //Main()&#123; //&#125; public static void main(String[] args) &#123; Main d = new Main();//创建一个对象 d.play();//表示调用d对象中的play函数，输出//~~~~~^_^~~~~~ d.a = 1; d.b = 123; System.out.println(d.a);//输出1 System.out.println(d.b);//输出123 &#125;&#125; 也可以在一个类中，声明另个一个类的对象，并且可以对其进行访问 1234567891011121314public class Main &#123; Computer come = new Computer();//声明一个Computer类的对象 public static void main(String[] args) &#123; Main arr = new Main();//声明一个Main类的对象 arr.come.name = \"孙悟空\"; System.out.println(arr.come.name);//输出\"孙悟空\" &#125; &#125;//另一个类class Computer&#123; String name;&#125; 二.Java基础之内存分析栈1.方法被调用的时候，都会在栈中开辟一块内存，用来存储方法中的东西 2.对象在栈中储存的是该对象在堆中的地址，对象的值并不会直接储存在栈中，而是储存在了堆中 3.局部变量也是储存在了栈内存当中 堆1.是一个不连续的内存空间，用来储存创建好的对象 2.成员变量，即对象中的属性和属性值都是在堆中储存 方法区 用来存放程序中不变或唯一的内容，实际上也是一个特殊的堆， 1234567891011121314151617181920212223public class Main &#123; //以下变量都属于成员变量， //对象又被称为实例，实例变量即对象变量 //不创建对象，成员变量的内存空间是不存在的，只有创建了 //对象，成员变量的内存空间才会被创建 int name; int age; public static void main(String[] args) &#123; //arr表示一个引用,引用即一个变量，储存的是一个Java对象的内存地址 //Java中，不能直接操作堆内存，Java中没有指针 //Java中，只能用过\"引用\"去访问堆内存的成员变量 //读取数据: 引用.变量名 Main arr = new Main(); &#125; &#125;//成员变量没有手动赋值的话，系统赋默认值//byte、short int long:0;// float double: 0.0;// boolean:false","categories":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/tags/Java/"}]},{"title":"Java基础之方法","slug":"Java/Java基础之方法","date":"2019-07-19T10:15:31.000Z","updated":"2019-07-19T10:16:04.756Z","comments":true,"path":"2019/07/19/Java/Java基础之方法/","link":"","permalink":"http://zhumenger.top/2019/07/19/Java/Java基础之方法/","excerpt":"","text":"java中的方法类似于其他语言中的函数，是完成特定功能的代码片段 12345678910public class Main &#123; public static void main(String[] args) &#123; int a = 2, b = 3; int c = sum(a, b); System.out.println(c); &#125; public static int sum(int a, int b)&#123; return a +b; &#125;&#125; 方法的重载： Java语言中的方法的名称可以相同 构成重载的条件： 1.方法名相同，参数个数不同，构成重载 123456789101112131415public class Main &#123; public static void main(String[] args) &#123; int a = 2, b = 3, d = 4; int c = sum(a, b); int f = sum(a, b, d); System.out.println(c);//输出5 System.out.println(f);//输出9 &#125; public static int sum(int a, int b)&#123; return a +b; &#125; public static int sum(int a, int b, int c)&#123; return a + b + c; &#125;&#125; 2.方法名相同，参数类型不同，构成重载 12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; int a = 2, b = 3; double d = 2.0; int c = sum(a, b); double f = sum(d, b); System.out.println(c);//输出5 System.out.println(f);//5.0 &#125; public static int sum(double a, int b)&#123; return a +b; &#125; public static double sum(int a, double b)&#123; return a + b; &#125;&#125; 方法名相同，参数顺序不同，构成重载 12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; double a = 2.0; int b = 3; double c = sum(a, b); double d = sum(b, a); System.out.println(c);//5.0 System.out.println(d);//5.0 &#125; public static double sum(double a, int b)&#123; return a +b; &#125; public static double sum(int a, double b)&#123; return a + b; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/tags/Java/"}]},{"title":"整数划分","slug":"动态规划/整数划分","date":"2019-07-19T02:24:06.000Z","updated":"2019-07-19T02:25:23.218Z","comments":true,"path":"2019/07/19/动态规划/整数划分/","link":"","permalink":"http://zhumenger.top/2019/07/19/动态规划/整数划分/","excerpt":"","text":"题目描述 一个正整数n可以表示成若干个正整数之和，形如：n=n1+n2+…+nk，其中n1≥n2≥…≥nk,k≥1。 我们将这样的一种表示称为正整数n的一种划分。 现在给定一个正整数n，请你求出n共有多少种不同的划分方法。 输入格式 共一行，包含一个整数n。 输出格式 共一行，包含一个整数，表示总划分数量。 由于答案可能很大，输出结果请对109+7取模。 数据范围 1≤n≤1000 输入样例: 5 输出样例： 7 题解： 类似于完全背包问题，可以把n看成体积，有 n - 1种不能体积的物品，问将这些物品装入背包，容量恰好为n的方法有多少种 状态表示：f(i, j) 表示前 i 个物品恰好能装进容量为 j 的方法总数 如何求f(i, j)？对于每个物品我们可以选择装，也可以选择不装: 1.第 i 个物品不装进背包中，说明前i - 1个物品装进背包的容量恰好为j，所以f(i, j) = f(i - 1, j) 1.第 i 个物品装进背包中，将第 i 个物品装进背包后，背包容量恰好为 j ，则状态转移方程为： *f(i, j) = f(i, j - i) * 所以总的状态转移方程为：f(i, j) = f(i - 1, j ) + f(i, j - 1) 代码如下： 123456789101112131415#include&lt;iostream&gt;using namespace std;const int N = 1010, mod = 1e9 + 7;int f[N];int main()&#123; int n; cin &gt;&gt; n; f[0] = 1; for(int i = 1; i &lt;= n; i++) // 枚举物品 for(int j = i; j &lt;= n; j++)//从小到大枚举体积 f[j] = (f[j] + f[j - i]) % mod; cout &lt;&lt; f[n] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/categories/动态规划/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"计数DP","slug":"计数DP","permalink":"http://zhumenger.top/tags/计数DP/"}]},{"title":"石子合并","slug":"动态规划/石子合并","date":"2019-07-19T02:05:11.000Z","updated":"2019-07-19T02:07:33.948Z","comments":true,"path":"2019/07/19/动态规划/石子合并/","link":"","permalink":"http://zhumenger.top/2019/07/19/动态规划/石子合并/","excerpt":"","text":"题目描述 设有N堆石子排成一排，其编号为1，2，3，…，N。 每堆石子有一定的质量，可以用一个整数来描述，现在要将这N堆石子合并成为一堆。 每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。 例如有4堆石子分别为 1 3 5 2， 我们可以先合并1、2堆，代价为4，得到4 5 2， 又合并 1，2堆，代价为9，得到9 2 ，再合并得到11，总代价为4+9+11=24； 如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11=22。 问题是：找出一种合理的方法，使总的代价最小，输出最小代价。 输入格式 第一行一个数N表示石子的堆数N。 第二行N个数，表示每堆石子的质量(均不超过1000)。 输出格式 输出一个整数，表示最小代价。 数据范围 1≤N≤300 输入样例： 41 3 5 2 输出样例： 22 题解： 区间DP问题，用动态规划来做： 状态表示：f(i, j) 表示将第 i 堆石子到第 j 堆石子合并成一堆石子的代价的最小值 如何求f(i, j)呢？ 1.假设k为 i ~ j 堆石子的一个分界线，从 i 堆到 k 堆的最小代价已经求出，从 k + 1 堆到 j 堆的最小代价也已经求出，我们要求 i 堆到 j 堆的最小代价，只需要将左右俩堆的最小代价加起来，再加上这次合并的代价，就可以得到我们的f(i, j)了。 2.这次的合并代价为 i ~ j 堆所有石子的重量之和，我们可以用前缀和的方法来得到任意区间的总和 3.状态转移方程为：f(i, j) = min(f(i, j), f(i, k) + f(k + 1, j) + s[j] - s[i - 1]) 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;const int N = 310;int f[N][N], a[N], s[N];int main()&#123; int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= n; i++) s[i] = a[i] + s[i - 1]; for(int i = 2; i &lt;= n; i++)&#123;//枚举长度 for(int j = 1; j + i - 1 &lt;= n; j++)&#123;//枚举这个长度下的起点和终点 int l = j, r = j + i - 1; f[l][r] = 1e9; for(int k = l; k &lt; r; k++)//枚举分界线 f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]); &#125; &#125; cout &lt;&lt; f[1][n] &lt;&lt;endl; return 0;&#125;","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/categories/动态规划/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"区间DP","slug":"区间DP","permalink":"http://zhumenger.top/tags/区间DP/"}]},{"title":"最短编辑距离","slug":"动态规划/最短编辑距离","date":"2019-07-19T01:27:36.000Z","updated":"2019-07-19T01:29:08.648Z","comments":true,"path":"2019/07/19/动态规划/最短编辑距离/","link":"","permalink":"http://zhumenger.top/2019/07/19/动态规划/最短编辑距离/","excerpt":"","text":"题目描述 给定两个字符串A和B，现在要将A经过若干操作变为B，可进行的操作有： 删除–将字符串A中的某个字符删除。 插入–在字符串A的某个位置插入某个字符。 替换–将字符串A中的某个字符替换为另一个字符。 现在请你求出，将A变为B至少需要进行多少次操作。 输入格式 第一行包含整数n，表示字符串A的长度。 第二行包含一个长度为n的字符串A。 第三行包含整数m，表示字符串B的长度。 第四行包含一个长度为m的字符串B。 字符串中均只包含小写字母。 输出格式 输出一个整数，表示最少操作次数。 数据范围 1≤n,m≤1000 输入样例： 10AGTCTGACGC11AGTAAGTAGGC 输出样例： 4 题解： 将一个字符串通过删除、插入、替换变为另一个字符串的最短距离,可以用动态规划来做，用f(i, j)来表示长度为i的字符串变为长度为j的字符串最小的操作次数，那么如何来求f(i, j)呢？对每个字符我们有3种操作: 1.删除：假设删除a[i]后，a[1 ~ i] 与 b[1 ~ j] 匹配，那么说明a[1 ~ i - 1]已经与b[1 ~ j]相等了，那么多出来的a[i]直接删掉即可，状态转移方程为：f(i, j) = f(i - 1, j) + 1 2.插入： 假设插入一个a[i],使a[i] == b[j]后，a[1 ~ i] 与 b[1 ~ j] 匹配,那么说明a[1 ~ i]已经与b[i ~ j - 1]相等了，要使a[1 ~ i]与b[i ~ j]相等,只需再a[1 ~ i]的后面添加一个b[j]即可 状态转移方程为：f(i, j) = f(i, j - 1) + 1 3.替换：假设将a[i]替换成b[j],使得a[1 ~ i] 与 b[1 ~ j] 匹配,那么说明a[1 ~ i - 1]已经与b[i ~ j - 1]相等了，要使a[1 ~ i]与b[i ~ j]相等,只需将a[i]替换为b[j]即可。 如果a[i] = b[j]，则无需替换，状态转移方程为：f(i, j) = f(i - 1, j - 1) 如果a[i] != b[j]，则需要替换，状态转移方程为：f(i, j) = f(i - 1, j - 1) + 1 所以我们得出来总的状态转移方程式为就是上述方程式的最小值 代码如下： 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;const int N = 1010;char s1[N], s2[N];int f[N][N];int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; s1 + 1; cin &gt;&gt; m &gt;&gt; s2 + 1; for(int i = 0; i &lt;= n; i++) //a[i ~ i]变为0，只能删除， 操作数为i f[i][0] = i; for(int i = 0; i &lt;= m; i++)//a[0]变为b[1 ~ i]，只能添加，操作数为i f[0][i] = i; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; //f[i - 1][j] + 1 表示进行删除操作 //f[i][j - 1] + 1 表示进行添加操作 f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1); //下面的表示进行替换操作 if(s1[i] == s2[j])f[i][j] = min(f[i][j], f[i - 1][j - 1]); else f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1); &#125; &#125; cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/categories/动态规划/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"}]},{"title":"Java基础之运算符","slug":"Java/Java基础之运算符","date":"2019-07-18T11:19:58.000Z","updated":"2019-07-18T11:20:42.828Z","comments":true,"path":"2019/07/18/Java/Java基础之运算符/","link":"","permalink":"http://zhumenger.top/2019/07/18/Java/Java基础之运算符/","excerpt":"","text":"1.二元运算符整数运算 1.如果俩个操作数有一个为long，则结果为long 2.如果没有long时，结果为int，即使操作符全为float或byte，也必须用int类型的变量来保存 浮点运算 3.如果俩个操作符中有一个为double，则结果为double 4.只有当俩个操作符全为float时，结果才为float 取模运算 余数的符号与左边操作符相同，如 7%3 = 1， -7 % 3 = -1， 7 % -3 = 1； 2.自增与自减12345678910public class Main &#123; public static void main(String[] args) &#123; int a = 3; int b = a++;//先赋值在运算,b为3,a为4 int c = ++a;//先运算再赋值,a = 5, c = 5 b = a--;//先赋值在运算,b为5,a为4 b = --a;//先赋值在运算,a = 3,b = 3 System.out.println(); &#125;&#125; 3.字符串运算符1.string型与int型相加,先将int类型转化为字符串类型，在进行拼接 2.运算顺序从左到右，俩个整形相加还是整形，直到与字符串相加才变成字符串类型 12345678910public class Main &#123; public static void main(String[] args) &#123; String a = \"3\"; int b = 4; int c = 5; System.out.println(a + b);//输出34 System.out.println(a + b + c);//345 System.out.println(b + c + a);//93 &#125;&#125; 4.强制类型转换语法：type var = (type)value 12345678910public class Main &#123; public static void main(String[] args) &#123; double x = 3.14; int a = (int)x; char a = 'a'; int d = c + 1; System.out.println(a);//输出3 Syetem.out.println((char)d);//输出'b' &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/tags/Java/"}]},{"title":"Java基础之基本类型","slug":"Java/Java基础之基本类型","date":"2019-07-18T10:43:17.000Z","updated":"2019-07-18T10:43:52.595Z","comments":true,"path":"2019/07/18/Java/Java基础之基本类型/","link":"","permalink":"http://zhumenger.top/2019/07/18/Java/Java基础之基本类型/","excerpt":"","text":"1.常量定义：指固定的值，不能随意改变，如：1， 2， “hello world”等 在java语言中，利用final关键字来定义一个常量，常量一旦被初始化后便不能再更改其值 声明格式: 1final type varname = value; 例： 123456public class Main&#123; public static void main(String[] args)&#123; final double PI = 3.14; System.out.println(PI); &#125;&#125; 2.基本数据类型数值型： byte(1个字节)、short(2个字节)、int(4个字节)、long(8个字节)、float(4个字节)、double(8个字节) 字符型： char(2个字节) 布尔型： boolean(1个字节) 整形的4种表示方式 1.十进制：如，99 2.八进制：以0开头 如：015 3.十六进制：以0x 或0X开头，如： 0xab 0x15 4.二进制： 以0b 或 0B开头 如：0b011010 1234567891011public class Main&#123; public static void main(String[] args)&#123; byte a = 5;//a的范围不能超过一个字节，否则会报错 int b = 015//8进制 int c = 0x15//16进制 int d = 0b1001//2进制 long e = 12345; long f = 10000000L;(后面+L表示这是一个long类型的变量) System.out.println(PI); &#125;&#125; 浮点型 1.表示形式 十进制数形式：3.14、0.1 科学计数法表示：3e5 表示300000.0 300000e-5 表示3.0 float类型数值有一个后缀 F 或 f ,没有后缀F/f的浮点数默认为double类型，也可以在数值后面添加D/d来声明它是一个double类型 浮点型的值不精确： 1234567public class Main&#123; public static void main(String[] args)&#123; float a = 0.1f; double b = 1.0 / 10; System.out.println(a == b);//false &#125;&#125; 字符型字符型占2个字节，用单引号’ ‘ 来表示一个字符，用双引号” “ 来表示一个字符串，Java采用的是Unicode编码，可以处理各种语言的文字 12345678910public class Main&#123; public static void main(String[] args)&#123; char str1 = '1'; char str2 = 'a'; char str3 = '哈'; //也可以用转义字符\\u + 4位16进制的数拉表示一个字符 char a = '\\u0061';// 表示'a' System.out.println(a == b);//false &#125;&#125; boolean类型有俩个常量：true和false","categories":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/tags/Java/"}]},{"title":"Java基础之-注释、标识符、变量","slug":"Java/Java基础之-注释、标识符、变量","date":"2019-07-17T09:28:07.000Z","updated":"2019-07-17T09:33:39.752Z","comments":true,"path":"2019/07/17/Java/Java基础之-注释、标识符、变量/","link":"","permalink":"http://zhumenger.top/2019/07/17/Java/Java基础之-注释、标识符、变量/","excerpt":"","text":"一.注释单行注释： //内容…. 多行注释： /* 内容…*/ 文档注释： /** 内容 */ 1234567891011121314151617/** * 这里是文档注释 * @author Administrator * */public class Main &#123; //这里是单行注释 public static void main(String[] args) &#123; // TODO Auto-generated method stub System.out.println(\"安装eclipse完成!\"); &#125; /* * 这 * 里 * 是 * 多行注释 */&#125; 二.标识符1.命名规则: 标识符必须以字母、下划线、或者$开头，不能以数字开头 标识符其他部分可以是字母、下划线、$ 和数字的任意组合 Java标识符区分大小写 标识符不可以是Java的关键字 标识符的第一个单词的字母要小写，从第二个单词开始，首字母大写，我们称之为“驼峰原则”如get， getMin Java语言采用的不是ASCII字符集，而是Unicode国际编码，所以字符串中的内容可以是中文 三.变量当你把一个值赋值给一个名字时，它会储存在内存中，把这块内存称为变量, 本质上就是一个可以操作的储存空间 声明变量： 1234double a; //8个字节long b; //8个字节int c; //4个字节int a, b, c;//一行中声明对个变量 局部变量 在代码块内部定义的变量，生命周期从声明位置开始，带方法或代码块执行完毕为止 12345public class Main &#123; public void text&#123; int j = i + 5; &#125;&#125; 成员变量方法外部、类的内部定义的变量, 书与对象，生命周期伴随对象始终，如果不自动初始化，它会自动初始化为默认值(整型为0，浮点型为0.0) 静态变量 使用static定义，从属于类，生命周期始终伴随类，类在，该变量就在","categories":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/tags/Java/"}]},{"title":"Java基础之-程序详细解析","slug":"Java/Java基础之-程序详细解析","date":"2019-07-17T08:20:40.000Z","updated":"2019-07-17T09:33:18.926Z","comments":true,"path":"2019/07/17/Java/Java基础之-程序详细解析/","link":"","permalink":"http://zhumenger.top/2019/07/17/Java/Java基础之-程序详细解析/","excerpt":"","text":"1.Java区分大小写，大小写拼写错误，程序无法运行 2.关键词class是类的意思。Java所有的代码都要写在类中 3.一个源文件中只能声明一个public的类，其他类的个数不限 4.编写类的时候有俩种方式： (A). public class定义类 ： 1.如果一个类声明的时候使用了public class进行了声明，则类名称必须与文件名称完全一致。 2.被public修饰的类可以被其他包访问 (B). class定义类 1.如果一个类声明的时候使用了class进行了声明，则作为启动类的名称可以与文件名称不一致，但是执行的时候肯定执行的是生成后的名称。 2.没有public修饰的类，该类就拥有了包访问权限，即该类只可以用于该包之中。该类不能被其他包访问 5.Java中每个语句以分号结束 6.main方法是java应用程序的入口方法，它有固定的书写格式：public static void main(String[] args) 1234567891011121314151617//public 表示公开的， 表示其他的类都可以访问这个方法//class表示定义一个类//Main 表示一个类名//下面一句表示定义了一个公开的类，起名为Main,必须和文件名一致public class Main&#123; /* public表示公开的 static表示静态的 void表示空 main是Java程序进入的方法 String[] args： String 类型的数组，名为args，这个名字是可以变化的，但是一般使用args。 */ //下面一句表示定义了 public static void main(String[] args)&#123; System.out.println(\"安装eclipse完成!\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/tags/Java/"}]},{"title":"素数","slug":"数论/素数","date":"2019-07-17T00:50:38.000Z","updated":"2019-07-17T01:22:59.287Z","comments":true,"path":"2019/07/17/数论/素数/","link":"","permalink":"http://zhumenger.top/2019/07/17/数论/素数/","excerpt":"","text":"一.试除法判定质数即暴力枚举它之前的数，如果能整除，说明该数不是素数 1234567891011121314151617181920212223//时间复杂度O(sqrt(n))#include&lt;iostream&gt;using namespace std;int n;bool prime(int n)&#123; if(n &lt; 2)return false; for(int i = 2; i &lt; n / i; i++)//i * i 有溢出风险，所以要把i除过去 if(n % i == 0) return false; return true;&#125;int main()&#123; long long int a; cin &gt;&gt; n; while(n--)&#123; cin &gt;&gt; a; if(prime(a))cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; return 0;&#125; 二.分解质因数 给定n个正整数ai，将每个数分解质因数，并按照质因数从小到大的顺序输出每个质因数的底数和指数。 输入格式 第一行包含整数n。 接下来n行，每行包含一个正整数ai。 输出格式 对于每个正整数ai,按照从小到大的顺序输出其分解质因数后，每个质因数的底数和指数，每个底数和指数占一行。 每个正整数的质因数全部输出完毕后，输出一个空行。 数据范围 1≤n≤1001≤ai≤2∗109 输入样例： 268 输出样例： 2 13 1 2 3 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;typedef long long ll;void divide(ll n)&#123; for(ll i = 2; i &lt;= n / i; i++)&#123; //枚举到sqrt(n)，时间复杂度最大为O(sqrt(n)) if(n % i== 0)&#123; int ans = 0; while(n % i == 0)&#123; n /=i; ans++; &#125; printf(\"%d %d\\n\", i, ans); &#125; &#125; if(n &gt; 1)printf(\"%d %d\\n\", n, 1);//大于sqrt(n)的质因子&#125;int main()&#123; int n; ll x; cin &gt;&gt; n; while(n--)&#123; scanf(\"%lld\", &amp;x); divide(x); printf(\"\\n\"); &#125; return 0;&#125; 三.筛质数题目描述 给定一个正整数n，请你求出1~n中质数的个数。 输入格式 共一行，包含整数n。 输出格式 共一行，包含一个整数，表示1~n中质数的个数。 数据范围 1≤n≤106 输入样例： 8 输出样例： 4 埃氏筛法原理 素数的定义：素数就是除了1和本身之外没有其他的约数，所以有约数的都不是素数。 埃氏筛法的思想就是：先去掉2的倍数，再去掉3的倍数，再去掉4的倍数，……依此类推，直到最大数小于最后一个标出的素数的平方，那么剩下的序列中所有的数都是素数。 时间复杂度：O(nloglogn)代码如下： 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;#define maxn 10000000#define INF 0x3f3f3f3fusing namespace std;bool a[maxn+5];int main()&#123; int n,m; scanf(\"%d%d\",&amp;n,&amp;m); memset(a,true,sizeof(a)); for(int i=2;i&lt;=n;i++)&#123; if(a[i])&#123; for(int j=2;i*j&lt;=n;j++) a[i*j]=false; &#125; &#125; a[1]=false; int t; while(m--) &#123; scanf(\"%d\",&amp;t); if(a[t])printf(\"Yes\\n\"); else printf(\"No\\n\"); &#125; return 0;&#125; 欧拉筛法 在埃式筛法中，存在有些数存在重复筛的情况，如：385这个数，385= 5 * 7* 11，会被5的倍数时标记一次，7的倍数时标记一次，11的倍数时标记一次，造成效率达不到最优。而线性筛法基于改进这个不足的基础上，在线性时间内，也就是O(n)，用筛选的方法把素数找出来。 核心原理：对于每个合数，都只由它最小的质因子筛掉。 比如：（假定：ans[]数组中存放着已经确定的素数）合数 i = p（最小素因子）* a; 若 i%ans[j] ==0; 则 i * ans[j+1] = p * a * ans[j+1] 可以被后面的 a * ans[j+1] 再乘以素数 p 筛选出来，(显而p&lt;ans[j+1]） 所以i%ans[j] == 0 时要停止。 代码如下： 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define maxn 10000000#define INF 0x3f3f3f3fusing namespace std;bool a[maxn+5];int b[maxn+5];//存储质数int main()&#123; int n,m; scanf(\"%d%d\",&amp;n,&amp;m); memset(a,true,sizeof(a)); a[1]=false; int k=1; for(int i=2;i&lt;=n;i++)&#123; if(a[i]) //如果i为质数 b[k++]=i;//存上 for(int j=1;j&lt;=k&amp;&amp;i*b[j]&lt;=n;j++)&#123; a[i*b[j]]=false; if(i%b[j]==0)break; &#125; &#125; int t; while(m--)&#123; scanf(\"%d\",&amp;t); if(a[t])printf(\"Yes\\n\"); else printf(\"No\\n\"); &#125; return 0;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"素数","slug":"素数","permalink":"http://zhumenger.top/tags/素数/"}]},{"title":"雪花雪花雪花","slug":"数据结构基础/雪花雪花雪花(最小表示法)","date":"2019-07-16T01:39:15.000Z","updated":"2019-07-16T01:40:25.302Z","comments":true,"path":"2019/07/16/数据结构基础/雪花雪花雪花(最小表示法)/","link":"","permalink":"http://zhumenger.top/2019/07/16/数据结构基础/雪花雪花雪花(最小表示法)/","excerpt":"","text":"雪花雪花雪花 有N片雪花，每片雪花由六个角组成，每个角都有长度。 第i片雪花六个角的长度从某个角开始顺时针依次记为ai1,ai2,…,ai6。 因为雪花的形状是封闭的环形，所以从任何一个角开始顺时针或逆时针往后记录长度，得到的六元组都代表形状相同的雪花。 例如ai1,ai2,…,ai6和ai2,ai3,…,ai6，ai1就是形状相同的雪花。 ai1,ai2,…,ai6和ai6,ai5,…,ai1也是形状相同的雪花。 我们称两片雪花形状相同，当且仅当它们各自从某一角开始顺时针或逆时针记录长度，能得到两个相同的六元组。 求这N片雪花中是否存在两片形状相同的雪花。 输入格式 第一行输入一个整数N，代表雪花的数量。 接下来N行，每行描述一片雪花. 每行包含6个整数，分别代表雪花的六个角的长度（这六个数即为从雪花的随机一个角顺时针或逆时针记录长度得到）。 同行数值之间，用空格隔开。 输出格式 如果不存在两片形状相同的雪花，则输出： No two snowflakes are alike. 如果存在两片形状相同的雪花，则输出： Twin snowflakes found. 数据范围 1≤n≤1000000≤ai,j&lt;10000000 输入样例： 21 2 3 4 5 64 3 2 1 6 5 输出样例： Twin snowflakes found. 题解： 字符串的最小表示法：每一个字符串都有一个字典序最小的表示，比较这俩个字符串的最小表示是否相等即可 1.用俩个数组分别存取该字符串的正序和逆序表示 2.用最小表示法获得俩种表示方法中字典序最小的那个，并将该结果用数组储存起来 3.我们需要对储存的结果进行排序，这样只需要比较相邻的俩个数是否相等即可，但并不能直接对二维数组进行排序，这里我们需要一个一维数组，来储存每个字符串的下标，该数组通过二维数组字符串的关系对下标进行排序,通过遍历该下标访问二维数组即可 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e5 + 10;int n;int snows[N][6], idx[N];void get_min(int a[])//获得字符串的最小表示法&#123; int b[12]; for(int i = 0; i &lt; 12; i++)b[i] = a[i % 6]; int i = 0, j = 1, k; while(i &lt;= 6 &amp;&amp; j &lt;= 6)&#123; k = 0; while(k &lt; 6 &amp;&amp; b[i + k] == b[j + k])k++; if(k == 6)break; if(b[i + k] &lt; b[j + k])&#123; j += k + 1; if(j == i)j++; &#125; else&#123; i += k + 1; if(i == j)i++; &#125; &#125; k = min(i, j); for(int i = 0; i &lt; 6; i++)&#123; a[i] = b[i + k]; &#125;&#125;bool cmp_array(int a[], int b[])//比较a是否小于b&#123; for(int i = 0; i &lt; 6; i++)&#123; if(a[i] &gt; b[i]) return false; else if(a[i] &lt; b[i]) return true; &#125; return false;&#125;bool cmp(int a, int b)//对二维数组排序&#123; return cmp_array(snows[a], snows[b]);//返回俩个字符串的关系&#125;int main()&#123; cin &gt;&gt; n; int snow[6], isnow[6]; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; 6; j++)&#123; cin &gt;&gt;snow[j]; isnow[5 - j] = snow[j]; &#125; get_min(snow);//获得最小表示 get_min(isnow); if(cmp_array(snow, isnow))memcpy(snows[i], snow, sizeof snow); else memcpy(snows[i], isnow, sizeof isnow); idx[i] = i; &#125; sort(idx, idx + n, cmp);//对下标进行排序 bool flag = false; for(int i = 1; i &lt; n; i++)&#123;//比较相邻的俩个数是否相同 if(!cmp(idx[i - 1], idx[i]) &amp;&amp; !cmp(idx[i], idx[i - 1]))&#123; flag = true; break; &#125; &#125; if(flag)puts(\"Twin snowflakes found.\"); else puts(\"No two snowflakes are alike.\"); return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"字符串","slug":"字符串","permalink":"http://zhumenger.top/tags/字符串/"}]},{"title":"邻值查找","slug":"数据结构基础/邻值查找","date":"2019-07-16T01:18:34.000Z","updated":"2019-07-27T04:46:04.367Z","comments":true,"path":"2019/07/16/数据结构基础/邻值查找/","link":"","permalink":"http://zhumenger.top/2019/07/16/数据结构基础/邻值查找/","excerpt":"","text":"题目描述 给定一个长度为 n 的序列 A，A 中的数各不相同。对于 A 中的每一个数 Ai，求： min1≤j&lt;i|Ai−Aj| 以及令上式取到最小值的 j（记为 Pi）。若最小值点不唯一，则选择使 Aj 较小的那个。 输入格式 第一行输入整数n，代表序列长度。 第二行输入n个整数A1…An,代表序列的具体数值，数值之间用空格隔开。 输出格式 输出共n-1行，每行输出两个整数，数值之间用空格隔开。 分别表示当i取2~n时，对应的min1≤j&lt;i|Ai−Aj|和Pi的值。 数据范围 0&lt;n≤10^5,|Ai|≤10^9 输入样例： 31 5 3 输出样例： 4 12 1 题解： 1.由题意可知，这道题让我们求的是a[i]之前与a[i]最接近的数,如果我们进行排序，拍完序后与a[i]相邻的俩个肯定有一个是与a[i]最接近的, 2.首先用结构体将a[i]及其对应的下标存起来，从小到大排序 3.将排完序之后的结果用链表存起来,存起来后，我们从a[n]开始倒着遍历查找答案，在链表中它的前驱和后继的下标一定都是小于n的，取俩者与a[n]最接近的数，便是我们的答案 4.找到i的答案后，去掉该节点即可，保证从后往前遍历的时候，与a(i - 1)相邻的节点的下标都是小于i - 1的 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e5 + 10;int e[N], l[N], r[N];typedef pair&lt;int, int&gt; p;p a[N], ans[N];int main()&#123; int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i].first, a[i].second = i; sort(a + 1, a + 1 + n); a[0].first = 1e9, a[n + 1].first = -1e9; for(int i = 1; i &lt;= n; i++)&#123; l[i] = i - 1, r[i] = i + 1; e[a[i].second] = i; &#125; for(int i = n; i &gt; 1; i--)&#123;//从后往前遍历，则a[i]排完序后的前驱和后继的下标都是小于i的, int j = e[i], left = l[j], right = r[j]; int lv = abs(a[j].first - a[left].first); int rv = abs(a[j].first - a[right].first); if(lv &lt;= rv) ans[i] = &#123;lv, a[left].second&#125;; else if(lv &gt; rv) ans[i] = &#123;rv, a[right].second&#125;; r[left] = right, l[right] = left; //找到i的答案后，去掉该节点即可，这样从后往前遍历的 //时，保证了与a(i - 1)相邻的节点的下标都是小于i - 1的 &#125; for(int i = 2; i &lt;= n; i++) cout &lt;&lt; ans[i].first &lt;&lt; ' ' &lt;&lt; ans[i].second &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"链表","slug":"链表","permalink":"http://zhumenger.top/tags/链表/"}]},{"title":"背包九讲","slug":"动态规划/背包九讲","date":"2019-07-15T00:56:00.000Z","updated":"2019-07-15T00:58:18.878Z","comments":true,"path":"2019/07/15/动态规划/背包九讲/","link":"","permalink":"http://zhumenger.top/2019/07/15/动态规划/背包九讲/","excerpt":"","text":"Acwing背包题库一.01背包问题问题描述 有 N 件物品和一个容量是 VV 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。 输入格式 第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。 接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。 输出格式 输出一个整数，表示最大价值。 数据范围 0&lt;N,V≤10000&lt;vi,wi≤1000 输入样例 4 51 22 43 44 5 输出样例： 8 题解： 首先DP问题分为俩个步骤： 1.状态表示：首先考虑用几维的状态表示，然后考虑集合的含义，以及其属性(求Max, Min,数量等) 2.状态计算：DP问题一般都可以将大问题划分为小问题，从小问题下手，从而得到一般的状态转移方程 对于这道题，我们考虑： 1.首先声明一个数组F(i, j)表示选前 i 件物品，且背包容量为 j 时所能获得的最大价值 。 2.对于每个物品我们有拿或者不拿俩种选择： (1).j &lt; w[i] 的情况，这时候背包容量不足以放下第 i 件物品，只能选择不拿 (2).j &gt;= w[i] 的情况，这时背包容量可以放下第 i 件物品，我们就要考虑拿这件物品是否能获取更大的价值。 如果拿取，则F(i, j) = f(i - 1, j - v[i]) + w[i],即 F(i, j) 表示在上一状态中选了第i件物品， 如果不拿，则F(i, j) = f(i - 1, j) 拿或者不拿，就要看哪种方法得到的价值最大，即 F(i, j) = max(f(i - 1, j), f(i - 1, j - v[i]) + w[i]) 如下图所示： 代码如下： 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;#define maxn 1000using namespace std;int v[maxn + 5], w[maxn + 5];int dp[maxn + 5][maxn + 5];int main()&#123; int n,W; scanf(\"%d%d\",&amp;n,&amp;W); for(int i = 0; i &lt; n; i++) scanf(\"%d%d\",&amp;v[i],&amp;w[i]); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt;= W; j++)&#123; if(v[i] &gt; j)dp[i + 1][j] = dp[i][j]; else dp[i + 1][j] = max(dp[i][j], dp[i][j - v[i]] +w[i]); &#125; &#125; printf(\"%d\\n\",dp[n][W]); return 0;&#125; 01背包问题一维数组实现状态转移方程如果是由上一层的状态得来的话，枚举体积的时候从大到小枚举，这样我们计算体积的时候，可以保证本层所用到的体积还没有被计算过 如果用的是本层的状态，枚举体积的时候就要从小到大枚举，这样我们计算体积的时候，可以保证所用到的体积是本层之前计算好的体积 1234567891011121314151617#include&lt;iostream&gt;using namespace std;const int N = 1010;int d[N];int main()&#123; int n, V; cin &gt;&gt; n &gt;&gt; V; for(int i = 0; i &lt; n; i++)&#123; int v, w; cin &gt;&gt; v &gt;&gt; w; for(int j = V; j &gt;= v; j--) d[j] = max(d[j], d[j - v] + w); &#125; cout &lt;&lt; d[V] &lt;&lt; endl; return 0;&#125; 二.01背包问题2问题描述 有n个重量和价值分别为wi，vi的物品。从这些物品中挑选总重量不超过W的物品，求所有挑选方案中价值总和最大的方案 输入样例 4 52 1 3 23 2 4 2 输出样例 7 取值范围 1&lt;=n&lt;=1001&lt;=wi&lt;=10^71&lt;=vi&lt;=1001&lt;=W&lt;=10 ^9 分析： 这里与背包问题1不同的地方是修改了限制的条件，求解这一问题的复杂度是O（NW），对于这一问题的规模来讲就不够用了，相比较重量来说，价值的范围较小一些，所以可以改变DP的对象，背包问题1用DP来表示不同体积下的最大价值，这次我们不妨用DP来表示不同价值下的最小体积。定义：F(i, j)表示前i个物品挑选出价值总和为j时的最小重量,(不存在是就是一个充分大的数INF)由于前0个物品都挑选不了 所以F(0, 0)=0, F(0, j)=INF 状态转移式为：F(i, j) = min(f(i - 1, j), F(i - 1,j - w[i]) + v[i]) 代码如下： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#define INF 1000000000#define max_n 100#define max_v 100using namespace std;int n,W;int dp[max_n+5][max_n*max_v+5];int w[max_n+5],v[max_n+5];void solve()&#123; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;=max_n*max_v+5;j++)&#123; if(j&lt;v[i])dp[i+1][j]=dp[i][j]; else dp[i+1][j]=min(dp[i][j],dp[i][j-v[i]]+w[i]); &#125; &#125;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;W); for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;w[i]); for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;v[i]); fill(dp[0],dp[0]+max_n*max_v+5,INF); //初始化 dp[0][0]=0; solve(); int res=0; for(int i=0;i&lt;=max_n*max_v;i++)&#123; if(dp[n][i]&lt;=W)res=i; &#125; printf(\"%d\\n\",res); return 0;&#125; 三.完全背包问题 有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。 第 i 种物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。 输入格式 第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。 接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 种物品的体积和价值。 输出格式 输出一个整数，表示最大价值。 数据范围 0&lt;N,V≤10000&lt;vi,wi≤1000 输入样例 4 51 22 43 44 5 输出样例： 10 题解： 完全背包问题，物品有无限个，这里我们来考虑第i个物品选多少个 1.对于每种物品，我们有选和不选俩种选择， 如果不选，F(i + 1 ,j) = F(i , j) 如果选了，我们还要考虑选多少个，即F(i + 1, j) = max(F(i + 1, j - v[i]) + w[i], F(i + 1, j)) 取俩种情况的最大值，变得到了状态转移方程： F(i + 1, j) = max(F(i , j), F(i + 1, j - v[i]) + w[i]) 代码如下： 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;#define maxn 1000using namespace std;int v[maxn + 5], w[maxn + 5];int dp[maxn + 5][maxn + 5];int main()&#123; int n,V; scanf(\"%d%d\",&amp;n,&amp;V); for(int i = 0; i &lt; n; i++) scanf(\"%d%d\",&amp;v[i],&amp;w[i]); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt;= V; j++)&#123; if(v[i] &gt; j)dp[i + 1][j] = dp[i][j]; else dp[i + 1][j] = max(dp[i][j], dp[i + 1][j - v[i]] + w[i]); &#125; &#125; printf(\"%d\\n\",dp[n][V]); return 0;&#125; 一维数组实现 上面我们说到：如果用的是本层的状态，枚举体积的时候就要从小到大枚举即可，这样我们计算体积的时候，可以保证所用到的体积是本层之前计算好的体积 代码如下： 1234567891011121314151617#include&lt;iostream&gt;using namespace std;const int N = 1010;int d[N];int main()&#123; int n,V; cin &gt;&gt; n &gt;&gt; V; for(int i = 0; i &lt; n; i++)&#123; int v, w; cin &gt;&gt; v &gt;&gt; w; for(int j = v; j &lt;= V; j++) d[j] = max(d[j], d[j - v] + w); &#125; cout &lt;&lt; d[V] &lt;&lt; endl; return 0;&#125; 四.多重背包问题 I题目描述 有 N 种物品和一个容量是 V 的背包。 第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。 输入格式 第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。 接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。 输出格式 输出一个整数，表示最大价值。 数据范围 0&lt;N,V≤1000&lt;vi,wi,si≤100 输入样例 4 51 2 32 4 13 4 34 5 2 输出样例： 10 题解： 当成01背包问题来做即可，在枚举体积的时候在枚举一下该物品个数 状态转移方程：F(i, j) = max(F(i - 1, j), F(i - 1, j - k * v[i]) + k * w[i]) 一维数组实现，由于该状态转移用的是上一层的状态，所以枚举体积的时候，我们从大到小枚举，代码如下： 123456789101112131415161718#include&lt;iostream&gt;using namespace std;const int N = 110;int d[N];int main()&#123; int n, V; cin &gt;&gt; n &gt;&gt; V; for(int i = 0; i &lt; n; i++)&#123; int v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; for(int j = V; j &gt;= v; j--) for(int k = 1; k &lt;= s &amp;&amp; k * v &lt;= j; k++) d[j] = max(d[j], d[j - k * v] + k * w); &#125; cout &lt;&lt; d[V] &lt;&lt; endl; return 0;&#125; 五.多重背包问题II题目描述 有 N 种物品和一个容量是 V 的背包 第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。 输入格式 第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。 接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。 输出格式 输出一个整数，表示最大价值。 数据范围 0&lt;N≤10000&lt;V≤20000&lt;vi,wi,si≤2000 提示：本题考查多重背包的二进制优化方法。 输入样例 4 51 2 32 4 13 4 34 5 2 输出样例： 10 题解： 由于这题的数据范围有点大，直接暴力枚举会超时，那么我们就要想一个可以优化的方法，这里主要是对物品的个数进行拆分，将其变为01背包问题 二进制拆分法： 我们知道，从2^0, 2^1, 2^2…2^(k - 1)这k个数中选出任意个相加可以表示出0~2^k之间任何整数，所以我们可以对每一种物品就行二进制拆分，将其转化为01背包问题 代码如下： 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 9;int a[N], b[N], d[N];int main()&#123; int k = 0; int n, V; cin &gt;&gt; n &gt;&gt; V; for(int i = 0; i &lt; n; i++)&#123; int v, w, s; scanf(\"%d%d%d\", &amp;v, &amp;w, &amp;s); for(int j = 1; j &lt;= s; j &lt;&lt;= 1)&#123;//二进制拆分 a[k] = j * v; //用a数组来存体积 b[k++] = j * w; //b数组来存价值 s -= j; &#125; if(s &gt; 0)&#123; a[k] = s * v; b[k++] = s * w; &#125; &#125; for(int i = 0; i &lt; k; i++)//01背包 for(int j = V; j &gt;= a[i]; j--) d[j] = max(d[j], d[j - a[i]] + b[i]); cout &lt;&lt; d[V] &lt;&lt; endl; return 0;&#125; 六.分组背包问题题目描述 有 N 组物品和一个容量是 V 的背包。 每组物品有若干个，同一组内的物品最多只能选一个。每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。 求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。 输出最大价值。 输入格式 第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。 接下来有 N 组数据： 每组数据第一行有一个整数 Si，表示第 i 个物品组的物品数量； 每组数据接下来有 Si 行，每行有两个整数 vij,wij，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值； 输出格式 输出一个整数，表示最大价值。 数据范围 0&lt;N,V≤1000&lt;Si≤1000&lt;vij,wij≤100 输入样例 3 521 22 413 414 5 输出样例 8 题解： 跟完全背包问题类似 用F(i, j)来表示选前i组物品且体积为j时的价值最大值，我们先枚举每一组，由于F(i, j)的状态用的是上一层的状态，所以我们枚举体积的时候从大到小来枚举，再依次枚举每一组里的物品，找到体积为j时，选取i组中哪个物品的价值最大 代码如下： 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;const int N = 110;int v[N][N], w[N][N];int d[N], s[N];int main()&#123; int n, V; cin &gt;&gt; n &gt;&gt; V; for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; s[i]; for(int j = 0; j &lt; s[i]; j++)&#123; cin &gt;&gt; v[i][j] &gt;&gt; w[i][j]; &#125; &#125; for(int i = 0; i &lt; n; i++) //枚举每一组 for(int j = V; j &gt;= 0; j--) //枚举体积 for(int k = 0; k &lt; s[i]; k++)//枚举第i组体积为j时，选取哪个物品价值最大 if(v[i][k] &lt;= j) d[j] = max(d[j], d[j - v[i][k]] + w[i][k]); cout &lt;&lt; d[V] &lt;&lt; endl; return 0;&#125; 七.背包问题求方案数有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出 最优选法的方案数。注意答案可能很大，请输出答案模 109+7 的结果。 输入格式第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。 接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。 输出格式输出一个整数，表示 方案数 模 109+7 的结果。 数据范围0&lt;N,V≤10000&lt;vi,wi≤1000 输入样例 4 51 22 43 44 6 输出样例： 2 题解：在01背包问题的基础上，添加一个num数组用来记录方案数即可 代码如下： 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3 + 10, mod = 1000000007;int w[N], v[N], dp[N], num[N];int main()&#123; int n, V; scanf(\"%d%d\", &amp;n, &amp;V); for(int i = 0; i &lt; n; i++)&#123; scanf(\"%d%d\", &amp;v[i], &amp;w[i]); num[i] = 1; &#125; for(int i = 0; i &lt; n; i++)&#123; for(int j = V; j &gt;= v[i]; j--)&#123; if(dp[j] &lt; dp[j - v[i]] + w[i])&#123;//更新最大价值 dp[j] = dp[j - v[i]] + w[i]; num[j] = num[j - v[i]] % mod;//num数组记录更新方案数 &#125; else if(dp[j] == dp[j - v[i]] + w[i])&#123;//如果相等 num[j] = (num[j] + num[j - v[i]]) % mod;//方案数相加 &#125; &#125; &#125; cout &lt;&lt; num[V] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/categories/动态规划/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"背包问题","slug":"背包问题","permalink":"http://zhumenger.top/tags/背包问题/"}]},{"title":"博弈论","slug":"数论/博弈论","date":"2019-07-11T09:12:52.000Z","updated":"2019-07-11T09:14:07.784Z","comments":true,"path":"2019/07/11/数论/博弈论/","link":"","permalink":"http://zhumenger.top/2019/07/11/数论/博弈论/","excerpt":"","text":"博弈论一.NIM博弈给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。 我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。NIM博弈不存在平局，只有先手必胜和先手必败两种情况。 定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An != 0 代码如下： 123456789101112131415#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int a[N];int main()&#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++)cin &gt;&gt; a[i]; int ans = 0; for(int i = 0; i &lt; n; i++)ans ^= a[i]; if(ans != 0)cout &lt;&lt; \"Yes\" &lt;&lt; endl; else puts(\"No\"); return 0;&#125; 二.SG函数Mex运算： 设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：mex(S) = min{x}, x属于自然数，且x不属于S SG函数 在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达子节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即：SG(x) = mex({SG(y1), SG(y2), …, SG(yk)}) 特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。 有向图游戏的和 设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即： SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm) 定理有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。 例题：集合-Nim游戏 给定n堆石子以及一个由k个不同正整数构成的数字集合S。 现在有两位玩家轮流操作，每次操作可以从任意一堆石子中拿取石子，每次拿取的石子数量必须包含于集合S，最后无法进行操作的人视为失败。 问如果两人都采用最优策略，先手是否必胜。 输入格式 第一行包含整数k，表示数字集合S中数字的个数。 第二行包含k个整数，其中第i个整数表示数字集合S中的第i个数si。 第三行包含整数n。 第四行包含n个整数，其中第ii个整数表示第i堆石子的数量hi。 输出格式 如果先手方必胜，则输出“Yes”。 否则，输出“No”。 数据范围1≤n,k≤1001≤si,hi≤10000 输入样例： 22 532 4 7 输出样例： Yes 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 110, M = 10010;int n, m;int f[N], SG[M], s[M];void getSG(int n)//SG函数模板&#123; memset(SG, 0, sizeof SG); for(int i = 1; i &lt;= n; i++)&#123; memset(s, 0, sizeof s); for(int j = 0; f[j] &lt;= i &amp;&amp; j &lt; m; j++)&#123; s[SG[i - f[j]]] = 1;//记录i的子节点的SG函数 &#125; for(int j = 0;; j++)&#123; if(!s[j])&#123; SG[i] = j; break; &#125; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; m; for(int i = 0; i &lt; m; i++)cin &gt;&gt; f[i]; sort(f, f + m); getSG(10000); cin &gt;&gt; n; int ans = 0; for(int i = 0; i &lt; n; i++)&#123; int x; cin &gt;&gt; x; ans ^= SG[x]; &#125; if(ans)puts(\"Yes\"); else puts(\"No\"); return 0;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"博弈论","slug":"博弈论","permalink":"http://zhumenger.top/tags/博弈论/"}]},{"title":"容斥原理","slug":"数论/容斥原理","date":"2019-07-11T08:56:39.000Z","updated":"2019-07-11T08:57:31.198Z","comments":true,"path":"2019/07/11/数论/容斥原理/","link":"","permalink":"http://zhumenger.top/2019/07/11/数论/容斥原理/","excerpt":"","text":"容斥原理什么是容斥原理 在计数时，必须注意没有重复，没有遗漏。为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。 1.假设有俩个圆相交，要你求它的面积，便可得到 两个集合的容斥关系：S1∪S2 =|S1∪S2| = |S1|+|S2| - |S1∩S2 | *2.假设有3个圆相交，要你求它的面积: * 那么三个集合的容斥关系S = s1 + s2 + s3 - (s1 ∩ s2) - (s1 ∩ s3) - (s2 ∩ s3) + (s1 ∩ s2 ∩ s3) 在这个基础上加以推广便可得到我们的容斥原理公式： 题目描述给定一个整数n和m个不同的质数p1,p2,…,pm。 请你求出1~n中能被p1,p2,…,pm中的至少一个数整除的整数有多少个。 输入格式第一行包含整数n和m。 第二行包含m个质数。 输出格式输出一个整数，表示满足条件的整数的个数。 数据范围1≤m≤161≤n,pi≤109 输入样例： 10 22 3 输出样例： 7 代码如下： 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;const int N = 20;typedef long long int ll;int a[N];int main()&#123; int n,m; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i++) cin &gt;&gt; a[i]; int ans = 0; for(int i = 1; i &lt; 1 &lt;&lt; m; i++)&#123;//用位运算来表示哪些数被选过 int t = 1, cnt = 0; //t表示所有被选的数的乘积，cnt表示选中数的个数 for(int j = 0; j &lt; m; j++)&#123; if(i &gt;&gt; j &amp; 1)&#123; cnt++; if((ll)t * a[j] &gt; n)&#123; //如果乘积大于n, 则这种方法不行 t = -1; break; &#125; t *= a[j]; &#125; &#125; if(t != -1)&#123; //奇+ 偶- if(cnt % 2)ans += n / t; //n里面有多少个t else ans -= n / t; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"容斥原理","slug":"容斥原理","permalink":"http://zhumenger.top/tags/容斥原理/"}]},{"title":"JS基础之强制类型转换","slug":"JavaScirpt/JS基础之强制类型转换","date":"2019-07-10T10:08:47.000Z","updated":"2019-07-10T10:12:20.386Z","comments":true,"path":"2019/07/10/JavaScirpt/JS基础之强制类型转换/","link":"","permalink":"http://zhumenger.top/2019/07/10/JavaScirpt/JS基础之强制类型转换/","excerpt":"","text":"强制类型转换将一个数据类型转化为另一个数据类型，如：String Number Boolean 1.转化为String类型123456789101112131415161718192021222324252627282930313233343536373839&lt;script type=\"text/javascript\"&gt; /* *方式一： * -调用被转换数据类型的toString()的方法 * -该方法不会影响到原变量，它会将转换的结果返回 * -注意：null和undefined这俩个值没有toString()方法 * 如果调用他们，会报错 */ var a = 123; var b = a.toString(); console.log(typeof a);//输出number console.log(typeof b)//输出string //给自己赋值 a = a.toString(); a = null; //a = a.toString();//报错 a = undefined; //a = a.toString();//报错 /*方式二： * -调用String()函数，并将被转换的数据作为参数传递给函数 * -调用String()函数做强制类型转换时， * 对于Number和boolean实际上就是调用的toString()方法 * 对于null和undefined不会调用toString()方法 * 它会直接转化为字符串 */ a = 123; a = String(a); a = null; a = String(a);//输出字符串\"null\" a = undefined; a = String(a);//输出字符串\"undefined\" &lt;/script&gt; 2.转化为number类型1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;script type=\"text/javascript\"&gt; /* *方式一: * -使用Number()函数 * -字符 --&gt; 数字 * 1.如果是纯数字的字符串，直接转化为相应的数字 * 2.如果字符串中有只要有非数字的内容，则转换为NaN * 3.如果字符串为空串或者全是空格，则转化为0 * -布尔 --&gt; 数字 * true 转为1 * false 转为0 * -Null --&gt; 数字 0 * -undefined --&gt; 数字 NaN */ var a = \"123\"; a = Number(a); a = true; a = Number(a);//值为1 a = false; a = Number(a);//值为0 a = null; a = Number(a);//值为0 a = undefined; a = Number();//值为NaN /* *转化方式二： * -专门用来对付字符串的 * -parseInt();//把字符串转化为一个整数 * -parseFloat();//把一个字符串转化为浮点数 * -可以将字符串中有效的数字转化为Number * -只要遇到非数字内容，后面的即使有整数也不再读取 * -如果对非String使用parseInt() * 它会先将其转化为String,然后在操作 */ a = \"123px\"; a = parseInt(a);//输出123 a = true; a = parseInt(a);//输出NaN&lt;/script&gt;","categories":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/categories/JavaScirpt/"}],"tags":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/tags/JavaScirpt/"}]},{"title":"满足条件的01序列","slug":"数论/满足条件的01序列","date":"2019-07-10T08:18:54.000Z","updated":"2019-07-10T11:51:16.019Z","comments":true,"path":"2019/07/10/数论/满足条件的01序列/","link":"","permalink":"http://zhumenger.top/2019/07/10/数论/满足条件的01序列/","excerpt":"","text":"题目描述 给定n个0和n个1，它们将按照某种顺序排成长度为2n的序列，求它们能排列成的所有序列中，能够满足任意前缀序列中0的个数都不少于1的个数的序列有多少个。 输出的答案对109+7取模。 输出格式 共一行，包含整数n。 输出格式 共一行，包含一个整数，表示答案。 数据范围 1≤n≤105 输入样例： 3 输出样例： 5 题解： 可以将这道题转化为表格的形式，0表示向左走一格，1表示向上走一格，要想满足前缀序列中0的个数始终不少于1的个数，只需满足x &gt;= y即可，如下图所示 即到(n, n)的路径中不能越过红线，越过红线的路径皆为违法的路径,如下图所示： 任意一条违法的路径都能通过 y = x 这条线从(n, n)映射到(n - 1, n + 1) 所以违法的路径我们是可以求出来的，即C(2n, n - 1), 那么用总路径减去违法的路径便是我们想要求出的答案 即answer = C(2n, n) - C(2n, n - 1), 化简可得answer = (2n)! /(n! * n!)/(1 + n) = C(2n, n) / (1 + n) 代码如下： 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;typedef long long ll;const int mod = 1e9 + 7;int ksm(int a, int b)//快速幂求乘法逆元&#123; ll ans = 1; while(b)&#123; if(b &amp; 1)ans = (ll)ans * a % mod; b &gt;&gt;= 1; a = (ll)a * a % mod; &#125; return ans;&#125;int main()&#123; int n; cin &gt;&gt; n; int a = 2 * n, b = n; int ans = 1; for(int i = a; i &gt; a - b; i--) ans = (ll)ans * i % mod; for(int i = 1; i &lt;= b; i++) ans = (ll)ans * ksm(i, mod - 2) % mod; ans = (ll)ans * ksm(n + 1, mod - 2) % mod; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"}]},{"title":"组合数IV之高精度","slug":"数论/组合数IV之高精度","date":"2019-07-10T07:56:50.000Z","updated":"2019-07-10T07:58:04.918Z","comments":true,"path":"2019/07/10/数论/组合数IV之高精度/","link":"","permalink":"http://zhumenger.top/2019/07/10/数论/组合数IV之高精度/","excerpt":"","text":"题目描述 输入a,b，求C(a, b)的值。 注意结果可能很大，需要使用高精度计算。 输入格式 共一行，包含两个整数a和b。 输出格式 共一行，输出C(a, b)的值。 数据范围 1≤b≤a≤5000 输入样例： 5 3 输出样例： 10 题解： 可以用公式C(a, b) = a! / (b! * (a - b)!) 来做，如果直接用for循环求阶乘的话，时间复杂度很大，我们求除法运算的时候，一般都是将他们分解质因数，然后用分子分解质因数的个数减去分母分解质因数的个数，最后将质因数乘起来便是最后的答案 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N = 5010;int primes[N], cnt;int sum[N];bool st[N];void get_primes(int n) //线性筛法得到质因数&#123; for(int i = 2; i &lt;= n; i++)&#123; if(!st[i]) primes[cnt++] = i; for(int j = 0; j &lt; cnt &amp;&amp; primes[j] &lt;= n / i; j++)&#123; st[primes[j] * i] = true; if(i % primes[j] == 0)break; &#125; &#125;&#125;int get(int n, int p)//得到p这个质因数的个数&#123; int res = 0; while(n)&#123; res += n / p; n /= p; &#125; return res;&#125;vector&lt;int&gt; mul(vector&lt;int&gt; a, int b)//高精度乘法&#123; vector&lt;int&gt; ans; int t = 0; for(int i = 0; i &lt; a.size(); i++)&#123; t += a[i] * b; ans.push_back(t % 10); t /= 10; &#125; while(t)&#123; ans.push_back(t % 10); t /= 10; &#125; return ans;&#125;int main()&#123; int a, b; cin &gt;&gt; a &gt;&gt; b; get_primes(a); for(int i = 0; i &lt; cnt; i++)&#123; int p = primes[i]; sum[i] = get(a, p) - get(b, p) - get(a - b, p);//获取除法运算中每个质因数的个数 &#125; vector&lt;int&gt;res; res.push_back(1); for(int i = 0; i &lt; cnt; i++)&#123;//枚举每个质因数 for(int j = 0; j &lt; sum[i]; j++)&#123;//枚举个数 res = mul(res, primes[i]);//高精度乘法 &#125; &#125; for(int i = res.size() - 1; i &gt;= 0; i--)&#123;//倒序输出 cout &lt;&lt; res[i]; &#125; return 0;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"组合数","slug":"组合数","permalink":"http://zhumenger.top/tags/组合数/"}]},{"title":"高斯消元解线性方程组","slug":"数论/高斯消元解线性方程组","date":"2019-07-09T04:40:45.000Z","updated":"2019-07-09T05:47:05.248Z","comments":true,"path":"2019/07/09/数论/高斯消元解线性方程组/","link":"","permalink":"http://zhumenger.top/2019/07/09/数论/高斯消元解线性方程组/","excerpt":"","text":"一.高斯消元解线性方程组题目描述输入一个包含n个方程n个未知数的线性方程组。 方程组中的系数为实数。 求解这个方程组。 下图为一个包含m个方程n个未知数的线性方程组示例： 输入格式 第一行包含整数n。 接下来n行，每行包含n+1个实数，表示一个方程的n个系数以及等号右侧的常数。 输出格式 如果给定线性方程组存在唯一解，则输出共n行，其中第i行输出第i个未知数的解，结果保留两位小数。 如果给定线性方程组存在无数解，则输出“Infinite group solutions”。 如果给定线性方程组无解，则输出“No solution”。 数据范围 1≤n≤100,所有输入系数以及常数均保留两位小数，绝对值均不超过100。 输入样例： 31.00 2.00 -1.00 -6.002.00 1.00 -3.00 -9.00-1.00 -1.00 2.00 7.00 输出样例： 1.00-2.003.00 题解： 高斯消元，即线性代数的知识，将方程组系数矩阵转化为三角矩阵: 1.枚举每一列，在每一列中找到绝对值最大的一行 2.将改行放到最上面，并将该行首非零元素化为1 3.将下面的所有行的第c列化为0， 4.最终得到三角矩阵，倒叙遍历，不断减去前面的解乘以系数，便可得到所有的解 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int N = 110;const double eps = 1e-6;int n;double a[N][N];int gauss()&#123; int c, r; for(c = 0, r = 0; c &lt; n; c++)&#123;//枚举每一列 int t = r; for(int i = r; i &lt; n; i++) if(fabs(a[i][c]) &gt; fabs(a[t][c]))//找到这一列绝对值最大的一行 t = i; if(fabs(a[t][c]) &lt; eps)continue; //如果全为0，则略过 for(int i = c; i &lt; n + 1; i++)swap(a[t][i], a[r][i]);//将第t行与第r行交换 for(int i = n; i &gt;= c; i--)a[r][i] /= a[r][c];//将首元素系数化为1 for(int i = r + 1; i &lt; n; i++) //将第r + 1行以下的第c列的元素化为0 if(fabs(a[i][c]) &gt; eps) for(int j = n; j &gt;= c; j--) //每一列都要相减 a[i][j] -= a[r][j] * a[i][c]; r++; &#125; if(r &lt; n)&#123; //如果r &lt; n, r + 1 行一下的系数都为0 for(int i = r; i &lt; n; i++) if(fabs(a[i][n]) &gt; eps) //a[i][n]不为0，说明0 = a[i][n]，无解 return 2; return 1; //否则有无穷多解 &#125; for(int i = n - 1 ; i &gt;= 0; i--) //否则有唯一解 for(int j = i + 1; j &lt; n; j++) //倒叙遍历，减去xi之前的x(i + j) * 系数，变得到了xi的解 a[i][n] -= a[j][n] * a[i][j]; return 0;&#125;int main()&#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt;= n; j++) cin &gt;&gt; a[i][j]; int t = gauss(); if(t == 0)&#123; for(int i = 0; i &lt; n; i++)printf(\"%.2lf\\n\", a[i][n]); &#125; else if(t == 1)puts(\"Infinite group solutions\"); else puts(\"No solution\"); return 0;&#125; 二.高斯消元解异或线性方程组题目描述 输入一个包含n个方程n个未知数的异或线性方程组。 方程组中的系数和常数为0或1，每个未知数的取值也为0或1。 求解这个方程组. 异或线性方程组示例如下： 1234M[1][1]x[1] ^ M[1][2]x[2] ^ … ^ M[1][n]x[n] = B[1]M[2][1]x[1] ^ M[2][2]x[2] ^ … ^ M[2][n]x[n] = B[2]…M[n][1]x[1] ^ M[n][2]x[2] ^ … ^ M[n][n]x[n] = B[n] 其中“^”表示异或(XOR)，M[i][j]表示第i个式子中x[j]的系数，B[i]是第i个方程右端的常数，取值均为0或1。 输入格式 第一行包含整数n。 接下来n行，每行包含n+1个整数0或1，表示一个方程的n个系数以及等号右侧的常数。 输出格式 如果给定线性方程组存在唯一解，则输出共n行，其中第i行输出第i个未知数的解。 如果给定线性方程组存在无数解，则输出“Infinite group solutions”。 如果给定线性方程组无解，则输出“No solution”。 数据范围 1≤n≤100 输入样例： 31 1 0 10 1 1 01 0 0 1 输出样例： 100 题解： 思路跟第一题一样，代码稍微改改就行 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int N = 110;int n;int a[N][N];int gauss()&#123; int c, r; for(c = 0, r = 0; c &lt; n; c++)&#123;//枚举每一列 int t = r; for(int i = r; i &lt; n; i++) if(a[i][c] &gt; a[t][c])//找到这一列绝对值最大的一行 t = i; if(!a[t][c])continue; //如果全为0，则略过 for(int i = c; i &lt; n + 1; i++)swap(a[t][i], a[r][i]);//将第t行与第r行交换 for(int i = r + 1; i &lt; n; i++) //将第r + 1行以下的第c列的元素化为0 if(a[i][c]) for(int j = n; j &gt;= c; j--) //每一列都要异或 a[i][j] ^= a[r][j]; r++; &#125; if(r &lt; n)&#123; //如果r &lt; n, r + 1 行一下的系数都为0 for(int i = r; i &lt; n; i++) if(a[i][n]) //a[i][n]不为0，说明0 = a[i][n]，无解 return 2; return 1; //否则有无穷多解 &#125; for(int i = n - 1 ; i &gt;= 0; i--) for(int j = i + 1; j &lt; n; j++) a[i][n] ^= a[j][n] * a[i][j]; return 0;&#125;int main()&#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt;= n; j++) cin &gt;&gt; a[i][j]; int t = gauss(); if(t == 0)&#123; for(int i = 0; i &lt; n; i++)printf(\"%d\\n\", a[i][n]); &#125; else if(t == 1)puts(\"Infinite group solutions\"); else puts(\"No solution\"); return 0;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"高斯消元","slug":"高斯消元","permalink":"http://zhumenger.top/tags/高斯消元/"}]},{"title":"JS基础之标识符、数据类型","slug":"JavaScirpt/JS基础之标识符、数据类型","date":"2019-07-08T14:24:12.000Z","updated":"2019-07-10T09:16:43.143Z","comments":true,"path":"2019/07/08/JavaScirpt/JS基础之标识符、数据类型/","link":"","permalink":"http://zhumenger.top/2019/07/08/JavaScirpt/JS基础之标识符、数据类型/","excerpt":"","text":"一.标识符1.在JS中所有的可以由我们自主命名的都可以称为标识符 2.命名规则： 1.标识符中可以含有字母、数字、下划线和$。2.标识符不能以数字开头3.标识符不能是关键字 4.标识符一般采用驼峰命名法： 首字母小写，每个单词的开头字母大写，其余字母小写 如: var helloWorld = 123； 二.数据类型数据类型指的是字面量的类型，一共有6种 String 字符串 Number 数值 Boolean 布尔值 Null 空值 Undefined 未定义 Object 对象 前5个为基本数据类型，Object属于引用数据类型 1.字符串声明: 1234567&lt;script type=\"text/javascript\"&gt; var str = \"hello\"; //输出字面量 字符串str alert(\"str\"); //输出变量str alert(str);&lt;/script&gt; 1&gt;.单引号，双引号都可以，但必须配对，不能混淆 2&gt;.引号不能嵌套，双引号里不能放双引号，单引号里不能放单引号 3&gt;.双引号里可以嵌套单引号 4&gt;.如果想要任意嵌套，必须加入转义字符 转义字符： 在字符串中可以用\\作为转义字符 如\\ “表示 单引号， \\ n 表示换行， \\ \\ 表示斜杠 2.数值1&gt;.声明 123&lt;script type=\"text/javascript\"&gt; var a = 123;&lt;/script&gt; 2&gt;.可以用 typeof 来检查一个变量的类型 123456&lt;script type=\"text/javascript\"&gt; var a = 123; console.log(typeof a);//输出“number”类型 var b = \"123\" console.log(typeof b);//输出“string”类型&lt;/script&gt; 3&gt;.输出数字的最大值、最小值 1234567&lt;script type=\"text/javascript\"&gt; //输出最大值 console.log(Number.MAX_VALUE); //输出最小值 console.log(Number.MIN_VALUE); //如果使用的Number表示的数字超过了最大值,则会返回一个Infinity表示无穷&lt;/script&gt; 4&gt;.NAN 是一个特殊的数字， 表示Not A Number 1234567&lt;script type=\"text/javascript\"&gt; var a = \"abc\" * \"abc\"; console.log(a); //输出NAN， console.log(typeof a); //输出number&lt;/script&gt; 5&gt;.如果JS进行浮点元素，可能得到一个不确定的结果 12345&lt;script type=\"text/javascript\"&gt; var a = 0.1 + 0.2; comsole.log(a); //输出0.3000000000000004&lt;/script&gt; 3.布尔值 Boolean1234567891011&lt;script type=\"text/javascript\"&gt; /* *Boolean 布尔值 * 布尔值只有俩个 * true -表示真 * false -表示假 */ var bool = false; console.log(bool)//输出false console.log(typeof bool)//输出boolean&lt;/script&gt; 4.Null12345678910&lt;script type=\"text/javascript\"&gt; /* * Null类型只有一个,就是null * null表示一个为空的对象 * 使用typeof检查null值时，返回object */ var a = null; console.log(a);//输出null console.log(typeof a);//输出//object &lt;/script&gt; 5.Undefined12345678&lt;script type=\"text/javascript\"&gt; /* * Undefined的类型只有一个，就是undefined * 当声明一个变量未赋值时，就是undefined */ var a; console.log(a)//输出undefined &lt;/script&gt;","categories":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/categories/JavaScirpt/"}],"tags":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/tags/JavaScirpt/"}]},{"title":"扩展欧几里得算法","slug":"数论/扩展欧几里得算法","date":"2019-07-08T03:36:44.000Z","updated":"2019-07-08T03:39:26.332Z","comments":true,"path":"2019/07/08/数论/扩展欧几里得算法/","link":"","permalink":"http://zhumenger.top/2019/07/08/数论/扩展欧几里得算法/","excerpt":"","text":"一.扩展欧几里得算法裴蜀定理 对于任意的整数a, b，存在一对整数 x，y，满足ax + by = gcd(a, b). 题目描述 给定n对正整数ai,bi，对于每对数，求出一组xi,yi，使其满足ai∗xi+bi∗yi=gcd(ai,bi)。 输入格式 第一行包含整数n。 接下来n行，每行包含两个整数ai,bi。 输出格式 输出共n行，对于每组ai,bi，求出一组满足条件的xi,yi，每组结果占一行。 本题答案不唯一，输出任意满足条件的xi,yi均可。 数据范围 1≤n≤1051≤ai,bi≤2∗109 输入样例： 24 68 18 输出样例： -1 1-2 1 代码如下： 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;typedef long long int ll;ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y)&#123; if(b == 0)&#123; x = 1; y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x ; //y表示b的系数 return d;&#125;int main()&#123; int n; ll a, b, x, y; cin &gt;&gt; n; while(n--)&#123; scanf(\"%lld%lld\", &amp;a, &amp;b); ll d = exgcd(a, b, x, y); printf(\"%lld %lld\\n\", x, y); &#125; return 0;&#125; 二.线性同余方程题目描述给定n组数据ai,bi,mi，对于每组数求出一个xi，使其满足ai∗xi≡bi(mod mi)，如果无解则输出impossible。 输入格式第一行包含整数n。 接下来n行，每行包含一组数据ai,bi,mi。 输出格式输出共n行，每组数据输出一个整数表示一个满足条件的xi，如果无解则输出impossible。 每组数据结果占一行，结果可能不唯一，输出任意一个满足条件的结果均可。 输出答案必须在int范围之内。 数据范围1≤n≤10^51≤ai,bi,mi≤2∗10^9 输入样例： 22 3 64 3 5 输出样例： impossible7 题解： 对于a * x % m = b 等价于 a * x - b 是m的倍数，不妨设为 -y 倍。于是，该方程可以改写为 a * x + m * y = b。 这样就变成了欧几里得算法，只有 b 为 gcd(a, m) 的倍数的时候，方程才有解，带公式即可 代码如下： 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;typedef long long int ll;ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y)&#123; if(b == 0)&#123; x = 1; y = 0; return a; &#125; ll d = exgcd(b, a % b, y ,x); y -= a / b * x; return d;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; ll a, b, c; ll x, y; scanf(\"%lld %lld %lld\", &amp;a, &amp;b, &amp;c); ll d = exgcd(a, c, x, y); if(b % d == 0) printf(\"%lld\\n\", x *(b / d) % c); //x 乘以倍数 % c else puts(\"impossible\"); &#125; return 0;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"http://zhumenger.top/tags/扩展欧几里得/"}]},{"title":"JS基础之基本语法、字面量和变量","slug":"JavaScirpt/JS基础之基本语法、字面量和变量","date":"2019-07-07T13:14:03.000Z","updated":"2019-07-07T13:16:35.696Z","comments":true,"path":"2019/07/07/JavaScirpt/JS基础之基本语法、字面量和变量/","link":"","permalink":"http://zhumenger.top/2019/07/07/JavaScirpt/JS基础之基本语法、字面量和变量/","excerpt":"","text":"一.基本语法1.注释 123456&lt;script type=\"text/javascript\"&gt; //单行注释 /* 多行注释，注释中的内容不会被执行 */&lt;/script&gt; 2.JS中严格区分大小写 12alert(\"hello world\");//可以执行Alert(\"hello world\")；//会报错 3.分号表示一个语句的结束. 如果不写分号，浏览器会自动添加，但是会消耗一些系统资源 而且有点时候，浏览器会加错分号，所以在开发中分号必须写 4.JS会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化 二.字面量和变量1.字面量 都是一些不可改变的值，比如：1 2 3 4 5 字面量可以直接使用，但是我们一般都不会直接使用字面量 2.变量 可以用来保存字面量，而且变量的值可以任意改变 所以在开发中都是通过变量取保存一个字面量，而很少直接用到字面量 3.变量的使用 123456//在JS中使用var关键字来声明一个变量var a;//为变量赋值a = 123；//向页面输出adocument.write(a)","categories":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/categories/JavaScirpt/"}],"tags":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/tags/JavaScirpt/"}]},{"title":"JS基础之编写位置","slug":"JavaScirpt/JS基础之编写位置","date":"2019-07-07T12:45:20.000Z","updated":"2019-07-07T12:50:11.539Z","comments":true,"path":"2019/07/07/JavaScirpt/JS基础之编写位置/","link":"","permalink":"http://zhumenger.top/2019/07/07/JavaScirpt/JS基础之编写位置/","excerpt":"","text":"1.可以将JS的代码写到标签的属性中，当点击按钮时执行 1&lt;button onclick = \"alert('讨厌，你点我干嘛');\"&gt;点我一下&lt;/button&gt; 2.可以将JS代码写在href属性中，这样点击超链接时，会执行JS代码 1&lt;a href=\"javascript:alert('让你点你就点');\"&gt;你也点我一下&lt;/a&gt; 虽然可以写在标签的属性中，但是他们属于结构与行为耦合不方便维护，不推荐使用 3.可以将JS写在script标签中,打开网页时直接运行 123&lt;script type=\"text/javascript\"&gt; alert(\"我是script标签中的代码\");&lt;/script&gt; 4.可以将JS代码写到外部JS文件中，然后通过script标签引入,用src引入路径 1&lt;script type=\"text/javascript\" src=\"script.js\"&gt;&lt;/script&gt; script标签一旦引入外部文件，就不能编写代码了，即使编写了代码，编译器也会忽略","categories":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/categories/JavaScirpt/"}],"tags":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/tags/JavaScirpt/"}]},{"title":"JS基础之Hello World","slug":"JavaScirpt/JS基础之Hello-World","date":"2019-07-07T11:51:48.000Z","updated":"2019-07-07T11:57:14.595Z","comments":true,"path":"2019/07/07/JavaScirpt/JS基础之Hello-World/","link":"","permalink":"http://zhumenger.top/2019/07/07/JavaScirpt/JS基础之Hello-World/","excerpt":"","text":"输出语句1.所有的JS代码都要放到script标签里 2.alert(）：可以控制浏览器发出一个警告框 123&lt;script type=\"text/javascript\"&gt; alert(\"这是我的第一行JS代码\");&lt;/script&gt; 效果如下： 3.document.write()可以向body中输出一个内容 123&lt;script type=\"text/javascript\"&gt; document.write(\"看我出不出来\");&lt;/script&gt; 4.console.log()可以向控制台输出一个内容 123&lt;script type=\"text/javascript\"&gt; console.log(\"你猜猜我在哪\");&lt;/script&gt; 效果如下：","categories":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/categories/JavaScirpt/"}],"tags":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/tags/JavaScirpt/"}]},{"title":"快速幂","slug":"数论/快速幂","date":"2019-07-07T06:04:35.000Z","updated":"2019-07-07T06:05:45.942Z","comments":true,"path":"2019/07/07/数论/快速幂/","link":"","permalink":"http://zhumenger.top/2019/07/07/数论/快速幂/","excerpt":"","text":"一.快速幂快速幂问题（求a^b）: 1.我们都知道当指数为偶数的时候，对于a ^b，可以变为(a ^ 2) ^ (b/2)。2.而当指数为奇数的时候，对于a ^ b，可以化简为a * (a ^ (b-1))，然后即可以化简为a * ((a ^ 2) ^ ((b-1)/2))3.如此我们便可知道 如果b为奇数，则将b减一除二，将一个a取到外面，同时对里面的a平方。4.如果b为偶数，则直接除二，同时对a平方。 若b为7，a为2。则a变为4，b变为3，ans变为2 * (2 ^ 2) ^ 3。然后继续向后运，(注意此时a为4)，a变为16，b变为1，ans变为2* 4*(2 ^ 2 ^ 2) ^ 1。结果为128。 若b为10，a为2。则a变为4，b变为5，ans变(2 ^ 2) ^ 5。然后继续向后运，(注意此时a为4)，a变为16，b变为2，ans变为4(2 ^ 2 ^ 2) ^2。再之后(注意此时a为16)，a变为256，b变为1，ans变为4(2 ^ 2 ^ 2 ^ 2) ^ 1。结果为1024 快速幂取余 代码如下： 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;typedef long long int ll;ll a, b, c;void solve()&#123; ll ans = 1; while(b)&#123; if(b &amp; 1)ans = ans * a % c; //如果b为奇数 b &gt;&gt;= 1; //b除以2 a = a * a % c; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; solve(); &#125; return 0;&#125; 二.快速幂求逆元题目描述 给定n组ai,pi，其中pipi是质数,求ai模pi的乘法逆元，若逆元不存在则输出impossible。 输入格式 第一行包含整数n。 接下来n行，每行包含一个数组ai,pi，数据保证pi是质数。 输出格式 输出共n行，每组数据输出一个结果，每个结果占一行。 若ai模pi的乘法逆元存在，则输出一个整数，表示逆元，否则输出impossible。 数据范围 1≤n≤10^51≤ai,pi≤2∗10^9 输入样例： 34 38 56 3 输出样例： 12impossible 什么是逆元** 若b与m互质，对于a/b(a是b的倍数) % m，可以找到一个数x使得ax % m = a/b % m,那么我们称x为b%m的逆元 费马定理： 若p为质数，则b^(p - 1) % p == 1。 题解： 这道题用到了费马定理，b * b^(p - 2) % p == 1,所以只需求b^(p - 2) % p即可，那么这道题便转化为了一道快速幂的问题 代码如下： 12345678910111213141516171819202122232425//费马定理：若p为质数，则a^(p -1)% p == 1,可得a * a^(p - 2) % p == 1，这道题求a^(p - 2) % p 便是a的逆元#include&lt;iostream&gt;using namespace std;typedef long long int ll;ll ksm(ll a, ll b, ll c)&#123; ll ans = 1; while(b)&#123; if(b &amp; 1)ans = ans * a % c; b &gt;&gt;= 1; a =a * a % c; &#125; return ans;&#125;int main()&#123; ll t, a, b; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; a &gt;&gt; b; if(a % b == 0)cout &lt;&lt; \"impossible\" &lt;&lt; endl;//若a是p的倍数，则不存在逆元 else cout &lt;&lt; ksm(a, b - 2, b) &lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"快速幂","slug":"快速幂","permalink":"http://zhumenger.top/tags/快速幂/"}]},{"title":"欧拉函数","slug":"数论/欧拉函数","date":"2019-07-07T05:58:01.000Z","updated":"2019-07-07T06:00:17.297Z","comments":true,"path":"2019/07/07/数论/欧拉函数/","link":"","permalink":"http://zhumenger.top/2019/07/07/数论/欧拉函数/","excerpt":"","text":"一.欧拉函数什么是欧拉函数： 1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)。 欧拉函数的通式： φ(n)=n(1-1/p1)(1-1/p2)(1-1/p3)(1-1/p4)…..(1-1/pn),其中p1, p2……pn为n的所有质因数，n是不为0的整数。φ(1)=1（唯一和1互质的数就是1本身）。 欧拉定理： 若a与n互质，则a^φ(n) % n == 1 求欧拉函数的代码如下： 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;typedef long long int ll;void solve(ll n)&#123; ll ans = n; for(int i = 2; i &lt;= n / i; i++)&#123; if(n % i == 0)&#123; ans = ans / i * (i - 1);//如果i为n的质因数，则带入公式 while(n % i == 0)n /= i;//分解质因数 &#125; &#125; if(n &gt; 1)ans = ans / n * (n - 1); cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; ll n, t; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; n; solve(n); &#125; return 0;&#125; 二.. 筛法求欧拉函数 给定一个正整数n，求1~n中每个数的欧拉函数之和。 输入格式 共一行，包含一个整数n。 输出格式 共一行，包含一个整数，表示1~n中每个数的欧拉函数之和。 数据范围 1≤n≤10^6 输入样例： 6 输出样例： 12 思路： 在线性筛法的过程得到每个数的欧拉函数 1.如果i为质数，则i之前的数都与i互质,所以φ(i) = i - 1, 2.如果i % prime[j] == 0,φ(prime[j] * i) = prime[j] * ouler[i]; 3.若果i % prime[j] != 0, φ(prime[j] * i) = ouler[i] * (prime[j] - 1) 代码如下： 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int prime[N], ouler[N], cnt;typedef long long int ll;bool vis[N];void get_ouler(int n)&#123; ouler[1] = 1; //φ(1) = 1,与1互质的数为1 for(int i = 2; i &lt;= n; i++)&#123; if(!vis[i])&#123; //如果是质数 prime[cnt++] = i; ouler[i] = i - 1;//φ(i) = i - 1 &#125; for(int j = 0; j &lt; cnt &amp;&amp; prime[j] &lt;= n / i; j++)&#123; vis[prime[j] * i] = true; if(i % prime[j] == 0)&#123; ouler[prime[j] * i] = prime[j] * ouler[i]; break; &#125; ouler[prime[j] * i] = ouler[i] * (prime[j] - 1); &#125; &#125; ll ans = 0; for(int i = 1; i &lt;= n; i++) ans += ouler[i]; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; int n; cin &gt;&gt; n; get_ouler(n); return 0;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"http://zhumenger.top/tags/欧拉函数/"}]},{"title":"约数","slug":"数论/约数","date":"2019-07-07T05:54:22.000Z","updated":"2019-07-07T05:57:46.109Z","comments":true,"path":"2019/07/07/数论/约数/","link":"","permalink":"http://zhumenger.top/2019/07/07/数论/约数/","excerpt":"","text":"算术基本定理任何一个大于1的自然数 N ，如果N不为质数，都可以唯一分解成有限个质数的乘积 N = P1^a1 * P2^a2 ….Pn^an , 这里 P1&lt;P2&lt;….&lt;Pn均为质数，其诸指数 ai 是正整数。 定理应用（1）一个大于1的正整数N，如果它的标准分解式为： N = P1^a1 * P2^a2 ….Pn^an ，那么它的正因数个数为 φ(N) = (1 + a1)(1 + a2)(1 +a3)。 （2） 它的全体正因数之和为φ(N) = (1 + p1 + p1^2 + …+ p1^a1)(1 + p2 + p2^2 + … + p2^a2)…(1 + pn + pn^2 + … + pn^an). 一.约数个数题目描述 给定n个正整数ai，请你输出这些数的乘积的约数个数，答案对109+7取模。 输入格式 第一行包含整数n。 接下来n行，每行包含一个整数ai。 输出格式 输出一个整数，表示所给正整数的乘积的约数个数，答案需对109+7109+7取模。 数据范围 1≤n≤1001≤ai≤2∗10^9 输入样例： 3268 输出样例： 12 求n个数乘积的约数的个数，用到了定理（1）的知识，代码如下： 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;unordered_map&gt;using namespace std;unordered_map&lt;int, int&gt; mp;typedef long long int ll;const int mod = 1e9 + 7;void solve(ll n)&#123; for(int i = 2; i &lt;= n / i; i++)&#123; while(n % i == 0)&#123; n /= i; mp[i]++; &#125; &#125; if(n &gt; 1)mp[n]++;//先分解所有的质因子&#125;int main()&#123; ll n, t; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt;n; solve(n); &#125; ll ans = 1; for(auto mps : mp)&#123; ans = ans * (mps.second + 1) % mod;//代公式即可 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 二.约数之和 给定n个正整数ai，请你输出这些数的乘积的约数之和，答案对109+7取模。 输入格式 第一行包含整数n。 接下来n行，每行包含一个整数ai。 输出格式 输出一个整数，表示所给正整数的乘积的约数之和，答案需对109+7取模。 数据范围 1≤n≤1001≤ai≤2∗10^9 输入样例： 3268 输出样例： 252 求n个数乘积的约数之和，用到了定理（2）的知识，代码如下： 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;unordered_map&gt;using namespace std;const int mod = 1e9 + 7;typedef long long int ll;unordered_map&lt;int, int &gt;mp;void solve(ll n)&#123; for(ll i = 2; i &lt;= n / i; i++)&#123; while(n % i == 0)&#123; n /= i; mp[i]++; &#125; &#125; if(n &gt; 1)mp[n]++;//分解所有的质因数&#125;int main()&#123; int t; ll n; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; n; solve(n); &#125; ll ans = 1; for(auto mps : mp)&#123; ll t= 1; ll x = mps.first, a = mps.second; while(a--)t = (t * x + 1) % mod; //带公式即可 ans = ans * t % mod; &#125; cout &lt;&lt;ans &lt;&lt; endl;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/categories/数论/"}],"tags":[{"name":"数论，约数","slug":"数论，约数","permalink":"http://zhumenger.top/tags/数论，约数/"}]},{"title":"二分图","slug":"图论/二分图/二分图","date":"2019-06-24T12:11:27.000Z","updated":"2019-07-07T03:08:53.783Z","comments":true,"path":"2019/06/24/图论/二分图/二分图/","link":"","permalink":"http://zhumenger.top/2019/06/24/图论/二分图/二分图/","excerpt":"","text":"二分图1.定义： 二分图是指将图中的点分为俩个集合X和Y，满足所有的边仅在俩个集合之间，并且俩个集合中没有边，即X中的点只与Y中的点相连，如下图所示，这样的图称为二分图。 2.性质： 当且仅当图中不含奇数环，即所有的环的边数为偶数。这样的图一定是二分图。 3.判定： 染色法判定二分图原理： 首先任意取出一个顶点进行染色,和该节点相邻的点有三种情况: 1.未染色 那么继续染色此节点(染色为另一种颜色) 2.已染色但和当前节点颜色不同 跳过该点 3.已染色并且和当前节点颜色相同 返回失败(该图不是二分图) 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int h[N], e[N], ne[N], idx;int n, m, color[N];//color表示哪些点已经被染了色void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;bool dfs(int x, int c)//c表示染色的种类&#123; color[x] = c; for(int i = h[x]; i != -1; i = ne[i])&#123; int j = e[i]; if(color[j] == c)return false;//如果与i相连的点与i染成了相同的颜色，返回false else if(color[j] == 0 &amp;&amp; !dfs(j, -c))return false; //如果该点还没有被染色，并且染成相反的染色失败了的话，返回false &#125; return true;&#125;int main()&#123; scanf(\"%d%d\", &amp;n, &amp;m); memset(h, -1, sizeof h); while(m--)&#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); add(a, b); add(b, a); &#125; bool flag = false; for(int i = 1; i &lt;= n; i++)&#123;//遍历每一个点 if(color[i] == 0)&#123;//如果没有被染色 if(!dfs(i, 1))&#123;// 判断是否能被染色 flag = true; break; &#125; &#125; &#125; if(flag)puts(\"No\"); else puts(\"Yes\"); return 0;&#125; 二分图的最大匹配什么是匹配： 给定一个二分图G，在G的一个子图M中， M的边集{E}中的任意两条边都不交汇于同一个结点，则称M是一个匹配。 图中加粗的边是数量为2的匹配。 二分图的最大匹配 ：选择匹配边数最多的一个子图称为图的最大匹配 如下图所示，加粗的边数最多为3，所以该子图为二分图的最大匹配 如何求二分图的最大匹配： 匈牙利算法 假设左边的集合都为男生，右边的集合都为女生，让我们求出最多有多少对情侣能够配对成功。 对于每个男生，遍历他所有有好感度的女生，有俩种情况： 1.如果该女生是单身，则匹配成功 2.否则我们寻找与该女生的配对的那个男生，看看这个男生是否能和其他的女生配对，如果可以的话，让这个男与其备胎匹配，空出来的这个女生便可以与当前的这个男生配对成功。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e5 + 10;int h[N], e[N], ne[N], idx;int match[N];//一个映射关系:表示妹子与谁配了对bool vis[N];//表示哪些妹子已经遍历过了int n1, n2, m;void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;bool Find(int x)&#123; for(int i = h[x]; i != -1; i = ne[i])&#123;//遍历该男生所有有好感度的女生 int j = e[i]; if(!vis[j])&#123;//如果该女生还没有被当前男生询问过 vis[j] = true;//已经被询问过 if(match[j] == 0 || Find(match[j]))&#123;//如果该女生还没有配对或者与该女生配对的那个男生可以跟另 match[j] = x; //一个女生配对的话，该女生便可以与当前的这个男生配对。 return true;//返回true &#125; &#125; &#125; return false;//否则，返回false&#125;int main()&#123; cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m; memset(h, -1, sizeof h); while(m--)&#123; int a, b; cin &gt;&gt; a &gt;&gt; b; add(a, b); &#125; int ans = 0;//表示成功匹配了对少对 for(int i = 1; i &lt;= n1; i++)&#123; memset(vis, false, sizeof vis);//对于每一个男生，所有的妹子还没有询问过，所以这里要初始化 if(Find(i))ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://zhumenger.top/categories/图论/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://zhumenger.top/tags/图论/"},{"name":"二分图","slug":"二分图","permalink":"http://zhumenger.top/tags/二分图/"}]},{"title":"最小生成树","slug":"图论/最小生成树/最小生成树","date":"2019-06-24T03:26:41.000Z","updated":"2019-07-09T06:14:22.734Z","comments":true,"path":"2019/06/24/图论/最小生成树/最小生成树/","link":"","permalink":"http://zhumenger.top/2019/06/24/图论/最小生成树/最小生成树/","excerpt":"","text":"最小生成树题目描述 给出无向图中M个节点间N条边的权值。求一个使得所有点连通的子图,要求图内的边权和最小 输入格式 第一行包含两个整数n和m。 接下来m行，每行包含三个整数u，v，w，表示点u和点v之间存在一条权值为w的边。 输出格式 共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。 数据范围 1≤n≤5001≤n≤500,1≤m≤1051≤m≤105,图中涉及边的边权的绝对值均不超过10000。 输入样例： 4 51 2 11 3 21 4 32 3 23 4 4 输出样例： 6 一.克鲁斯卡尔算法(kruskal)算法定义： 假设 WN=(V,{E}) 是一个含有 n 个顶点的连通图，那么我们把它定义为含有 n 棵树的一个森林。每次从图的边集 E 中选取一条权值最小的边，若该条边的两个顶点分属不同的树，就将这两个顶点分别所在的两棵树合成一棵树，表示这俩个点已经连通；若该条边的两个顶点已落在同一棵树上，则直接跳过，因为前面已经选了一个更小的权值的边使得俩个点连在了一起。然后继续选择下一条最小的边加入到集合里面。依次类推，直至森林中只有一棵树，也即子图中含有 n-1条边为止。 kruskal算法流程: 1.建立并查集，每个点各自构成一个集合2.把所有的边按照权值从小到大排序，一次扫描每一条边3.若x，y属于同一个集合，则忽略这条边，继续扫描下一条边4.否则，合并x，y所在的集合，并将边权值累加到答案中 时间复杂度：O(mlogm) 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e6 + 10, INF = 0x3f3f3f3f;int f[N];struct p&#123; //存储所有的边 int a, b, c;&#125;arr[N];int n, m;bool cmp(p a, p b) //按照边权值从小到达排序&#123; return a.c &lt; b.c;&#125;int Find(int x) //找到x的根节点&#123; if(x != f[x])f[x] = Find(f[x]); return f[x];&#125;int main()&#123; int cnt = 0, ans = 0; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)f[i] = i; //初始化为n个集合 for(int i = 0; i &lt; m; i++) cin &gt;&gt; arr[i].a &gt;&gt; arr[i].b &gt;&gt; arr[i].c; sort(arr, arr + m, cmp); for(int i = 0; i &lt; m; i++)&#123; int x = Find(arr[i].a); int y = Find(arr[i].b); if(x != y)&#123; //如果不属于同一个集合 f[x] = y; cnt++; //边数++ ans += arr[i].c; //累加边权值 &#125; if(cnt == n - 1)break; &#125; if(cnt == n - 1)cout &lt;&lt; ans &lt;&lt; endl; else cout &lt;&lt; \"impossible\" &lt;&lt;endl; return 0;&#125; 二.prime算法算法简介： 首先维护一个集合，找到集合之外的距离这个集合最近的点，将这个点加入集合，并用这个点去更新其他点到集合的距离，这样得出来的生成树一定是最小的。算法思想跟dijstra算法类似。 时间复杂度：O(n^2) 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 510, INF = 0x3f3f3f3f;int n, m;int arr[N][N], dis[N];bool vis[N];void prime()&#123; memset(dis, INF, sizeof dis); int ans = 0; for(int i = 0; i &lt; n; i++)&#123; int t = -1; for(int j = 1; j &lt;= n; j++) if(!vis[j] &amp;&amp; (t == -1 || dis[t] &gt; dis[j]))//找到集合外的点到该集合距离最短的点 t = j; //用t记录该下标 if(i &amp;&amp; dis[t] == INF)&#123; //如果没有找到距离集合最短的点，说明这个图是不连通的 puts(\"impossible\"); return ; &#125; if(i)ans += dis[t]; //不断的加上该边权值 vis[t] = true; //表示该点已经加入到集合里了 //用t不断更新其他的点到集合的距离 for(int j = 1; j &lt;= n; j++)dis[j] = min(dis[j], arr[t][j]); &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; memset(vis, false, sizeof vis); cin &gt;&gt; n &gt;&gt; m; int a, b, c; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) arr[i][j] = i == j ? 0 : INF; while(m--)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; arr[a][b] = arr[b][a] = min(arr[a][b], c); &#125; prime(); return 0;&#125; 2.prime算法堆优化 跟dijstra算法一样，再找集合外的点到该集合距离最小的点时用堆做了一个优化。时间复杂度为：O(mlogn) 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;int arr[505][505];int dis[505];bool vis[505];typedef pair&lt;int ,int &gt; p;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt;= n; i++) for(int j = 0; j &lt;= n; j++) arr[i][j] = i == j ? 0 : INF; memset(dis, INF, sizeof dis); memset(vis, false, sizeof vis); int a, b, c; for(int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; arr[a][b] = arr[b][a] = min(arr[a][b], c); &#125; priority_queue&lt;p, vector&lt;p&gt;, greater&lt;p&gt; &gt; q; int ans = 0, sum = 0; dis[1] = 0; q.push(&#123;0, 1&#125;); while(q.size()) &#123; p cur = q.top(); q.pop(); int u = cur.second; if(vis[u])continue; vis[u] = true; sum++; //表示该点已经加入到集合当中 ans += dis[u];//加上该边权值 for(int i = 1; i &lt;= n; i++)&#123; //用该点不断更新集合外的点到集合的距离 if(!vis[i] &amp;&amp; dis[i] &gt; arr[u][i])&#123; dis[i] = arr[u][i]; q.push(&#123;dis[i], i&#125;); //如果该点被更新过，就加入到队列中去 &#125; &#125; &#125; if(sum == n)cout &lt;&lt; ans &lt;&lt; endl; //判断是否连通 else cout &lt;&lt; \"impossible\" &lt;&lt; endl; return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://zhumenger.top/categories/图论/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://zhumenger.top/tags/图论/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://zhumenger.top/tags/最小生成树/"}]},{"title":"编程俱乐部6月常规赛二题解","slug":"题解/编程俱乐部6月常规赛二题解","date":"2019-06-23T08:12:30.000Z","updated":"2019-06-23T08:19:57.049Z","comments":true,"path":"2019/06/23/题解/编程俱乐部6月常规赛二题解/","link":"","permalink":"http://zhumenger.top/2019/06/23/题解/编程俱乐部6月常规赛二题解/","excerpt":"","text":"编程俱乐部6月常规赛二题解一.魔法雪花 ****题解： 字符串的最小表示法：每一个字符串都有一个字典序最小的表示，比较这俩个字符串的最小表示是否相等即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;stdio.h&gt;using namespace std;string s1, s2;int n;int get(string s) //获得最小字典序的起始下标&#123; int i = 0, j = 1; while(i &lt;= n &amp;&amp; j &lt;= n) &#123; int k = 0; while(k &lt; n &amp;&amp; s[i + k] == s[j + k])k++; if(k == n)break; if(s[i + k] &lt; s[j + k])&#123; j = j + k + 1; if(i == j)j++; &#125; else &#123; i = i + k + 1; if(i == j)i++; &#125; &#125; return min(i, j);&#125;bool cmp(int i, int j) //比较字符串是否相同&#123; for(int k = 0; k &lt; n; k++)&#123; if(s1[i + k] != s2[j + k])return false; &#125; return true;&#125;int main()&#123; cin &gt;&gt; s1 &gt;&gt; s2; n = s1.size(); s1 += s1; //长度增加2倍 s2 += s2; int l = get(s1); int r = get(s2); if(cmp(l, r))&#123; cout &lt;&lt; \"Yes\" &lt;&lt; endl; for(int i = l; i &lt; l + n; i++) printf(\"%c\", s1[i]); &#125; else cout &lt;&lt; \"No\" &lt;&lt; endl; return 0;&#125; 二.魔仙彩石 题解：单调栈的运用，如果栈首的元素与a[i]相加&gt;m，就不断的弹出元素，直到a[i]与栈首的和&lt;=m或栈中的元素为空，让ans+=q[t]求出答案。 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int a[20010], q[20010], t = 0;int main()&#123; int n, m; long long int ans =0; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; sort(a, a + n); for(int i = 0; i &lt; n; i++)&#123; while(t &gt; 0 &amp;&amp; a[i] + a[q[t]] &gt;m)t--; if(t &gt; 0)ans += q[t] + 1; //单调栈的性质，该下标之前的元素与a[i]相加都小于等于m q[++t] = i; //单调栈记录下标 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; *三黑暗法阵 * 题解：经典的水池问题，如果该点为1，则让它等于0，继续往上下左右遍历，记录最大的ans即可 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;const int N = 110;int a[N][N];int dx[] = &#123;1, 0, -1, 0&#125;;int dy[] = &#123;0, 1, 0, -1&#125;;int n, m, res;void dfs(int x, int y)&#123; res++; a[x][y] = 0; for(int i = 0; i &lt; 4; i++)&#123; int xx = x + dx[i]; int yy = y + dy[i]; if(xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; m &amp;&amp; a[xx][yy] == 1) dfs(xx, yy); &#125;&#125;int main()&#123; while(cin &gt;&gt; n &gt;&gt; m)&#123; if(n == 0 &amp;&amp; m == 0)break; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) cin &gt;&gt; a[i][j]; int ans = 0; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j ++)&#123; if(a[i][j] == 1)&#123; res = 0; dfs(i, j); ans = max(ans, res); &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 四.女王搬水泥 题解： 最小生成树的题，将每条路的建造的时间从小到大排个序，依次遍历，如果都联通了输出当前的时间，break;如果遍历完一遍还没有全部联通，则输出-1 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e6 + 10;int f[N];struct p&#123; int a; int b; int c;&#125;arr[N];int Find(int x)&#123; if(x != f[x])f[x] = Find(f[x]); return f[x];&#125;bool cmp(p a, p b)&#123; return a.c &lt; b.c;&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) f[i] = i; for(int i = 0; i &lt; m; i++) cin &gt;&gt; arr[i].a &gt;&gt; arr[i].b &gt;&gt; arr[i].c; sort(arr, arr + m, cmp); int ans = 0, res = 1; for(int i = 0; i &lt; m; i++)&#123; int x = Find(arr[i].a); int y = Find(arr[i].b); if(x != y)&#123; res++; //记录联通了几个点 f[x] = y; &#125; if(res == n)&#123; //全部联通就输出当前的时间 ans = arr[i].c; break; &#125; &#125; if(res == n)cout &lt;&lt; ans &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; return 0;&#125; 五.游ne娃子的取石子游戏 题解:取三个最大的互质的数，得到的最小公倍数一定是最大的。如果n为奇数，三个最大的互质的数就是n, n - 1, n- 2。如果n为偶数， 需要判断一下n是否为3的倍数，如果不是，那么三个最大的互质的数就是n, n - 1, n - 3，如果是,那么三个最大的互质的数就是n - 1, n- 2， n - 3. 12345678910111213#include&lt;iostream&gt;using namespace std;int main()&#123; long long int n, ans; cin &gt;&gt; n; if(n % 2)cout &lt;&lt; n &lt;&lt; ' ' &lt;&lt; n - 1 &lt;&lt; ' ' &lt;&lt; n - 2 &lt;&lt; endl; else &#123; if(n % 3)cout &lt;&lt; n &lt;&lt; ' ' &lt;&lt; n - 1 &lt;&lt; ' ' &lt;&lt; n - 3 &lt;&lt; endl; else cout &lt;&lt; n - 1 &lt;&lt; ' ' &lt;&lt; n - 2 &lt;&lt; ' ' &lt;&lt; n - 3 &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://zhumenger.top/categories/题解/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://zhumenger.top/tags/题解/"}]},{"title":"图论之最短路问题","slug":"图论/最短路/图论之最短路问题","date":"2019-06-23T04:18:21.000Z","updated":"2019-07-09T06:14:17.387Z","comments":true,"path":"2019/06/23/图论/最短路/图论之最短路问题/","link":"","permalink":"http://zhumenger.top/2019/06/23/图论/最短路/图论之最短路问题/","excerpt":"","text":"图论之最短路问题1.什么是最短路： 从某顶点出发，沿图的边到达另一顶点所经过的路径中，各边上权值之和最小的一条路径 2.常用的最短路算法： Dijkstra算法，Bellman-Ford算法，Floyd算法和SPFA算法 3.最短路所有算法的适用情况以及时间复杂度，如下表所示。 算法详解一.Dijkstra算法1.朴素版的Dijkstra 简介： 每次找到已知的能够到达的一条最短的路径，并用这条路径更新它能够到达的所有的点，这样得到的路径一定是最短的，假设有n个点，那么我们就需要遍历n - 1次找到n - 1个边，每次用得到的最短的边依次更新其他可以到达的点。所以时间复杂度为O(n^2) 适用条件： 求单源最短路，并且所有的边都为正数。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1010, INF = 0x3f3f3f3f;int arr[N][N], n, m; //arr用来存边bool vis[N]; //判断边是否已经被选过int d[N]; //存储到每个点的距离void dijstra()&#123; d[1] = 0;//起点距离为1 for(int i = 0; i &lt;n - 1; i++)&#123; //遍历n - 1次，找到至少n -1 条边 int t = -1; for(int j = 1; j &lt;= n; j++)&#123; if(!vis[j] &amp;&amp; (t == -1 || d[t] &gt; d[j])) //找到已知的距离起点最短的一条路 t = j; &#125; for(int j = 1; j &lt;= n; j++) //用这条路径不断的更新到其他的点 d[j] = min(d[j], d[t] + arr[t][j]); //取最小值 vis[t] = true; //表示该点已经被选过了 &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; memset(arr, INF, sizeof arr); //初始化 memset(vis, false, sizeof vis); memset(d, INF, sizeof d); int a, b, c; for(int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; arr[a][b] = min(arr[a][b], c); //有可能给你多条相同的，所以要取最短的那条 &#125; dijstra(); if(d[n] == INF)cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; d[n] &lt;&lt; endl; return 0;&#125; 2.堆优化的Dijkstra： 主要是针对朴素版找到距离最小的一条路径用堆做了一个优化，我们可以用堆来储存已经更新过的点，每次取出堆中的最小的一条边即可，堆的时间复杂度为O(1)，所以在时间上要优化不少。 存图方式： 如果n和m非常大的话，比如1 &lt;= n, m &lt;= 1000000.用数组的方式肯定是存不下的，所以我们一般要用到邻接表的存图方式。也有很多人用vector动态数组来存，但当数据非常大时，vector动态数组开拓空间花费的时间也是非常大的，有的题就专门卡vector，所以邻接表最常用的一种存图方式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N = 1e5 + 10, INF = 0x3f3f3f3f;typedef pair&lt;int, int &gt; p;int h[N], e[N], ne[N], idx, w[N];//邻接表，由n个单链表组成，w[idx]用来存边权值int dis[N], n, m;bool vis[N];//判断这条边是否被选过void add(int a, int b, int c) //建图&#123; e[idx] = b, w[idx] = c, ne[idx]= h[a], h[a] = idx++;&#125;void dijstra()&#123; dis[1] = 0;//起点的距离为0 priority_queue&lt;p, vector&lt;p&gt;, greater&lt;p&gt; &gt; q; //优先队列 q.push(&#123;0, 1&#125;); while(q.size())&#123; p t = q.top(); q.pop(); int u = t.second, d = t.first; if(vis[u])continue; vis[u] = true; for(int i = h[u]; i != -1; i = ne[i])&#123;//遍历每一条边 int j = e[i]; if(dis[j] &gt; d + w[i])&#123;//不断更新为最短距离 dis[j] = d + w[i]; q.push(&#123;dis[j], j&#125;);//放入到队列中 &#125; &#125; &#125;&#125;int main()&#123; memset(dis, INF, sizeof dis);//初始化 memset(vis, false, sizeof vis); memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m; int a, b, c; while(m--)&#123; cin &gt;&gt; a&gt;&gt; b &gt;&gt; c; add(a, b, c); &#125; dijstra(); if(dis[n] == INF)cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; dis[n] &lt;&lt;endl; return 0;&#125; 二.bellman-ford算法简介： 循环n次，每次遍历所有的边，遍历的同时，不断更新a到b的最短距离即dis[b] = min(dis[b], backup[a] + w)，循环完一遍后，得到的所有路径一定满足dis[b] &lt;= dis[a] + w[i] 适用条件： 可以用来判断是否存在负边，时间复杂度为O(nm)，一般情况下不会用到这个算法，常用来求有边数限制的最短路问题，用结构体存储所有的边即可， 代码如下： 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10, INF = 0x3f3f3f3f;int n, m, k;int dis[N], backup[N];struct p&#123; //结构体存边 int a, b, c;&#125;arr[N];void bellman_ford()&#123; memset(dis, INF, sizeof dis); dis[1] = 0; for(int i = 0; i &lt; k; i++)&#123; //限制条件为k条边 memcpy(backup, dis, sizeof dis); //防止出现连锁反应，所以这里的用backup将上一次的最 //短路备份一下 for(int j = 0; j &lt; m; j++)&#123;//遍历所有的边 int a = arr[j].a, b = arr[j].b, w = arr[j].c; dis[b] = min(dis[b], backup[a] + w);//更新 &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 0; i &lt; m; i++) cin &gt;&gt; arr[i].a &gt;&gt; arr[i].b &gt;&gt; arr[i].c; bellman_ford(); if(dis[n] &gt; INF / 2)cout &lt;&lt; \"impossible\" &lt;&lt; endl; //有可能有负权边，所以要大于INF/2 else cout &lt;&lt; dis[n] &lt;&lt; endl; return 0;&#125; 三.spfa算法简介： spfa算法是对bellman-ford算法的一个优化，要想dis[b]变小，前提一定是dis[a]变小了，所以我们用队列来存储已经更新过的点，再用该点不断去更新其他的点，原理跟dijstra算法类似 如何判断负环 用一个变量cnt[i]表示到达 i 这个点的最短路径中经过了多少条边，如果cnt[i] &gt;= n表示有至少经过了n条边，那么就说明至少多走了一条边，那么这条边一定是一个负环。 适用条件： 用来求最短路以及判断是否存在负环，时间复杂度为O(m) 1.spaf算法求最短路 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N = 1e6 + 10, INF = 0x3f3f3f3f;int h[N], e[N], ne[N], w[N], idx;//邻接表存图int n, m;int dis[N];bool vis[N]; //vis含义跟dijstra算法中的不太一样，在这里表示当前这个点是否在队列当中void add(int a, int b, int c)//建边&#123; e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;&#125;void spfa()&#123; memset(dis, INF, sizeof dis); dis[1] = 0; //起点距离为0 queue&lt;int&gt; q; q.push(1); //将1放入队列 while(q.size())&#123; int u = q.front(); q.pop(); vis[u] = false; //表示u不在这个队列中 for(int i = h[u]; i != -1; i = ne[i])&#123; //遍历所有能够到达的点 int v = e[i]; if(dis[v] &gt; dis[u] + w[i])&#123; //更新距离 dis[v] = dis[u] + w[i]; if(!vis[v])&#123; //如果不在队列中 q.push(v); //放入队列 vis[v] = true;//表示v已经在队列当中 &#125; &#125; &#125; &#125;&#125;int main()&#123; memset(h, -1, sizeof h);//初始化 memset(vis, false, sizeof vis); cin &gt;&gt; n &gt;&gt; m; int a, b, c; while(m--)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); &#125; spfa(); if(dis[n] == INF)cout &lt;&lt; \"impossible\" &lt;&lt; endl; else cout &lt;&lt; dis[n] &lt;&lt; endl;&#125; 2.spfa判断是否存在负环 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N = 1e6 + 10, INF = 0x3f3f3f3f;int h[N], e[N], ne[N], w[N], idx;int dis[N], cnt[N]; //cnt[i]表示到达i这个点经过了多少条边bool vis[N];int n, m;void add(int a, int b, int c)&#123; e[idx] = b, w[idx]= c, ne[idx] = h[a], h[a] = idx++;&#125;bool spfa()&#123; queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i++)&#123;//因为不知道负环出现在哪一个起点，所以要将所有的点放入到队列中 vis[i] = true; q.push(i); &#125; while(q.size())&#123; int u = q.front(); q.pop(); vis[u] = false; for(int i = h[u]; i != -1; i = ne[i])&#123; int v = e[i]; if(dis[v] &gt; dis[u] + w[i])&#123; dis[v] = dis[u] +w[i]; cnt[v] = cnt[u] + 1; //边数+1 if(cnt[v] &gt;= n)return true; //如果大于n说明一定存在负环 if(!vis[v])&#123; q.push(v); vis[v] = true; &#125; &#125; &#125; &#125; return false;&#125;int main()&#123; memset(dis, INF, sizeof dis); memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m; int a, b, c; while(m--)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); &#125; if(spfa())puts(\"Yes\"); else puts(\"No\"); return 0;&#125; 四.floyd算法简介： 从任意节点A到任意节点B的最短路径不外乎2种可能，1是直接从A到B，2是从A经过若干个节点到B，所以，我们假设dist(AB)为节点A到节点B的最短路径的距离，对于每一个节点K，我们检查dist(AK) + dist(KB) &lt; dist(AB)是否成立，如果成立，证明从A到K再到B的路径比A直接到B的路径短，我们便设置 dist(AB) = dist(AK) + dist(KB)，这样一来，当我们遍历完所有节点K，dist(AB)中记录的便是A到B的最短路径的距离。 适用条件 能求出任意俩条边的最短路，时间复杂度为O(n^3) 代码如下： 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;const int N = 210, INF = 0x3f3f3f3f;int arr[N][N];int main()&#123; int n ,m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) arr[i][j] = i == j ? 0 : INF; //初始化 int a, b, c; for(int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; arr[a][b] = min(arr[a][b], c); &#125; //floyd算法核心 for(int k = 1; k &lt;= n; k++) for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) arr[i][j] = min(arr[i][j], arr[i][k] + arr[k][j]); while(k--)&#123; cin &gt;&gt; a &gt;&gt; b; if(arr[a][b] &gt; INF / 2)puts(\"impossible\");//可能有负环，所以这里是大于INF/2 else cout &lt;&lt; arr[a][b] &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://zhumenger.top/categories/图论/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://zhumenger.top/tags/图论/"},{"name":"最短路问题","slug":"最短路问题","permalink":"http://zhumenger.top/tags/最短路问题/"}]},{"title":"八数码(bfs)","slug":"搜索/八数码","date":"2019-06-21T13:22:10.000Z","updated":"2019-06-21T15:09:15.721Z","comments":true,"path":"2019/06/21/搜索/八数码/","link":"","permalink":"http://zhumenger.top/2019/06/21/搜索/八数码/","excerpt":"","text":"在一个3×3的网格中，1~8这8个数字和一个“X”恰好不重不漏地分布在这3×3的网格中。 例如： 1 2 3X 4 67 5 8 在游戏过程中，可以把“X”与其上、下、左、右四个方向之一的数字交换（如果存在）。 我们的目的是通过交换，使得网格变为如下排列（称为正确排列）： 1 2 34 5 67 8 X 例如，示例中图形就可以通过让“X”先后与右、下、右三个方向的数字交换成功得到正确排列。 交换过程如下： 1 2 3 1 2 3 1 2 3 1 2 3X 4 6 4 X 6 4 5 6 4 5 67 5 8 7 5 8 7 X 8 7 8 X 现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换。 输入格式输入占一行，将3×3的初始网格描绘出来。 例如，如果初始网格如下所示：1 2 3 x 4 6 7 5 8 则输入为：1 2 3 x 4 6 7 5 8 输出格式输出占一行，包含一个整数，表示最少交换次数。 如果不存在解决方案，则输出”-1”。 输入样例： 2 3 4 1 5 x 7 6 8 输出样例 19 题解：图的最短路问题，肯定要用到bfs, 可以将这个图转化为一个字符串,终点状态就是到达特定字符串”12345678x”，最先到达的一定是最短的 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;unordered_map&gt;using namespace std;unordered_map&lt;string, int &gt; d; //字符串哈希来表示到达该字串的距离string End, cur;int dx[] = &#123;0, 1, 0, -1&#125;;int dy[] = &#123;1, 0, -1, 0&#125;;int bfs()&#123; End = \"12345678x\"; d[cur] = 0; queue&lt;string &gt;q; q.push(cur); while(q.size())&#123; string u = q.front(); if(u == End)return d[u];//如果找到了，返回距离 int distance = d[u]; q.pop(); int x = u.find('x'); //在字符串里找到x int i = x / 3, j = x % 3; //得到x在图里的行和列 for(int k = 0; k &lt; 4; k++)&#123; //上下左右4个方向交换 int xx = i + dx[k]; int yy = j + dy[k]; if(xx &gt;= 0 &amp;&amp; xx &lt; 3 &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; 3)&#123; swap(u[x], u[xx * 3 + yy]);//交换 if(!d.count(u))&#123; //如果该字符串没有出现过，放入到队列中 d[u] = distance + 1; q.push(u); &#125; swap(u[x], u[xx * 3 + yy]); //恢复 &#125; &#125; &#125; return -1;&#125;int main()&#123; char ch; for(int i = 0; i &lt; 9; i++)&#123; cin &gt;&gt; ch; cur += ch; &#125; cout &lt;&lt; bfs() &lt;&lt; endl; return 0;&#125;","categories":[{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/categories/搜索/"}],"tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"dfs和bfs简介","slug":"搜索/dfs和bfs简介","date":"2019-06-15T16:03:24.000Z","updated":"2019-07-07T03:07:36.178Z","comments":true,"path":"2019/06/16/搜索/dfs和bfs简介/","link":"","permalink":"http://zhumenger.top/2019/06/16/搜索/dfs和bfs简介/","excerpt":"","text":"dfs和bfs简介一.深度优先遍历(dfs)本质： 通过递归的方式遍历图中的每一个点。 遍历流程： 从起点开始，在其一条分支上一条路走到黑，走不通了就开始往回走，只要当前有分支就继续往下走，直到将所有的点遍历一遍。 剪枝： 如果已经确定这条路没有我们想要的答案，那么就不用继续在这条路上走下去了，于是我们就开始走其他的分支或者往回走，这样节省时间的方法称之为剪枝。 回溯： 当我们一条路走到头，往回走时，就叫做回溯。 恢复现场： 当我们回溯的时候，原来这个图是什么样的，我们还要变回什么样。这是一个好习惯，我们用了什么东西，就需要还回什么东西。这样做的目的： 当我们遍历完这条分支，去遍历下一条分支的时候，我们需要保证当前图其他条件的一致性，也就是遍历每一条分支的时候，当前图的状态都是一样的。保证遍历每一条分支的时候都是公平的。 下面是流程图： 二.广度优先遍历(bfs)遍历流程： 逐层逐层的遍历，先遍历第一层，再遍历第二层…，也就是遍历当前节点所能到达的所有子节点。直到遍历所有的点。不存在剪枝，回溯和恢复现场的操作。 流程图如下： 三.对比dfs和bfs时间复杂度： dfs: 因为我们需要枚举没一个点，以及每一条边，所示它的时间复杂度为O(n + e) 即点的个数+边的个数 bfs:跟dfs时间复杂度一样，都为O(n + e) 不同的是对每个点的访问顺序是不一样的 用到的数据结构： dfs: stack bfs: queue 空间复杂度： dfs: O(h) h为树的深度 bfs: O(2^h) 特性： dfs: 不具有最短性 bfs: 具有最短性","categories":[{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/categories/搜索/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"},{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"有向图的拓扑排序(bfs)","slug":"搜索/有向图的拓扑排序","date":"2019-06-15T01:20:57.000Z","updated":"2019-07-30T04:39:16.725Z","comments":true,"path":"2019/06/15/搜索/有向图的拓扑排序/","link":"","permalink":"http://zhumenger.top/2019/06/15/搜索/有向图的拓扑排序/","excerpt":"","text":"题目描述 给定一个n个点m条边的有向图，图中可能存在重边和自环。 请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出-1。 若一个由图中所有点构成的序列A满足：对于图中的每条边(x, y)，x在A中都出现在y之前，则称A是该图的一个拓扑序列。 输入格式 第一行包含两个整数n和m 接下来m行，每行包含两个整数x和y，表示点x和点y之间存在一条有向边(x, y)。 输出格式 共一行，如果存在拓扑序列，则输出拓扑序列。 否则输出-1。 数据范围 1≤n,m≤10^5, 1≤n,m≤10^5 输入样例： 3 31 22 31 3 输出样例： 1 2 3 拓扑序列简介： 若一个由图中所有点构成的序列A满足：对于图中的每条边(x, y)，x在A中都出现在y之前，则称A是该图的一个拓扑序列。范围是有向图， 无向图是没有拓扑排序的。 入度： 有多少个点指向该元素，就表示该元素的入度是多少。 初出度： 该元素指向了多少个点，就表示该元素的出度是多少、 拓扑序列的起点： ​ 因为入度为0的点，没有其他的点指向它，所以它一定是一个起点，如果入度为0的点有多个，那么该拓扑序列不唯一，如果没有入度为0的点，也就是这个图是一个环，那么它没有拓扑排序。所以我们要求拓扑序列，那么该图一定是一个有向无环图 如何求拓扑序列： ​ 将入度为0的点加入队列当中，每次从入度为0的点开始遍历它的每一个子节点，不断删去前一个点，并且该节点的入度–，如果入度为0,则加入队列当中，在删去节点的同时用一个数组来存储该拓扑排序的顺序，最后输出答案即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int h[N], e[N], ne[N], idx;//邻接表int d[N], n ,m;//入度vector&lt;int &gt; ans;void add(int a, int b)//邻接表建图&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;int bfs()&#123; queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i++) if(!d[i])q.push(i); //将入度为0的点入队 while(q.size())&#123; int u = q.front(); q.pop(); ans.push_back(u); //储存该拓扑排序 for(int i = h[u]; i != -1; i = ne[i])&#123; int s = e[i]; d[s]--; if(!d[s])q.push(s); &#125; &#125; return (ans.size() == n); //判断是否所有的点都已经入队&#125;int main()&#123; int a, b; memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; a &gt;&gt; b; add(a, b); d[b]++; //入度++ &#125; if(bfs())&#123; for(int i = 0; i &lt; ans.size(); i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; cout &lt;&lt; endl; &#125; else cout &lt;&lt; -1 &lt;&lt; endl; return 0;&#125;","categories":[{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/categories/搜索/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"树与图的广度优先遍历(bfs)","slug":"搜索/树与图的广度优先遍历","date":"2019-06-15T01:11:29.000Z","updated":"2019-06-15T01:19:40.832Z","comments":true,"path":"2019/06/15/搜索/树与图的广度优先遍历/","link":"","permalink":"http://zhumenger.top/2019/06/15/搜索/树与图的广度优先遍历/","excerpt":"","text":"题目描述 给定一个n个点m条边的有向图，图中可能存在重边和自环。 所有边的长度都是1，点的编号为1~n。 请你求出1号点到n号点的最短距离，如果从1号点无法走到n号点，输出-1。 输入格式 第一行包含两个整数n和m。 接下来m行，每行包含两个整数a和b，表示存在一条从a走到b的长度为1的边。 输出格式 输出一个整数，表示1号点到n号点的最短距离。 数据范围 1≤n,m≤10^5, 1≤n,m≤10^5 输入样例： 4 51 22 33 41 31 4 输出样例： 1 题解： 找图的最短路，所以用到的一定是bfs,首先将起点入队，然后不断的弹出队列元素，让该元素的所有没有走过的叶子节点的距离+1, 然后让子节点入队，直到弹出队首元素为n，这样最先得到的距离一定是最短的。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 +10;int e[N], h[N], ne[N], idx;int d[N], n, m;queue&lt;int&gt; q;void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;void bfs()&#123; d[1] = 0; q.push(1); while(q.size())&#123; int u = q.front(); q.pop(); if(u == n)break; for(int i = h[u]; i != -1; i = ne[i])&#123; int s = e[i]; if(d[s] == -1)&#123; d[s] = d[u] + 1; q.push(s); &#125; &#125; &#125;&#125;int main()&#123; int a, b; memset(d, -1, sizeof d); memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; a &gt;&gt; b; add(a, b); &#125; bfs(); cout &lt;&lt; d[n] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/categories/搜索/"}],"tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"迷宫问题(bfs)","slug":"搜索/迷宫问题","date":"2019-06-14T15:37:25.000Z","updated":"2019-06-14T16:10:56.581Z","comments":true,"path":"2019/06/14/搜索/迷宫问题/","link":"","permalink":"http://zhumenger.top/2019/06/14/搜索/迷宫问题/","excerpt":"","text":"题目描述给定一个n*m的二维整数数组，用来表示一个迷宫，数组中只包含0或1，其中0表示可以走的路，1表示不可通过的墙壁。 最初，有一个人位于左上角(1, 1)处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。 请问，该人从左上角移动至右下角(n, m)处，至少需要移动多少次。 数据保证(1, 1)处和(n, m)处的数字为0，且一定至少存在一条通路。 输入格式 第一行包含两个整数n和m。 接下来n行，每行包含m个整数（0或1），表示完整的二维数组迷宫。 输出格式 输出一个整数，表示从左上角移动至右下角的最少移动次数。 数据范围 1≤n,m≤1001≤n,m≤100 输入样例： 5 50 1 0 0 00 1 0 1 00 0 0 0 00 1 1 1 00 0 0 1 0 输出样例： 8 题解： 经典的bfs问题：bfs有最短路的性质，如果每条边的边权值都是1的话，bfs最先遍历到的点离起点的距离一定是最短的，所以我们可以用bfs来做这道题，用队列的方法是bfs的主要特征。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int N = 1000, INF = 0x3f3f3f3f;int a[N][N], d[N][N]; //a数组用来存图， d数组表示距离int dx[] = &#123;0, 1, 0, -1&#125;;//往上下左右4个方向遍历int dy[] = &#123;1, 0, -1, 0&#125;; int n ,m;typedef pair&lt;int ,int &gt;P;queue&lt;P&gt; q;void bfs()&#123; memset(d, INF, sizeof d); //将开始的距离都初始化为最大值， d[1][1] = 0; //起点的距离为0 q.push(&#123;1, 1&#125;); while(q.size())&#123; P cur = q.front(); q.pop(); if(cur.first == n &amp;&amp; cur.second == m)&#123; cout &lt;&lt; d[n][m] &lt;&lt; endl; break; &#125; //4个方向遍历 for(int i = 0; i &lt; 4; i++)&#123; int x = cur.first + dx[i]; int y = cur.second + dy[i]; if(x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m &amp;&amp; d[x][y] == INF &amp;&amp; a[x][y] == 0)&#123;//x，y一定是合法的 &amp;&amp; 判断这条路是否可通 &amp;&amp; 判断这条路是否已经走过了 d[x][y] = d[cur.first][cur.second] +1; //距离+1 q.push(&#123;x, y&#125;);//放入到队列中 &#125; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) cin &gt;&gt; a[i][j]; bfs(); return 0;&#125;","categories":[{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/categories/搜索/"}],"tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"n-皇后问题(dfs)","slug":"搜索/n-皇后问题","date":"2019-06-14T15:25:28.000Z","updated":"2019-07-07T03:07:50.225Z","comments":true,"path":"2019/06/14/搜索/n-皇后问题/","link":"","permalink":"http://zhumenger.top/2019/06/14/搜索/n-皇后问题/","excerpt":"","text":"题目描述n-皇后问题是指将 n 个皇后放在 n∗n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。 现在给定整数n，请你输出所有的满足条件的棋子摆法。 输入格式 共一行，包含整数n。 输出格式 每个解决方案占n行，每行输出一个长度为n的字符串，用来表示完整的棋盘状态。其中”.”表示某一个位置的方格状态为空，”Q”表示某一个位置的方格上摆着皇后。每个方案输出完成后，输出一个空行。 数据范围 1≤n≤9 输入样例： 4 输出样例： .Q..…QQ…..Q. ..Q.Q……Q.Q.. 题解：经典的n皇后问题:dfs深搜每一行，用col[J]， dg[J], udg[J]数组分别来标记第J列， 正对角线， 反对角线是否有皇后，如果有我们就剪掉， 否则就把皇后放到该位置。代码如下： 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;const int N = 20;int arr[N][N], col[N], dg[N], udg[N], n; void dfs(int cur)&#123; if(cur == n)&#123; //如果放了n个皇后，直接输出 for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(arr[i][j])cout &lt;&lt; 'Q'; else cout &lt;&lt; '.'; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl; return ; &#125; for(int i = 0; i &lt; n; i++)&#123; if(col[i] || dg[cur + i] ||udg[n - cur + i])continue; //如果有了皇后，剪枝 arr[cur][i] = col[i] = dg[cur + i] = udg[n - cur + i] = 1; dfs(cur + 1); arr[cur][i] = col[i] = dg[cur + i] = udg[n - cur + i] = 0; //恢复现场 &#125;&#125;int main()&#123; cin &gt;&gt; n; dfs(0); return 0;&#125;","categories":[{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/categories/搜索/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"树的重心(dfs)","slug":"搜索/树的重心","date":"2019-06-14T09:50:40.000Z","updated":"2019-06-14T13:31:40.286Z","comments":true,"path":"2019/06/14/搜索/树的重心/","link":"","permalink":"http://zhumenger.top/2019/06/14/搜索/树的重心/","excerpt":"","text":"题目描述 给定一颗树，树中包含n个结点（编号1~n）和n-1条无向边。请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。 输入格式 第一行包含整数n，表示树的结点数。接下来n-1行，每行包含两个整数a和b，表示点a和点b之前存在一条边。 输出格式 输出一个整数m，表示重心的所有的子树中最大的子树的结点数目。 数据范围 1≤n≤105 输入样例 91 21 71 42 82 54 33 94 6 输出样例： 4 解题思路：这道题就是树的深度优先遍历，我们只需套用模板，遍历每个点的同时，返回该子树的点的个数，以及计算去掉该点时连通块点的最大值即可，最后用ans取去掉每个点之后的最大联通块的最小值就是最后的答案。具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int h[N], e[N], ne[N], idx, n;int ans = N; //答案bool vis[N]; //判断是否遍历过void add(int a, int b) //邻接表存树与图&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;int dfs(int cur)&#123; vis[cur] = true; int res = 0, sum = 1; //res表示去掉cur这个节点，联通块点的最大值， sum表示该子树点的个数 for(int i = h[cur]; i != -1; i = ne[i])&#123; //遍历树 int u = e[i]; if(!vis[u])&#123; int s = dfs(u); res = max(res, s); sum += s; &#125; &#125; res = max(res, n - sum); // sum是该子树的点的个数， n - sum表示它的父节点所连接的联通块点的个数 ans = min(res, ans); //取最大连通块点的最小值 return sum;&#125;int main()&#123; int a, b; cin &gt;&gt; n; //初始化 memset(h, -1, sizeof h); memset(vis, false, sizeof vis); for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; a &gt;&gt; b; //建树，双向图 add(a, b); add(b, a); &#125; dfs(1); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/categories/搜索/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"树与图的深度优先遍历(dfs)","slug":"搜索/树与图的深度优先遍历","date":"2019-06-14T09:47:20.000Z","updated":"2019-07-07T03:08:27.865Z","comments":true,"path":"2019/06/14/搜索/树与图的深度优先遍历/","link":"","permalink":"http://zhumenger.top/2019/06/14/搜索/树与图的深度优先遍历/","excerpt":"","text":"树与图的深度优先遍历:树其实也是图的一种图: 分为有向图和无向图图的储存: 第一种：邻接矩阵，就是一个二维数组，缺点：当点和边特别多的时候，存不下，一般用的比较少，而且非常浪费空间第二种：邻接表:由n个单链表组成，也可以用vector动态数组来实现，但vector有很大的缺点，当点和边非常大时，用vector动态数组的方法很容易超时，所以我们常用n个但链表的方式来存储图 邻接表如何存图呢：假设有这样一个图:那么我们可以给每个节点开一个单链表，如下图所示：这样我们就把图用邻接表的方法存了下来树与图深度优先遍历的大致流程：一条路走到黑，直到撞到南墙，走不通了，然后往回走，只要有分支就继续往下走，示例图如下: 树与图的遍历模板： 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int h[N], e[N], ne[N], idx, n;//这里跟单链表一样，只不过这里是N个头节点，H[N]bool vis[N]; //判断是否遍历过void add(int a, int b) //邻接表存树与图&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;void dfs(int cur)&#123; vis[cur] = true; for(int i = h[cur]; i != -1; i = ne[i])&#123; //遍历树 int u = e[i]; if(!vis[u])&#123; dfs(u); &#125; &#125;&#125;int main()&#123; int a, b; cin &gt;&gt; n; //初始化 memset(h, -1, sizeof h); memset(vis, false, sizeof vis); for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; a &gt;&gt; b; //建树，双向图 add(a, b); add(b, a); &#125; dfs(1); return 0;&#125; 这样我们就遍历了每个点。","categories":[{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/categories/搜索/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"字符串哈希","slug":"数据结构基础/字符串哈希","date":"2019-06-13T01:45:46.000Z","updated":"2019-06-14T15:51:18.497Z","comments":true,"path":"2019/06/13/数据结构基础/字符串哈希/","link":"","permalink":"http://zhumenger.top/2019/06/13/数据结构基础/字符串哈希/","excerpt":"","text":"字符串哈希：简介：为了方便的找到某个字符串，我们可以把该字符串转化为一个数值，每一个字符串都有一个唯一确定的编号，这样在绝大多数情况下可以在O(1)的时间复杂度中完成对字符串元素的查找 字符串哈希函数：为每一个字符串赋予唯一确定的数值或编号。 题目描述 给定一个长度为n的字符串，再给定m个询问，每个询问包含四个整数l1,r1,l2,r2l1,r1,l2,r2，请你判断[l1,r1l1,r1]和[l2,r2l2,r2]这两个区间所包含的字符串子串是否完全相同。 字符串中只包含大小写英文字母和数字。 输入格式 第一行包含整数n和m，表示字符串长度和询问次数。 第二行包含一个长度为n的字符串，字符串中只包含大小写英文字母和数字。 接下来m行，每行包含四个整数l1,r1,l2,r2l1,r1,l2,r2，表示一次询问所涉及的两个区间。 注意，字符串的位置从1开始编号。 输出格式 对于每个询问输出一个结果，如果两个字符串子串完全相同则输出“Yes”，否则输出“No”。 每个结果占一行。 数据范围 1≤n,m≤1051≤n,m≤105 输入样例： 8 3aabbaabb1 3 5 71 3 6 81 2 1 2 输出样例： YesNoYes 代码如下： 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef unsigned long long ULL;const int N = 1e6 + 10, base = 131;ULL h[N], p[N];char s[N];ULL solve(int l, int r)&#123; return h[r] - h[l - 1] * p[r - l + 1];&#125;int main()&#123; int n, m; int a, b, c, d; cin &gt;&gt; n &gt;&gt; m; cin &gt;&gt; (s + 1); p[0] = 1; for(int i = 1; i &lt;= n; i++) &#123; h[i] = h[i - 1] * base + s[i] - 'a' + 1; p[i] = p[i - 1] * base; &#125; while(m--)&#123; cin &gt;&gt; a&gt;&gt; b &gt;&gt; c &gt;&gt; d; if(solve(a, b) == solve(c, d))cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"字符串哈希","slug":"字符串哈希","permalink":"http://zhumenger.top/tags/字符串哈希/"}]},{"title":"哈希表(散列表)","slug":"数据结构基础/哈希表-散列表","date":"2019-06-11T16:08:08.000Z","updated":"2019-06-13T03:21:42.542Z","comments":true,"path":"2019/06/12/数据结构基础/哈希表-散列表/","link":"","permalink":"http://zhumenger.top/2019/06/12/数据结构基础/哈希表-散列表/","excerpt":"","text":"简介：哈希表又称为散列表，是实现字典操作的一种有效的数据结构。通过哈希函数将关键字映射到表中的某个位置上进行存放，以实现快速插入和查询的。时间复杂度可达到O(n).为什么要用到哈希：比如说有n(1&lt;=n&lt;=1e6)个数,当给你一个非常大的数时，为了方便查找这个数是否出现过，我们可以给这个数重新编号到1~n，这样我们就可以快速的找到想要的答案。 题目描述 维护一个集合，支持如下几种操作：“I x”，插入一个数x；“Q x”，询问数x是否在集合中出现过；现在要进行N次操作，对于每个询问操作输出对应的结果。 输入格式 第一行包含整数N，表示操作数量。接下来N行，每行包含一个操作指令，操作指令为”I x”，”Q x”中的一种。 输出格式 对于每个询问指令“Q x”，输出一个询问结果，如果x在集合中出现过，则输出“Yes”，否则输出“No”。每个结果占一行。 数据范围 1≤N≤105−109≤x≤109 输入样例： 5I 1I 2I 3Q 2Q 5 输出样例： YesNo 题解： 拉链法： ​ 先找出编号的数据范围MOD，最好是一个质数，这样冲突的几率是最小的，让输入的数字x%mod，这样就可以让x重新编号到0~mod - 1， 有的时候我们得到的余数是一样的，我们可以以这个余数为head， 把这些余数相同的储存到一个链表当中，具体代码如下： 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10, mod = 100003;int h[N], e[N], ne[N], idx = 1;void insert(int x)&#123; int k = (x % mod + mod) % mod; //得到余数head e[idx] = x, ne[idx] = h[k], h[k] = idx++;//在以head为头结点的链表中插入数值&#125;bool Find(int x)&#123; int k = (x % mod + mod) % mod; for(int i = h[k]; i != -1; i = ne[i]) //在以head为头结点的链表中查找x if(e[i] == x)return true; return false;&#125;int main()&#123; int n, x; string s; memset(h, -1, sizeof h); cin &gt;&gt; n; while(n--)&#123; cin &gt;&gt; s &gt;&gt;x; if(s == \"I\")&#123; insert(x); &#125; else &#123; if(Find(x))cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; &#125; return 0;&#125; 开放寻址法： ​ 这种方法也是先让x对mod取模， 得到x应该去到哪个坑里，如果这个坑已经被占了，就继续往下遍历直到寻找到一个没有人的坑位，数据范围往往开到n的俩到三倍。 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 200003, Max = 0x3f3f3f3f;int h[N];int Find(int x)&#123; int k = (x % N + N) % N; //取模 while(h[k] != Max &amp;&amp; h[k] != x)&#123; //找到一个没有人的坑位 k++; if(k == N)k = 0; //如果到头了，就从0重新开始遍历，因为一共就只有n个数，所以肯定有剩余的 //坑位供x使用 &#125; return k; //返回坑位的下标&#125;int main()&#123; int n, x; string s; cin &gt;&gt; n; memset(h, Max, sizeof h);//初始化，开始的时候都没有人 while(n--)&#123; cin &gt;&gt; s &gt;&gt; x; if(s == \"I\")&#123; int k = Find(x); h[k] = x; //把x放到该坑位 &#125; else &#123; int k = Find(x); if(h[k] != Max)cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"哈希","slug":"哈希","permalink":"http://zhumenger.top/tags/哈希/"}]},{"title":"最大异或对","slug":"数据结构基础/最大异或对","date":"2019-06-11T03:37:08.000Z","updated":"2019-06-11T03:45:19.192Z","comments":true,"path":"2019/06/11/数据结构基础/最大异或对/","link":"","permalink":"http://zhumenger.top/2019/06/11/数据结构基础/最大异或对/","excerpt":"","text":"Acwing-&gt;143.最大异或对 题目描述在给定的N个整数A1，A2……AN中选出两个进行xor（异或）运算，得到的结果最大是多少？ 输入格式 第一行输入一个整数N。第二行输入N个整数A1～AN。 输出格式 输出一个整数表示答案。 数据范围 1≤N≤105,0≤Ai&lt;231 输入样例： 31 2 3 输出样例： 3题解：异或+前缀+字典树其实来说,一个整数,是可以转化成为一个32位的二进制数,而也就可以变成长度为32位的二进制字符串.既然如此话,那么我们可以这么做,每一次检索的时候,我们都走与当前Ai的二进制位的数值相反的位置走,这样就可以让Xor值最大,如果说没有路可以走的话,那么就走相同的路.时间复杂度：位数*n，所以是O(32 * n) 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int a[N], trie[N * 32][5], idx;void insert(int x) //建树&#123; int p = 1; for(int i = 30; i &gt;= 0; i--)&#123; int u = x &gt;&gt; i &amp; 1; if(!trie[p][u])trie[p][u] = idx++; p = trie[p][u]; &#125;&#125;int search(int x)//找最大的&#123; int p = 1, ans = 0; for(int i = 30; i &gt;= 0; i--)&#123; int u = x &gt;&gt; i &amp;1; if(trie[p][u^1])&#123; p = trie[p][u^1]; ans +=(1 &lt;&lt; i); &#125; else p = trie[p][u]; &#125; return ans;&#125;int main()&#123; int n; cin &gt;&gt; n; idx =2; for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; a[i]; insert(a[i]); &#125; int res = 0; for(int i = 0; i &lt; n; i++)res = max(res, search(a[i])); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"Trie","slug":"Trie","permalink":"http://zhumenger.top/tags/Trie/"}]},{"title":"Trie-字典树","slug":"数据结构基础/Trie-字典树","date":"2019-06-11T00:57:01.000Z","updated":"2019-06-23T08:24:31.227Z","comments":true,"path":"2019/06/11/数据结构基础/Trie-字典树/","link":"","permalink":"http://zhumenger.top/2019/06/11/数据结构基础/Trie-字典树/","excerpt":"","text":"Trie(字典树): 一种用于实现字符串快速检索的多叉树结构 Trie插入： 当需要插入一个字符串s时，我们令一个指针P起始指向根节点。然后，依次扫描S中的每个字符c：若P的c字符指针指向一个已经存在的节点Q，则令P = Q。若P的c字符指针指向空，则新建一个节点Q，令P的c字符指针指向Q，然后令P = Q。当S中的字符扫描完毕时，在当前节点P上标记它是一个字符串的结尾。 检索： 当需要检索一个字符串S在Trie中是否存在时，我们令一个指针P起初指向根节点，然后依次扫描S中的每个字符c：若P的c字符指针指向空，则说明S没有被插入过Trie，结束检索。若P的c字符指针指向一个已经存在的节点Q，则令P = Q。当S中的字符扫描完毕时，若当前节点P被标记为一个字符串的结尾，则说明S在Trie中存在，否则说明S没有被插入过Trie。 问题描述 “I x”向集合中插入一个字符串x；“Q x”询问一个字符串在集合中出现了多少次。共有N个操作，输入的字符串总长度不超过 105，字符串仅包含小写英文字母。 输入格式 第一行包含整数N，表示操作数。接下来N行，每行包含一个操作指令，指令为”I x”或”Q x”中的一种。 输出格式 对于每个询问指令”Q x”，都要输出一个整数作为结果，表示x在集合中出现的次数。每个结果占一行。 数据范围 1≤N≤2∗104 输入样例： 5I abcQ abcQ abI abQ ab 输出样例： 101 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int trie[N][26], cnt[N], idx;char str[N], c;void insert(char *str)&#123; int len = strlen(str), p = 1; //从根节点开始 for(int i = 0; i &lt; len; i++)&#123; int u = str[i] - 'a'; if(!trie[p][u])//如果没有节点，便创造一个节点 trie[p][u] = idx++; //对每个字符串进行编号 p = trie[p][u]; //p等于该节点，继续往下遍历 &#125; cnt[p]++;// 统计编号为p的字符串的个数&#125;int search(char *str)&#123; int len = strlen(str), p = 1; for(int i = 0; i &lt; len; i++)&#123; int u = str[i] - 'a'; if(!trie[p][u])return 0; //如果该节点为空，说明该字符串没有出现 p = trie[p][u]; &#125; return cnt[p];&#125;int main()&#123; int n; cin &gt;&gt; n; idx = 1; while(n--)&#123; cin &gt;&gt; c &gt;&gt; str; if(c == 'I')insert(str); else cout &lt;&lt; search(str) &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"Trie","slug":"Trie","permalink":"http://zhumenger.top/tags/Trie/"}]},{"title":"单链表","slug":"数据结构基础/单链表","date":"2019-06-10T14:32:06.000Z","updated":"2019-06-10T14:33:06.797Z","comments":true,"path":"2019/06/10/数据结构基础/单链表/","link":"","permalink":"http://zhumenger.top/2019/06/10/数据结构基础/单链表/","excerpt":"","text":"题目描述实现一个单链表，链表初始为空，支持三种操作： (1) 向链表头插入一个数； (2) 删除第k个插入的数后面的数； (3) 在第k个插入的数后插入一个数 现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。 注意:题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。 输入格式 第一行包含整数M，表示操作次数。接下来M行，每行包含一个操作命令，操作命令可能为以下几种：(1) “H x”，表示向链表头插入一个数x。(2) “D k”，表示删除第k个输入的数后面的数（当k为0时，表示删除头结点）。(3) “I k x”，表示在第k个输入的数后面插入一个数x（此操作中k均大于0）。 输出格式 共一行，将整个链表从头到尾输出。 数据范围 1≤M≤100000所有操作保证合法。 输入样例： 10H 9I 1 1D 1D 0H 6I 3 6I 4 5I 4 5I 3 4D 6 输出样例： 6 4 6 5 1.单链表的简单介绍 单链表是一种链式存取的数据结构，用一组任意地址空间（地址空间即存储单元）来存放线性表的数据元素。单链表中的数据是以节点的形式来表示，而节点是用结构体来描述，每个节点都是由元素和指针构成，即该结构体中包含两个成员变量：存放元素的成员变量和存放下一个节点地址的成员变量。 2.顺序表与链表的区别 顺序表的特点为：逻辑相邻的两节点其物理地址也是相邻的；链表的特点为：逻辑相邻的两节点其物理地址不相邻。顺序表的存储方式是：节点元素连续存放在存储单元；链表的存储方式是：节点元素随机存放在存储单元。 链表的插入和删除操作：代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int head; //表示头结点int idx; //表示当前是第几个数int e[N]; //表示第i个数所存储的值int ne[N]; //i的下一个节点void init()&#123; head = -1; //初始化 idx = 0; //下标从0开始&#125;//插入到头结点//1.先用e[idx]存储该值//2.将ne[idx]即第idx个数的下一个节点指向头结点//3.头结点head更新为idx;//4.idx++;void add_to_head(int x)&#123; e[idx] = x, ne[idx] = head, head = idx, idx++; &#125;// 将x插入到第k个数的后面//1.先用e[idx]存储该值x//2.将ne[idx]即第idx个数的下一个节点指向第k个数的下一个节点//3.将ne[k]指向idx;//4.idx++;void add(int k, int x)&#123; e[idx] = x, ne[idx] = ne[k], ne[k] = idx, idx++;&#125;//删除第k个数后面的数//直接让ne[k] = ne[ne[k]]即可void move(int k)&#123; ne[k] = ne[ne[k]];&#125;int main()&#123; int t; init(); cin &gt;&gt; t; while(t--)&#123; char c; int k, x; cin &gt;&gt; c; if(c == 'H')&#123; cin &gt;&gt; x; add_to_head(x); &#125; else if(c == 'D')&#123; cin &gt;&gt; k; if(!k)head = ne[head]; //如果k == 0, 要删除头结点，即让head等于下一个节点 else move(k - 1); &#125; else if(c == 'I')&#123; cin &gt;&gt; k &gt;&gt; x; add(k - 1, x); &#125; &#125; for(int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; ' ' ; cout &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"单链表","slug":"单链表","permalink":"http://zhumenger.top/tags/单链表/"}]},{"title":"直方图中最大的矩形（单调栈2）","slug":"数据结构基础/直方图中最大的矩形（单调栈2）","date":"2019-06-10T14:16:22.000Z","updated":"2019-07-27T03:45:03.023Z","comments":true,"path":"2019/06/10/数据结构基础/直方图中最大的矩形（单调栈2）/","link":"","permalink":"http://zhumenger.top/2019/06/10/数据结构基础/直方图中最大的矩形（单调栈2）/","excerpt":"","text":"题目描述直方图是由在公共基线处对齐的一系列矩形组成的多边形。 矩形具有相等的宽度，但可以具有不同的高度。 例如，图例左侧显示了由高度为2,1,4,5,1,3,3的矩形组成的直方图，矩形的宽度都为1:通常，直方图用于表示离散分布，例如，文本中字符的频率。 现在，请你计算在公共基线处对齐的直方图中最大矩形的面积。 图例右图显示了所描绘直方图的最大对齐矩形。 输入格式 输入包含几个测试用例。每个测试用例占据一行，用以描述一个直方图，并以整数n开始，表示组成直方图的矩形数目。然后跟随n个整数h1，…，hn。这些数字以从左到右的顺序表示直方图的各个矩形的高度。每个矩形的宽度为1。同行数字用空格隔开。当输入用例为n=0时，结束输入，且该用例不用考虑。 输出格式 对于每一个测试用例，输出一个整数，代表指定直方图中最大矩形的区域面积。每个数据占一行。请注意，此矩形必须在公共基线处对齐。 数据范围 1≤n≤100000,0≤hi≤1000000000 输入样例： 7 2 1 4 5 1 3 34 1000 1000 1000 10000 输出样例： 84000 题解：以H[ i ]为高的矩形向左右扩展，找到能够到达的最远距离，即找到左右边界第一个小于H[ i ]的位置， 实际上就是一道单调栈的问题，用一个栈来维护一个单调递增的序列，如果栈中的某个元素比当前的数值的小，那么该元素之后的元素肯定是用不到了，所以就可以直接丢出栈， 并将该值加入栈中，遍历一遍，用ans记录最大值即可 代码如下: 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e5 + 10;int q[N], l[N], r[N], a[N], t;int n;void get(int *l)&#123; t = 0; a[0] = -1; q[0] = 0; for(int i = 1; i &lt;= n; i++)&#123; while(a[i] &lt;= a[q[t]])t--; l[i] = q[t] + 1; q[++t] = i; &#125;&#125;int main()&#123; while(cin &gt;&gt; n &amp;&amp; n)&#123; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; get(l); reverse(a + 1, a + 1 + n); get(r); reverse(a + 1, a + 1 + n); long long int ans = 0; for(int i = 1; i &lt;= n; i++)&#123; ans = max(ans, (long long)a[i] * (n - r[n - i + 1] +1 - l[i] + 1)); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"栈","slug":"栈","permalink":"http://zhumenger.top/tags/栈/"},{"name":"单调栈","slug":"单调栈","permalink":"http://zhumenger.top/tags/单调栈/"}]},{"title":"堆","slug":"数据结构基础/堆","date":"2019-06-10T11:07:00.000Z","updated":"2019-06-10T14:24:17.724Z","comments":true,"path":"2019/06/10/数据结构基础/堆/","link":"","permalink":"http://zhumenger.top/2019/06/10/数据结构基础/堆/","excerpt":"","text":"堆：一种支持插入，删除，查询最值的数据结构，是一颗完全二叉树，实际上就是一个优先队列priority_queue,这里我们用数组的实现这个堆大根堆：树中的任意一个节点的权值都小于等于其父节点小根堆：树中的任意一个节点的权值都大于等于其父节点如何实现堆：直接用一个数组来保存二叉堆， 逐层的从左到右依次编号，将此编号作为节点在数组中存储的位置。所以，父亲点编号等于子节点编号除以2，左子节点编号等于父节点编号乘以2，又子节点等于父节点编号乘2加1 堆的基本操作：1求集合中的最小值：h[ 1 ]2.插入一个数：h[++n] = x;up(n); //up函数将x向上调整，找到x的位置，保证堆的有序性3.删除最小值：h[1] = h[n–];down(1) //down函数，将x向下调整，找到x的位置，保证堆的有序性4.删除任意一个元素：h[x] = h[n–];down(x);up(x);//因为不确定x的大小，所以可能是向上调整，也可能是向下调整，这俩个函数虽然都写上了，但实际上只会执行一个，5.修改任意一个元素：h[k] = x;down(k);up(k)//跟4同理时间复杂度：与堆的高度有关，所以是O（logN）代码如下： 题目描述 输入一个长度为n的整数数列，从小到大输出前m小的数。 输入格式 第一行包含整数n和m。第二行包含n个整数，表示整数数列。 输出格式 共一行，包含m个整数，表示整数数列中前m小的数。 数据范围 1≤m≤n≤105，1≤数列中元素≤109 输入样例： 5 34 5 1 3 2 输出样例： 1 2 3 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int h[N], n ,m;void down(int p) //向上调整&#123; int s = 2 * p; //子节点 while(s &lt;= n)&#123; if(s &lt; n &amp;&amp; h[s] &gt; h[s + 1])s++; //找到左右子节点的最小值 if(h[s] &lt; h[p])&#123; //如果子节点比父节点小 swap(h[s], h[p]); //则交换 p = s; //继续向下调整 s = 2 * p; &#125; else break; &#125;&#125;void up(int p) //向上调整，&#123; while(p &gt; 1)&#123; if(h[p] &lt; h[p / 2])&#123; //如果子节点小于父节点 swap(h[p], h[p / 2]); //则交换 p /= 2; //继续向上调整 &#125; else break; &#125;&#125;int main()&#123; cin&gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; h[i]; for(int i = n / 2; i &gt;= 1; i--)down(i); while(m--)&#123; cout &lt;&lt; h[1] &lt;&lt; ' '; h[1] = h[n--]; down(1); &#125; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"堆","slug":"堆","permalink":"http://zhumenger.top/tags/堆/"}]}]}