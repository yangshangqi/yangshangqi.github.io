{"meta":{"title":"zhumenger ❤ blog","subtitle":null,"description":"穿过落雁修竹, 看过日升月暮<br/>你说总有一天你会名扬天下实现你的抱负!","author":"zhumenger","url":"http://zhumenger.top","root":"/"},"pages":[{"title":"404","date":"2019-06-10T10:17:33.000Z","updated":"2019-06-10T10:17:33.852Z","comments":true,"path":"404/index.html","permalink":"http://zhumenger.top/404/index.html","excerpt":"","text":""},{"title":"about","date":"2019-06-10T09:53:05.000Z","updated":"2019-07-09T07:13:35.130Z","comments":true,"path":"about/index.html","permalink":"http://zhumenger.top/about/index.html","excerpt":"","text":"人生是一个很长很长的梦 每个人都想着把这个梦做得完美 却奈何，奇怪的东西总是会出现在梦里 而我们只会不断沉迷，越陷越深 早已忘却了 这，只是一场梦…"},{"title":"categories","date":"2019-06-10T09:52:55.000Z","updated":"2019-07-09T07:11:48.278Z","comments":true,"path":"categories/index.html","permalink":"http://zhumenger.top/categories/index.html","excerpt":"","text":""},{"title":"guestbook","date":"2019-06-13T15:51:50.000Z","updated":"2019-06-13T15:51:50.980Z","comments":true,"path":"guestbook/index.html","permalink":"http://zhumenger.top/guestbook/index.html","excerpt":"","text":""},{"title":"search","date":"2019-07-09T07:07:01.000Z","updated":"2019-07-09T07:07:01.839Z","comments":true,"path":"search/index-1.html","permalink":"http://zhumenger.top/search/index-1.html","excerpt":"","text":""},{"title":"search","date":"2019-06-10T10:17:29.000Z","updated":"2019-06-10T10:17:29.558Z","comments":true,"path":"search/index.html","permalink":"http://zhumenger.top/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-10T09:52:42.000Z","updated":"2019-07-09T07:11:22.321Z","comments":true,"path":"tags/index.html","permalink":"http://zhumenger.top/tags/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-10T10:18:32.000Z","updated":"2019-06-10T10:18:32.868Z","comments":true,"path":"tags/index-1.html","permalink":"http://zhumenger.top/tags/index-1.html","excerpt":"","text":""},{"title":"timeline","date":"2019-06-13T16:10:01.000Z","updated":"2019-07-08T07:17:59.989Z","comments":true,"path":"timeline/index.html","permalink":"http://zhumenger.top/timeline/index.html","excerpt":"","text":""}],"posts":[{"title":"强制类型转换","slug":"强制类型转换","date":"2019-07-10T10:08:47.000Z","updated":"2019-07-10T10:08:47.999Z","comments":true,"path":"2019/07/10/强制类型转换/","link":"","permalink":"http://zhumenger.top/2019/07/10/强制类型转换/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"满足条件的01序列","slug":"数论/满足条件的01序列","date":"2019-07-10T08:18:54.000Z","updated":"2019-07-10T08:20:24.020Z","comments":true,"path":"2019/07/10/数论/满足条件的01序列/","link":"","permalink":"http://zhumenger.top/2019/07/10/数论/满足条件的01序列/","excerpt":"","text":"题目描述 给定n个0和n个1，它们将按照某种顺序排成长度为2n的序列，求它们能排列成的所有序列中，能够满足任意前缀序列中0的个数都不少于1的个数的序列有多少个。 输出的答案对109+7取模。 输出格式 共一行，包含整数n。 输出格式 共一行，包含一个整数，表示答案。 数据范围 1≤n≤105 输入样例： 3 输出样例： 5 题解： 可以将这道题转化为表格的形式，0表示向左走一格，1表示向上走一格，要想满足前缀序列中0的个数始终不少于1的个数，只需满足x &gt;= y即可，如下图所示 即到(n, n)的路径中不能越过红线，越过红线的路径皆为违法的路径,如下图所示： 任意一条违法的路径都能通过 y = x 这条线从(n, n)映射到(n - 1, n + 1) 所以违法的路径我们是可以求出来的，即C(2n, n - 1), 那么用总路径减去违法的路径便是我们想要求出的答案 即answer = C(2n, n) - C(2n, n - 1), 化简可得answer = (2n)! /(n! * n!)/(1 + n) = C(2n, n) / (1 + n) 代码如下： 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;typedef long long ll;const int mod = 1e9 + 7;int ksm(int a, int b)//快速幂求乘法逆元&#123; ll ans = 1; while(b)&#123; if(b &amp; 1)ans = (ll)ans * a % mod; b &gt;&gt;= 1; a = (ll)a * a % mod; &#125; return ans;&#125;int main()&#123; int n; cin &gt;&gt; n; int a = 2 * n, b = n; int ans = 1; for(int i = a; i &gt; a - b; i--) ans = (ll)ans * i % mod; for(int i = 1; i &lt;= b; i++) ans = (ll)ans * ksm(i, mod - 2) % mod; ans = (ll)ans * ksm(n + 1, mod - 2) % mod; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"}]},{"title":"组合数IV之高精度","slug":"数论/组合数IV之高精度","date":"2019-07-10T07:56:50.000Z","updated":"2019-07-10T07:58:04.918Z","comments":true,"path":"2019/07/10/数论/组合数IV之高精度/","link":"","permalink":"http://zhumenger.top/2019/07/10/数论/组合数IV之高精度/","excerpt":"","text":"题目描述 输入a,b，求C(a, b)的值。 注意结果可能很大，需要使用高精度计算。 输入格式 共一行，包含两个整数a和b。 输出格式 共一行，输出C(a, b)的值。 数据范围 1≤b≤a≤5000 输入样例： 5 3 输出样例： 10 题解： 可以用公式C(a, b) = a! / (b! * (a - b)!) 来做，如果直接用for循环求阶乘的话，时间复杂度很大，我们求除法运算的时候，一般都是将他们分解质因数，然后用分子分解质因数的个数减去分母分解质因数的个数，最后将质因数乘起来便是最后的答案 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N = 5010;int primes[N], cnt;int sum[N];bool st[N];void get_primes(int n) //线性筛法得到质因数&#123; for(int i = 2; i &lt;= n; i++)&#123; if(!st[i]) primes[cnt++] = i; for(int j = 0; j &lt; cnt &amp;&amp; primes[j] &lt;= n / i; j++)&#123; st[primes[j] * i] = true; if(i % primes[j] == 0)break; &#125; &#125;&#125;int get(int n, int p)//得到p这个质因数的个数&#123; int res = 0; while(n)&#123; res += n / p; n /= p; &#125; return res;&#125;vector&lt;int&gt; mul(vector&lt;int&gt; a, int b)//高精度乘法&#123; vector&lt;int&gt; ans; int t = 0; for(int i = 0; i &lt; a.size(); i++)&#123; t += a[i] * b; ans.push_back(t % 10); t /= 10; &#125; while(t)&#123; ans.push_back(t % 10); t /= 10; &#125; return ans;&#125;int main()&#123; int a, b; cin &gt;&gt; a &gt;&gt; b; get_primes(a); for(int i = 0; i &lt; cnt; i++)&#123; int p = primes[i]; sum[i] = get(a, p) - get(b, p) - get(a - b, p);//获取除法运算中每个质因数的个数 &#125; vector&lt;int&gt;res; res.push_back(1); for(int i = 0; i &lt; cnt; i++)&#123;//枚举每个质因数 for(int j = 0; j &lt; sum[i]; j++)&#123;//枚举个数 res = mul(res, primes[i]);//高精度乘法 &#125; &#125; for(int i = res.size() - 1; i &gt;= 0; i--)&#123;//倒序输出 cout &lt;&lt; res[i]; &#125; return 0;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"组合数","slug":"组合数","permalink":"http://zhumenger.top/tags/组合数/"}]},{"title":"高斯消元解线性方程组","slug":"数论/高斯消元解线性方程组","date":"2019-07-09T04:40:45.000Z","updated":"2019-07-09T05:47:05.248Z","comments":true,"path":"2019/07/09/数论/高斯消元解线性方程组/","link":"","permalink":"http://zhumenger.top/2019/07/09/数论/高斯消元解线性方程组/","excerpt":"","text":"一.高斯消元解线性方程组题目描述输入一个包含n个方程n个未知数的线性方程组。 方程组中的系数为实数。 求解这个方程组。 下图为一个包含m个方程n个未知数的线性方程组示例： 输入格式 第一行包含整数n。 接下来n行，每行包含n+1个实数，表示一个方程的n个系数以及等号右侧的常数。 输出格式 如果给定线性方程组存在唯一解，则输出共n行，其中第i行输出第i个未知数的解，结果保留两位小数。 如果给定线性方程组存在无数解，则输出“Infinite group solutions”。 如果给定线性方程组无解，则输出“No solution”。 数据范围 1≤n≤100,所有输入系数以及常数均保留两位小数，绝对值均不超过100。 输入样例： 31.00 2.00 -1.00 -6.002.00 1.00 -3.00 -9.00-1.00 -1.00 2.00 7.00 输出样例： 1.00-2.003.00 题解： 高斯消元，即线性代数的知识，将方程组系数矩阵转化为三角矩阵: 1.枚举每一列，在每一列中找到绝对值最大的一行 2.将改行放到最上面，并将该行首非零元素化为1 3.将下面的所有行的第c列化为0， 4.最终得到三角矩阵，倒叙遍历，不断减去前面的解乘以系数，便可得到所有的解 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int N = 110;const double eps = 1e-6;int n;double a[N][N];int gauss()&#123; int c, r; for(c = 0, r = 0; c &lt; n; c++)&#123;//枚举每一列 int t = r; for(int i = r; i &lt; n; i++) if(fabs(a[i][c]) &gt; fabs(a[t][c]))//找到这一列绝对值最大的一行 t = i; if(fabs(a[t][c]) &lt; eps)continue; //如果全为0，则略过 for(int i = c; i &lt; n + 1; i++)swap(a[t][i], a[r][i]);//将第t行与第r行交换 for(int i = n; i &gt;= c; i--)a[r][i] /= a[r][c];//将首元素系数化为1 for(int i = r + 1; i &lt; n; i++) //将第r + 1行以下的第c列的元素化为0 if(fabs(a[i][c]) &gt; eps) for(int j = n; j &gt;= c; j--) //每一列都要相减 a[i][j] -= a[r][j] * a[i][c]; r++; &#125; if(r &lt; n)&#123; //如果r &lt; n, r + 1 行一下的系数都为0 for(int i = r; i &lt; n; i++) if(fabs(a[i][n]) &gt; eps) //a[i][n]不为0，说明0 = a[i][n]，无解 return 2; return 1; //否则有无穷多解 &#125; for(int i = n - 1 ; i &gt;= 0; i--) //否则有唯一解 for(int j = i + 1; j &lt; n; j++) //倒叙遍历，减去xi之前的x(i + j) * 系数，变得到了xi的解 a[i][n] -= a[j][n] * a[i][j]; return 0;&#125;int main()&#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt;= n; j++) cin &gt;&gt; a[i][j]; int t = gauss(); if(t == 0)&#123; for(int i = 0; i &lt; n; i++)printf(\"%.2lf\\n\", a[i][n]); &#125; else if(t == 1)puts(\"Infinite group solutions\"); else puts(\"No solution\"); return 0;&#125; 二.高斯消元解异或线性方程组题目描述 输入一个包含n个方程n个未知数的异或线性方程组。 方程组中的系数和常数为0或1，每个未知数的取值也为0或1。 求解这个方程组. 异或线性方程组示例如下： 1234M[1][1]x[1] ^ M[1][2]x[2] ^ … ^ M[1][n]x[n] = B[1]M[2][1]x[1] ^ M[2][2]x[2] ^ … ^ M[2][n]x[n] = B[2]…M[n][1]x[1] ^ M[n][2]x[2] ^ … ^ M[n][n]x[n] = B[n] 其中“^”表示异或(XOR)，M[i][j]表示第i个式子中x[j]的系数，B[i]是第i个方程右端的常数，取值均为0或1。 输入格式 第一行包含整数n。 接下来n行，每行包含n+1个整数0或1，表示一个方程的n个系数以及等号右侧的常数。 输出格式 如果给定线性方程组存在唯一解，则输出共n行，其中第i行输出第i个未知数的解。 如果给定线性方程组存在无数解，则输出“Infinite group solutions”。 如果给定线性方程组无解，则输出“No solution”。 数据范围 1≤n≤100 输入样例： 31 1 0 10 1 1 01 0 0 1 输出样例： 100 题解： 思路跟第一题一样，代码稍微改改就行 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int N = 110;int n;int a[N][N];int gauss()&#123; int c, r; for(c = 0, r = 0; c &lt; n; c++)&#123;//枚举每一列 int t = r; for(int i = r; i &lt; n; i++) if(a[i][c] &gt; a[t][c])//找到这一列绝对值最大的一行 t = i; if(!a[t][c])continue; //如果全为0，则略过 for(int i = c; i &lt; n + 1; i++)swap(a[t][i], a[r][i]);//将第t行与第r行交换 for(int i = r + 1; i &lt; n; i++) //将第r + 1行以下的第c列的元素化为0 if(a[i][c]) for(int j = n; j &gt;= c; j--) //每一列都要异或 a[i][j] ^= a[r][j]; r++; &#125; if(r &lt; n)&#123; //如果r &lt; n, r + 1 行一下的系数都为0 for(int i = r; i &lt; n; i++) if(a[i][n]) //a[i][n]不为0，说明0 = a[i][n]，无解 return 2; return 1; //否则有无穷多解 &#125; for(int i = n - 1 ; i &gt;= 0; i--) for(int j = i + 1; j &lt; n; j++) a[i][n] ^= a[j][n] * a[i][j]; return 0;&#125;int main()&#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt;= n; j++) cin &gt;&gt; a[i][j]; int t = gauss(); if(t == 0)&#123; for(int i = 0; i &lt; n; i++)printf(\"%d\\n\", a[i][n]); &#125; else if(t == 1)puts(\"Infinite group solutions\"); else puts(\"No solution\"); return 0;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"高斯消元","slug":"高斯消元","permalink":"http://zhumenger.top/tags/高斯消元/"}]},{"title":"JS基础之标识符、数据类型","slug":"JavaScirpt/JS基础之标识符、数据类型","date":"2019-07-08T14:24:12.000Z","updated":"2019-07-10T09:16:43.143Z","comments":true,"path":"2019/07/08/JavaScirpt/JS基础之标识符、数据类型/","link":"","permalink":"http://zhumenger.top/2019/07/08/JavaScirpt/JS基础之标识符、数据类型/","excerpt":"","text":"一.标识符1.在JS中所有的可以由我们自主命名的都可以称为标识符 2.命名规则： 1.标识符中可以含有字母、数字、下划线和$。2.标识符不能以数字开头3.标识符不能是关键字 4.标识符一般采用驼峰命名法： 首字母小写，每个单词的开头字母大写，其余字母小写 如: var helloWorld = 123； 二.数据类型数据类型指的是字面量的类型，一共有6种 String 字符串 Number 数值 Boolean 布尔值 Null 空值 Undefined 未定义 Object 对象 前5个为基本数据类型，Object属于引用数据类型 1.字符串声明: 1234567&lt;script type=\"text/javascript\"&gt; var str = \"hello\"; //输出字面量 字符串str alert(\"str\"); //输出变量str alert(str);&lt;/script&gt; 1&gt;.单引号，双引号都可以，但必须配对，不能混淆 2&gt;.引号不能嵌套，双引号里不能放双引号，单引号里不能放单引号 3&gt;.双引号里可以嵌套单引号 4&gt;.如果想要任意嵌套，必须加入转义字符 转义字符： 在字符串中可以用\\作为转义字符 如\\ “表示 单引号， \\ n 表示换行， \\ \\ 表示斜杠 2.数值1&gt;.声明 123&lt;script type=\"text/javascript\"&gt; var a = 123;&lt;/script&gt; 2&gt;.可以用 typeof 来检查一个变量的类型 123456&lt;script type=\"text/javascript\"&gt; var a = 123; console.log(typeof a);//输出“number”类型 var b = \"123\" console.log(typeof b);//输出“string”类型&lt;/script&gt; 3&gt;.输出数字的最大值、最小值 1234567&lt;script type=\"text/javascript\"&gt; //输出最大值 console.log(Number.MAX_VALUE); //输出最小值 console.log(Number.MIN_VALUE); //如果使用的Number表示的数字超过了最大值,则会返回一个Infinity表示无穷&lt;/script&gt; 4&gt;.NAN 是一个特殊的数字， 表示Not A Number 1234567&lt;script type=\"text/javascript\"&gt; var a = \"abc\" * \"abc\"; console.log(a); //输出NAN， console.log(typeof a); //输出number&lt;/script&gt; 5&gt;.如果JS进行浮点元素，可能得到一个不确定的结果 12345&lt;script type=\"text/javascript\"&gt; var a = 0.1 + 0.2; comsole.log(a); //输出0.3000000000000004&lt;/script&gt; 3.布尔值 Boolean1234567891011&lt;script type=\"text/javascript\"&gt; /* *Boolean 布尔值 * 布尔值只有俩个 * true -表示真 * false -表示假 */ var bool = false; console.log(bool)//输出false console.log(typeof bool)//输出boolean&lt;/script&gt; 4.Null12345678910&lt;script type=\"text/javascript\"&gt; /* * Null类型只有一个,就是null * null表示一个为空的对象 * 使用typeof检查null值时，返回object */ var a = null; console.log(a);//输出null console.log(typeof a);//输出//object &lt;/script&gt; 5.Undefined12345678&lt;script type=\"text/javascript\"&gt; /* * Undefined的类型只有一个，就是undefined * 当声明一个变量未赋值时，就是undefined */ var a; console.log(a)//输出undefined &lt;/script&gt;","categories":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/categories/JavaScirpt/"}],"tags":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/tags/JavaScirpt/"}]},{"title":"扩展欧几里得算法","slug":"数论/扩展欧几里得算法","date":"2019-07-08T03:36:44.000Z","updated":"2019-07-08T03:39:26.332Z","comments":true,"path":"2019/07/08/数论/扩展欧几里得算法/","link":"","permalink":"http://zhumenger.top/2019/07/08/数论/扩展欧几里得算法/","excerpt":"","text":"一.扩展欧几里得算法裴蜀定理 对于任意的整数a, b，存在一对整数 x，y，满足ax + by = gcd(a, b). 题目描述 给定n对正整数ai,bi，对于每对数，求出一组xi,yi，使其满足ai∗xi+bi∗yi=gcd(ai,bi)。 输入格式 第一行包含整数n。 接下来n行，每行包含两个整数ai,bi。 输出格式 输出共n行，对于每组ai,bi，求出一组满足条件的xi,yi，每组结果占一行。 本题答案不唯一，输出任意满足条件的xi,yi均可。 数据范围 1≤n≤1051≤ai,bi≤2∗109 输入样例： 24 68 18 输出样例： -1 1-2 1 代码如下： 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;typedef long long int ll;ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y)&#123; if(b == 0)&#123; x = 1; y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x ; //y表示b的系数 return d;&#125;int main()&#123; int n; ll a, b, x, y; cin &gt;&gt; n; while(n--)&#123; scanf(\"%lld%lld\", &amp;a, &amp;b); ll d = exgcd(a, b, x, y); printf(\"%lld %lld\\n\", x, y); &#125; return 0;&#125; 二.线性同余方程题目描述给定n组数据ai,bi,mi，对于每组数求出一个xi，使其满足ai∗xi≡bi(mod mi)，如果无解则输出impossible。 输入格式第一行包含整数n。 接下来n行，每行包含一组数据ai,bi,mi。 输出格式输出共n行，每组数据输出一个整数表示一个满足条件的xi，如果无解则输出impossible。 每组数据结果占一行，结果可能不唯一，输出任意一个满足条件的结果均可。 输出答案必须在int范围之内。 数据范围1≤n≤10^51≤ai,bi,mi≤2∗10^9 输入样例： 22 3 64 3 5 输出样例： impossible7 题解： 对于a * x % m = b 等价于 a * x - b 是m的倍数，不妨设为 -y 倍。于是，该方程可以改写为 a * x + m * y = b。 这样就变成了欧几里得算法，只有 b 为 gcd(a, m) 的倍数的时候，方程才有解，带公式即可 代码如下： 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;typedef long long int ll;ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y)&#123; if(b == 0)&#123; x = 1; y = 0; return a; &#125; ll d = exgcd(b, a % b, y ,x); y -= a / b * x; return d;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; ll a, b, c; ll x, y; scanf(\"%lld %lld %lld\", &amp;a, &amp;b, &amp;c); ll d = exgcd(a, c, x, y); if(b % d == 0) printf(\"%lld\\n\", x *(b / d) % c); //x 乘以倍数 % c else puts(\"impossible\"); &#125; return 0;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"http://zhumenger.top/tags/扩展欧几里得/"}]},{"title":"JS基础之基本语法、字面量和变量","slug":"JavaScirpt/JS基础之基本语法、字面量和变量","date":"2019-07-07T13:14:03.000Z","updated":"2019-07-07T13:16:35.696Z","comments":true,"path":"2019/07/07/JavaScirpt/JS基础之基本语法、字面量和变量/","link":"","permalink":"http://zhumenger.top/2019/07/07/JavaScirpt/JS基础之基本语法、字面量和变量/","excerpt":"","text":"一.基本语法1.注释 123456&lt;script type=\"text/javascript\"&gt; //单行注释 /* 多行注释，注释中的内容不会被执行 */&lt;/script&gt; 2.JS中严格区分大小写 12alert(\"hello world\");//可以执行Alert(\"hello world\")；//会报错 3.分号表示一个语句的结束. 如果不写分号，浏览器会自动添加，但是会消耗一些系统资源 而且有点时候，浏览器会加错分号，所以在开发中分号必须写 4.JS会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化 二.字面量和变量1.字面量 都是一些不可改变的值，比如：1 2 3 4 5 字面量可以直接使用，但是我们一般都不会直接使用字面量 2.变量 可以用来保存字面量，而且变量的值可以任意改变 所以在开发中都是通过变量取保存一个字面量，而很少直接用到字面量 3.变量的使用 123456//在JS中使用var关键字来声明一个变量var a;//为变量赋值a = 123；//向页面输出adocument.write(a)","categories":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/categories/JavaScirpt/"}],"tags":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/tags/JavaScirpt/"}]},{"title":"JS基础之编写位置","slug":"JavaScirpt/JS基础之编写位置","date":"2019-07-07T12:45:20.000Z","updated":"2019-07-07T12:50:11.539Z","comments":true,"path":"2019/07/07/JavaScirpt/JS基础之编写位置/","link":"","permalink":"http://zhumenger.top/2019/07/07/JavaScirpt/JS基础之编写位置/","excerpt":"","text":"1.可以将JS的代码写到标签的属性中，当点击按钮时执行 1&lt;button onclick = \"alert('讨厌，你点我干嘛');\"&gt;点我一下&lt;/button&gt; 2.可以将JS代码写在href属性中，这样点击超链接时，会执行JS代码 1&lt;a href=\"javascript:alert('让你点你就点');\"&gt;你也点我一下&lt;/a&gt; 虽然可以写在标签的属性中，但是他们属于结构与行为耦合不方便维护，不推荐使用 3.可以将JS写在script标签中,打开网页时直接运行 123&lt;script type=\"text/javascript\"&gt; alert(\"我是script标签中的代码\");&lt;/script&gt; 4.可以将JS代码写到外部JS文件中，然后通过script标签引入,用src引入路径 1&lt;script type=\"text/javascript\" src=\"script.js\"&gt;&lt;/script&gt; script标签一旦引入外部文件，就不能编写代码了，即使编写了代码，编译器也会忽略","categories":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/categories/JavaScirpt/"}],"tags":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/tags/JavaScirpt/"}]},{"title":"JS基础之Hello World","slug":"JavaScirpt/JS基础之Hello-World","date":"2019-07-07T11:51:48.000Z","updated":"2019-07-07T11:57:14.595Z","comments":true,"path":"2019/07/07/JavaScirpt/JS基础之Hello-World/","link":"","permalink":"http://zhumenger.top/2019/07/07/JavaScirpt/JS基础之Hello-World/","excerpt":"","text":"输出语句1.所有的JS代码都要放到script标签里 2.alert(）：可以控制浏览器发出一个警告框 123&lt;script type=\"text/javascript\"&gt; alert(\"这是我的第一行JS代码\");&lt;/script&gt; 效果如下： 3.document.write()可以向body中输出一个内容 123&lt;script type=\"text/javascript\"&gt; document.write(\"看我出不出来\");&lt;/script&gt; 4.console.log()可以向控制台输出一个内容 123&lt;script type=\"text/javascript\"&gt; console.log(\"你猜猜我在哪\");&lt;/script&gt; 效果如下：","categories":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/categories/JavaScirpt/"}],"tags":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/tags/JavaScirpt/"}]},{"title":"快速幂","slug":"数论/快速幂","date":"2019-07-07T06:04:35.000Z","updated":"2019-07-07T06:05:45.942Z","comments":true,"path":"2019/07/07/数论/快速幂/","link":"","permalink":"http://zhumenger.top/2019/07/07/数论/快速幂/","excerpt":"","text":"一.快速幂快速幂问题（求a^b）: 1.我们都知道当指数为偶数的时候，对于a ^b，可以变为(a ^ 2) ^ (b/2)。2.而当指数为奇数的时候，对于a ^ b，可以化简为a * (a ^ (b-1))，然后即可以化简为a * ((a ^ 2) ^ ((b-1)/2))3.如此我们便可知道 如果b为奇数，则将b减一除二，将一个a取到外面，同时对里面的a平方。4.如果b为偶数，则直接除二，同时对a平方。 若b为7，a为2。则a变为4，b变为3，ans变为2 * (2 ^ 2) ^ 3。然后继续向后运，(注意此时a为4)，a变为16，b变为1，ans变为2* 4*(2 ^ 2 ^ 2) ^ 1。结果为128。 若b为10，a为2。则a变为4，b变为5，ans变(2 ^ 2) ^ 5。然后继续向后运，(注意此时a为4)，a变为16，b变为2，ans变为4(2 ^ 2 ^ 2) ^2。再之后(注意此时a为16)，a变为256，b变为1，ans变为4(2 ^ 2 ^ 2 ^ 2) ^ 1。结果为1024 快速幂取余 代码如下： 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;typedef long long int ll;ll a, b, c;void solve()&#123; ll ans = 1; while(b)&#123; if(b &amp; 1)ans = ans * a % c; //如果b为奇数 b &gt;&gt;= 1; //b除以2 a = a * a % c; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; solve(); &#125; return 0;&#125; 二.快速幂求逆元题目描述 给定n组ai,pi，其中pipi是质数,求ai模pi的乘法逆元，若逆元不存在则输出impossible。 输入格式 第一行包含整数n。 接下来n行，每行包含一个数组ai,pi，数据保证pi是质数。 输出格式 输出共n行，每组数据输出一个结果，每个结果占一行。 若ai模pi的乘法逆元存在，则输出一个整数，表示逆元，否则输出impossible。 数据范围 1≤n≤10^51≤ai,pi≤2∗10^9 输入样例： 34 38 56 3 输出样例： 12impossible 什么是逆元** 若b与m互质，对于a/b(a是b的倍数) % m，可以找到一个数x使得ax % m = a/b % m,那么我们称x为b%m的逆元 费马定理： 若p为质数，则b^(p - 1) % p == 1。 题解： 这道题用到了费马定理，b * b^(p - 2) % p == 1,所以只需求b^(p - 2) % p即可，那么这道题便转化为了一道快速幂的问题 代码如下： 12345678910111213141516171819202122232425//费马定理：若p为质数，则a^(p -1)% p == 1,可得a * a^(p - 2) % p == 1，这道题求a^(p - 2) % p 便是a的逆元#include&lt;iostream&gt;using namespace std;typedef long long int ll;ll ksm(ll a, ll b, ll c)&#123; ll ans = 1; while(b)&#123; if(b &amp; 1)ans = ans * a % c; b &gt;&gt;= 1; a =a * a % c; &#125; return ans;&#125;int main()&#123; ll t, a, b; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; a &gt;&gt; b; if(a % b == 0)cout &lt;&lt; \"impossible\" &lt;&lt; endl;//若a是p的倍数，则不存在逆元 else cout &lt;&lt; ksm(a, b - 2, b) &lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"快速幂","slug":"快速幂","permalink":"http://zhumenger.top/tags/快速幂/"}]},{"title":"欧拉函数","slug":"数论/欧拉函数","date":"2019-07-07T05:58:01.000Z","updated":"2019-07-07T06:00:17.297Z","comments":true,"path":"2019/07/07/数论/欧拉函数/","link":"","permalink":"http://zhumenger.top/2019/07/07/数论/欧拉函数/","excerpt":"","text":"一.欧拉函数什么是欧拉函数： 1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)。 欧拉函数的通式： φ(n)=n(1-1/p1)(1-1/p2)(1-1/p3)(1-1/p4)…..(1-1/pn),其中p1, p2……pn为n的所有质因数，n是不为0的整数。φ(1)=1（唯一和1互质的数就是1本身）。 欧拉定理： 若a与n互质，则a^φ(n) % n == 1 求欧拉函数的代码如下： 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;typedef long long int ll;void solve(ll n)&#123; ll ans = n; for(int i = 2; i &lt;= n / i; i++)&#123; if(n % i == 0)&#123; ans = ans / i * (i - 1);//如果i为n的质因数，则带入公式 while(n % i == 0)n /= i;//分解质因数 &#125; &#125; if(n &gt; 1)ans = ans / n * (n - 1); cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; ll n, t; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; n; solve(n); &#125; return 0;&#125; 二.. 筛法求欧拉函数 给定一个正整数n，求1~n中每个数的欧拉函数之和。 输入格式 共一行，包含一个整数n。 输出格式 共一行，包含一个整数，表示1~n中每个数的欧拉函数之和。 数据范围 1≤n≤10^6 输入样例： 6 输出样例： 12 思路： 在线性筛法的过程得到每个数的欧拉函数 1.如果i为质数，则i之前的数都与i互质,所以φ(i) = i - 1, 2.如果i % prime[j] == 0,φ(prime[j] * i) = prime[j] * ouler[i]; 3.若果i % prime[j] != 0, φ(prime[j] * i) = ouler[i] * (prime[j] - 1) 代码如下： 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int prime[N], ouler[N], cnt;typedef long long int ll;bool vis[N];void get_ouler(int n)&#123; ouler[1] = 1; //φ(1) = 1,与1互质的数为1 for(int i = 2; i &lt;= n; i++)&#123; if(!vis[i])&#123; //如果是质数 prime[cnt++] = i; ouler[i] = i - 1;//φ(i) = i - 1 &#125; for(int j = 0; j &lt; cnt &amp;&amp; prime[j] &lt;= n / i; j++)&#123; vis[prime[j] * i] = true; if(i % prime[j] == 0)&#123; ouler[prime[j] * i] = prime[j] * ouler[i]; break; &#125; ouler[prime[j] * i] = ouler[i] * (prime[j] - 1); &#125; &#125; ll ans = 0; for(int i = 1; i &lt;= n; i++) ans += ouler[i]; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; int n; cin &gt;&gt; n; get_ouler(n); return 0;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/categories/数论/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"http://zhumenger.top/tags/欧拉函数/"}]},{"title":"约数","slug":"数论/约数","date":"2019-07-07T05:54:22.000Z","updated":"2019-07-07T05:57:46.109Z","comments":true,"path":"2019/07/07/数论/约数/","link":"","permalink":"http://zhumenger.top/2019/07/07/数论/约数/","excerpt":"","text":"算术基本定理任何一个大于1的自然数 N ，如果N不为质数，都可以唯一分解成有限个质数的乘积 N = P1^a1 * P2^a2 ….Pn^an , 这里 P1&lt;P2&lt;….&lt;Pn均为质数，其诸指数 ai 是正整数。 定理应用（1）一个大于1的正整数N，如果它的标准分解式为： N = P1^a1 * P2^a2 ….Pn^an ，那么它的正因数个数为 φ(N) = (1 + a1)(1 + a2)(1 +a3)。 （2） 它的全体正因数之和为φ(N) = (1 + p1 + p1^2 + …+ p1^a1)(1 + p2 + p2^2 + … + p2^a2)…(1 + pn + pn^2 + … + pn^an). 一.约数个数题目描述 给定n个正整数ai，请你输出这些数的乘积的约数个数，答案对109+7取模。 输入格式 第一行包含整数n。 接下来n行，每行包含一个整数ai。 输出格式 输出一个整数，表示所给正整数的乘积的约数个数，答案需对109+7109+7取模。 数据范围 1≤n≤1001≤ai≤2∗10^9 输入样例： 3268 输出样例： 12 求n个数乘积的约数的个数，用到了定理（1）的知识，代码如下： 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;unordered_map&gt;using namespace std;unordered_map&lt;int, int&gt; mp;typedef long long int ll;const int mod = 1e9 + 7;void solve(ll n)&#123; for(int i = 2; i &lt;= n / i; i++)&#123; while(n % i == 0)&#123; n /= i; mp[i]++; &#125; &#125; if(n &gt; 1)mp[n]++;//先分解所有的质因子&#125;int main()&#123; ll n, t; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt;n; solve(n); &#125; ll ans = 1; for(auto mps : mp)&#123; ans = ans * (mps.second + 1) % mod;//代公式即可 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 二.约数之和 给定n个正整数ai，请你输出这些数的乘积的约数之和，答案对109+7取模。 输入格式 第一行包含整数n。 接下来n行，每行包含一个整数ai。 输出格式 输出一个整数，表示所给正整数的乘积的约数之和，答案需对109+7取模。 数据范围 1≤n≤1001≤ai≤2∗10^9 输入样例： 3268 输出样例： 252 求n个数乘积的约数之和，用到了定理（2）的知识，代码如下： 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;unordered_map&gt;using namespace std;const int mod = 1e9 + 7;typedef long long int ll;unordered_map&lt;int, int &gt;mp;void solve(ll n)&#123; for(ll i = 2; i &lt;= n / i; i++)&#123; while(n % i == 0)&#123; n /= i; mp[i]++; &#125; &#125; if(n &gt; 1)mp[n]++;//分解所有的质因数&#125;int main()&#123; int t; ll n; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; n; solve(n); &#125; ll ans = 1; for(auto mps : mp)&#123; ll t= 1; ll x = mps.first, a = mps.second; while(a--)t = (t * x + 1) % mod; //带公式即可 ans = ans * t % mod; &#125; cout &lt;&lt;ans &lt;&lt; endl;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/categories/数论/"}],"tags":[{"name":"数论，约数","slug":"数论，约数","permalink":"http://zhumenger.top/tags/数论，约数/"}]},{"title":"二分图","slug":"图论/二分图/二分图","date":"2019-06-24T12:11:27.000Z","updated":"2019-07-07T03:08:53.783Z","comments":true,"path":"2019/06/24/图论/二分图/二分图/","link":"","permalink":"http://zhumenger.top/2019/06/24/图论/二分图/二分图/","excerpt":"","text":"二分图1.定义： 二分图是指将图中的点分为俩个集合X和Y，满足所有的边仅在俩个集合之间，并且俩个集合中没有边，即X中的点只与Y中的点相连，如下图所示，这样的图称为二分图。 2.性质： 当且仅当图中不含奇数环，即所有的环的边数为偶数。这样的图一定是二分图。 3.判定： 染色法判定二分图原理： 首先任意取出一个顶点进行染色,和该节点相邻的点有三种情况: 1.未染色 那么继续染色此节点(染色为另一种颜色) 2.已染色但和当前节点颜色不同 跳过该点 3.已染色并且和当前节点颜色相同 返回失败(该图不是二分图) 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int h[N], e[N], ne[N], idx;int n, m, color[N];//color表示哪些点已经被染了色void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;bool dfs(int x, int c)//c表示染色的种类&#123; color[x] = c; for(int i = h[x]; i != -1; i = ne[i])&#123; int j = e[i]; if(color[j] == c)return false;//如果与i相连的点与i染成了相同的颜色，返回false else if(color[j] == 0 &amp;&amp; !dfs(j, -c))return false; //如果该点还没有被染色，并且染成相反的染色失败了的话，返回false &#125; return true;&#125;int main()&#123; scanf(\"%d%d\", &amp;n, &amp;m); memset(h, -1, sizeof h); while(m--)&#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); add(a, b); add(b, a); &#125; bool flag = false; for(int i = 1; i &lt;= n; i++)&#123;//遍历每一个点 if(color[i] == 0)&#123;//如果没有被染色 if(!dfs(i, 1))&#123;// 判断是否能被染色 flag = true; break; &#125; &#125; &#125; if(flag)puts(\"No\"); else puts(\"Yes\"); return 0;&#125; 二分图的最大匹配什么是匹配： 给定一个二分图G，在G的一个子图M中， M的边集{E}中的任意两条边都不交汇于同一个结点，则称M是一个匹配。 图中加粗的边是数量为2的匹配。 二分图的最大匹配 ：选择匹配边数最多的一个子图称为图的最大匹配 如下图所示，加粗的边数最多为3，所以该子图为二分图的最大匹配 如何求二分图的最大匹配： 匈牙利算法 假设左边的集合都为男生，右边的集合都为女生，让我们求出最多有多少对情侣能够配对成功。 对于每个男生，遍历他所有有好感度的女生，有俩种情况： 1.如果该女生是单身，则匹配成功 2.否则我们寻找与该女生的配对的那个男生，看看这个男生是否能和其他的女生配对，如果可以的话，让这个男与其备胎匹配，空出来的这个女生便可以与当前的这个男生配对成功。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e5 + 10;int h[N], e[N], ne[N], idx;int match[N];//一个映射关系:表示妹子与谁配了对bool vis[N];//表示哪些妹子已经遍历过了int n1, n2, m;void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;bool Find(int x)&#123; for(int i = h[x]; i != -1; i = ne[i])&#123;//遍历该男生所有有好感度的女生 int j = e[i]; if(!vis[j])&#123;//如果该女生还没有被当前男生询问过 vis[j] = true;//已经被询问过 if(match[j] == 0 || Find(match[j]))&#123;//如果该女生还没有配对或者与该女生配对的那个男生可以跟另 match[j] = x; //一个女生配对的话，该女生便可以与当前的这个男生配对。 return true;//返回true &#125; &#125; &#125; return false;//否则，返回false&#125;int main()&#123; cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m; memset(h, -1, sizeof h); while(m--)&#123; int a, b; cin &gt;&gt; a &gt;&gt; b; add(a, b); &#125; int ans = 0;//表示成功匹配了对少对 for(int i = 1; i &lt;= n1; i++)&#123; memset(vis, false, sizeof vis);//对于每一个男生，所有的妹子还没有询问过，所以这里要初始化 if(Find(i))ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://zhumenger.top/categories/图论/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://zhumenger.top/tags/图论/"},{"name":"二分图","slug":"二分图","permalink":"http://zhumenger.top/tags/二分图/"}]},{"title":"最小生成树","slug":"图论/最小生成树/最小生成树","date":"2019-06-24T03:26:41.000Z","updated":"2019-07-09T06:14:22.734Z","comments":true,"path":"2019/06/24/图论/最小生成树/最小生成树/","link":"","permalink":"http://zhumenger.top/2019/06/24/图论/最小生成树/最小生成树/","excerpt":"","text":"最小生成树题目描述 给出无向图中M个节点间N条边的权值。求一个使得所有点连通的子图,要求图内的边权和最小 输入格式 第一行包含两个整数n和m。 接下来m行，每行包含三个整数u，v，w，表示点u和点v之间存在一条权值为w的边。 输出格式 共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。 数据范围 1≤n≤5001≤n≤500,1≤m≤1051≤m≤105,图中涉及边的边权的绝对值均不超过10000。 输入样例： 4 51 2 11 3 21 4 32 3 23 4 4 输出样例： 6 一.克鲁斯卡尔算法(kruskal)算法定义： 假设 WN=(V,{E}) 是一个含有 n 个顶点的连通图，那么我们把它定义为含有 n 棵树的一个森林。每次从图的边集 E 中选取一条权值最小的边，若该条边的两个顶点分属不同的树，就将这两个顶点分别所在的两棵树合成一棵树，表示这俩个点已经连通；若该条边的两个顶点已落在同一棵树上，则直接跳过，因为前面已经选了一个更小的权值的边使得俩个点连在了一起。然后继续选择下一条最小的边加入到集合里面。依次类推，直至森林中只有一棵树，也即子图中含有 n-1条边为止。 kruskal算法流程: 1.建立并查集，每个点各自构成一个集合2.把所有的边按照权值从小到大排序，一次扫描每一条边3.若x，y属于同一个集合，则忽略这条边，继续扫描下一条边4.否则，合并x，y所在的集合，并将边权值累加到答案中 时间复杂度：O(mlogm) 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e6 + 10, INF = 0x3f3f3f3f;int f[N];struct p&#123; //存储所有的边 int a, b, c;&#125;arr[N];int n, m;bool cmp(p a, p b) //按照边权值从小到达排序&#123; return a.c &lt; b.c;&#125;int Find(int x) //找到x的根节点&#123; if(x != f[x])f[x] = Find(f[x]); return f[x];&#125;int main()&#123; int cnt = 0, ans = 0; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)f[i] = i; //初始化为n个集合 for(int i = 0; i &lt; m; i++) cin &gt;&gt; arr[i].a &gt;&gt; arr[i].b &gt;&gt; arr[i].c; sort(arr, arr + m, cmp); for(int i = 0; i &lt; m; i++)&#123; int x = Find(arr[i].a); int y = Find(arr[i].b); if(x != y)&#123; //如果不属于同一个集合 f[x] = y; cnt++; //边数++ ans += arr[i].c; //累加边权值 &#125; if(cnt == n - 1)break; &#125; if(cnt == n - 1)cout &lt;&lt; ans &lt;&lt; endl; else cout &lt;&lt; \"impossible\" &lt;&lt;endl; return 0;&#125; 二.prime算法算法简介： 首先维护一个集合，找到集合之外的距离这个集合最近的点，将这个点加入集合，并用这个点去更新其他点到集合的距离，这样得出来的生成树一定是最小的。算法思想跟dijstra算法类似。 时间复杂度：O(n^2) 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 510, INF = 0x3f3f3f3f;int n, m;int arr[N][N], dis[N];bool vis[N];void prime()&#123; memset(dis, INF, sizeof dis); int ans = 0; for(int i = 0; i &lt; n; i++)&#123; int t = -1; for(int j = 1; j &lt;= n; j++) if(!vis[j] &amp;&amp; (t == -1 || dis[t] &gt; dis[j]))//找到集合外的点到该集合距离最短的点 t = j; //用t记录该下标 if(i &amp;&amp; dis[t] == INF)&#123; //如果没有找到距离集合最短的点，说明这个图是不连通的 puts(\"impossible\"); return ; &#125; if(i)ans += dis[t]; //不断的加上该边权值 vis[t] = true; //表示该点已经加入到集合里了 //用t不断更新其他的点到集合的距离 for(int j = 1; j &lt;= n; j++)dis[j] = min(dis[j], arr[t][j]); &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; memset(vis, false, sizeof vis); cin &gt;&gt; n &gt;&gt; m; int a, b, c; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) arr[i][j] = i == j ? 0 : INF; while(m--)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; arr[a][b] = arr[b][a] = min(arr[a][b], c); &#125; prime(); return 0;&#125; 2.prime算法堆优化 跟dijstra算法一样，再找集合外的点到该集合距离最小的点时用堆做了一个优化。时间复杂度为：O(mlogn) 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;int arr[505][505];int dis[505];bool vis[505];typedef pair&lt;int ,int &gt; p;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt;= n; i++) for(int j = 0; j &lt;= n; j++) arr[i][j] = i == j ? 0 : INF; memset(dis, INF, sizeof dis); memset(vis, false, sizeof vis); int a, b, c; for(int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; arr[a][b] = arr[b][a] = min(arr[a][b], c); &#125; priority_queue&lt;p, vector&lt;p&gt;, greater&lt;p&gt; &gt; q; int ans = 0, sum = 0; dis[1] = 0; q.push(&#123;0, 1&#125;); while(q.size()) &#123; p cur = q.top(); q.pop(); int u = cur.second; if(vis[u])continue; vis[u] = true; sum++; //表示该点已经加入到集合当中 ans += dis[u];//加上该边权值 for(int i = 1; i &lt;= n; i++)&#123; //用该点不断更新集合外的点到集合的距离 if(!vis[i] &amp;&amp; dis[i] &gt; arr[u][i])&#123; dis[i] = arr[u][i]; q.push(&#123;dis[i], i&#125;); //如果该点被更新过，就加入到队列中去 &#125; &#125; &#125; if(sum == n)cout &lt;&lt; ans &lt;&lt; endl; //判断是否连通 else cout &lt;&lt; \"impossible\" &lt;&lt; endl; return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://zhumenger.top/categories/图论/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://zhumenger.top/tags/图论/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://zhumenger.top/tags/最小生成树/"}]},{"title":"编程俱乐部6月常规赛二题解","slug":"题解/编程俱乐部6月常规赛二题解","date":"2019-06-23T08:12:30.000Z","updated":"2019-06-23T08:19:57.049Z","comments":true,"path":"2019/06/23/题解/编程俱乐部6月常规赛二题解/","link":"","permalink":"http://zhumenger.top/2019/06/23/题解/编程俱乐部6月常规赛二题解/","excerpt":"","text":"编程俱乐部6月常规赛二题解一.魔法雪花 ****题解： 字符串的最小表示法：每一个字符串都有一个字典序最小的表示，比较这俩个字符串的最小表示是否相等即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;stdio.h&gt;using namespace std;string s1, s2;int n;int get(string s) //获得最小字典序的起始下标&#123; int i = 0, j = 1; while(i &lt;= n &amp;&amp; j &lt;= n) &#123; int k = 0; while(k &lt; n &amp;&amp; s[i + k] == s[j + k])k++; if(k == n)break; if(s[i + k] &lt; s[j + k])&#123; j = j + k + 1; if(i == j)j++; &#125; else &#123; i = i + k + 1; if(i == j)i++; &#125; &#125; return min(i, j);&#125;bool cmp(int i, int j) //比较字符串是否相同&#123; for(int k = 0; k &lt; n; k++)&#123; if(s1[i + k] != s2[j + k])return false; &#125; return true;&#125;int main()&#123; cin &gt;&gt; s1 &gt;&gt; s2; n = s1.size(); s1 += s1; //长度增加2倍 s2 += s2; int l = get(s1); int r = get(s2); if(cmp(l, r))&#123; cout &lt;&lt; \"Yes\" &lt;&lt; endl; for(int i = l; i &lt; l + n; i++) printf(\"%c\", s1[i]); &#125; else cout &lt;&lt; \"No\" &lt;&lt; endl; return 0;&#125; 二.魔仙彩石 题解：单调栈的运用，如果栈首的元素与a[i]相加&gt;m，就不断的弹出元素，直到a[i]与栈首的和&lt;=m或栈中的元素为空，让ans+=q[t]求出答案。 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int a[20010], q[20010], t = 0;int main()&#123; int n, m; long long int ans =0; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; sort(a, a + n); for(int i = 0; i &lt; n; i++)&#123; while(t &gt; 0 &amp;&amp; a[i] + a[q[t]] &gt;m)t--; if(t &gt; 0)ans += q[t] + 1; //单调栈的性质，该下标之前的元素与a[i]相加都小于等于m q[++t] = i; //单调栈记录下标 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; *三黑暗法阵 * 题解：经典的水池问题，如果该点为1，则让它等于0，继续往上下左右遍历，记录最大的ans即可 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;const int N = 110;int a[N][N];int dx[] = &#123;1, 0, -1, 0&#125;;int dy[] = &#123;0, 1, 0, -1&#125;;int n, m, res;void dfs(int x, int y)&#123; res++; a[x][y] = 0; for(int i = 0; i &lt; 4; i++)&#123; int xx = x + dx[i]; int yy = y + dy[i]; if(xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; m &amp;&amp; a[xx][yy] == 1) dfs(xx, yy); &#125;&#125;int main()&#123; while(cin &gt;&gt; n &gt;&gt; m)&#123; if(n == 0 &amp;&amp; m == 0)break; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) cin &gt;&gt; a[i][j]; int ans = 0; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j ++)&#123; if(a[i][j] == 1)&#123; res = 0; dfs(i, j); ans = max(ans, res); &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 四.女王搬水泥 题解： 最小生成树的题，将每条路的建造的时间从小到大排个序，依次遍历，如果都联通了输出当前的时间，break;如果遍历完一遍还没有全部联通，则输出-1 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e6 + 10;int f[N];struct p&#123; int a; int b; int c;&#125;arr[N];int Find(int x)&#123; if(x != f[x])f[x] = Find(f[x]); return f[x];&#125;bool cmp(p a, p b)&#123; return a.c &lt; b.c;&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) f[i] = i; for(int i = 0; i &lt; m; i++) cin &gt;&gt; arr[i].a &gt;&gt; arr[i].b &gt;&gt; arr[i].c; sort(arr, arr + m, cmp); int ans = 0, res = 1; for(int i = 0; i &lt; m; i++)&#123; int x = Find(arr[i].a); int y = Find(arr[i].b); if(x != y)&#123; res++; //记录联通了几个点 f[x] = y; &#125; if(res == n)&#123; //全部联通就输出当前的时间 ans = arr[i].c; break; &#125; &#125; if(res == n)cout &lt;&lt; ans &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; return 0;&#125; 五.游ne娃子的取石子游戏 题解:取三个最大的互质的数，得到的最小公倍数一定是最大的。如果n为奇数，三个最大的互质的数就是n, n - 1, n- 2。如果n为偶数， 需要判断一下n是否为3的倍数，如果不是，那么三个最大的互质的数就是n, n - 1, n - 3，如果是,那么三个最大的互质的数就是n - 1, n- 2， n - 3. 12345678910111213#include&lt;iostream&gt;using namespace std;int main()&#123; long long int n, ans; cin &gt;&gt; n; if(n % 2)cout &lt;&lt; n &lt;&lt; ' ' &lt;&lt; n - 1 &lt;&lt; ' ' &lt;&lt; n - 2 &lt;&lt; endl; else &#123; if(n % 3)cout &lt;&lt; n &lt;&lt; ' ' &lt;&lt; n - 1 &lt;&lt; ' ' &lt;&lt; n - 3 &lt;&lt; endl; else cout &lt;&lt; n - 1 &lt;&lt; ' ' &lt;&lt; n - 2 &lt;&lt; ' ' &lt;&lt; n - 3 &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://zhumenger.top/categories/题解/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://zhumenger.top/tags/题解/"}]},{"title":"图论之最短路问题","slug":"图论/最短路/图论之最短路问题","date":"2019-06-23T04:18:21.000Z","updated":"2019-07-09T06:14:17.387Z","comments":true,"path":"2019/06/23/图论/最短路/图论之最短路问题/","link":"","permalink":"http://zhumenger.top/2019/06/23/图论/最短路/图论之最短路问题/","excerpt":"","text":"图论之最短路问题1.什么是最短路： 从某顶点出发，沿图的边到达另一顶点所经过的路径中，各边上权值之和最小的一条路径 2.常用的最短路算法： Dijkstra算法，Bellman-Ford算法，Floyd算法和SPFA算法 3.最短路所有算法的适用情况以及时间复杂度，如下表所示。 算法详解一.Dijkstra算法1.朴素版的Dijkstra 简介： 每次找到已知的能够到达的一条最短的路径，并用这条路径更新它能够到达的所有的点，这样得到的路径一定是最短的，假设有n个点，那么我们就需要遍历n - 1次找到n - 1个边，每次用得到的最短的边依次更新其他可以到达的点。所以时间复杂度为O(n^2) 适用条件： 求单源最短路，并且所有的边都为正数。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1010, INF = 0x3f3f3f3f;int arr[N][N], n, m; //arr用来存边bool vis[N]; //判断边是否已经被选过int d[N]; //存储到每个点的距离void dijstra()&#123; d[1] = 0;//起点距离为1 for(int i = 0; i &lt;n - 1; i++)&#123; //遍历n - 1次，找到至少n -1 条边 int t = -1; for(int j = 1; j &lt;= n; j++)&#123; if(!vis[j] &amp;&amp; (t == -1 || d[t] &gt; d[j])) //找到已知的距离起点最短的一条路 t = j; &#125; for(int j = 1; j &lt;= n; j++) //用这条路径不断的更新到其他的点 d[j] = min(d[j], d[t] + arr[t][j]); //取最小值 vis[t] = true; //表示该点已经被选过了 &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; memset(arr, INF, sizeof arr); //初始化 memset(vis, false, sizeof vis); memset(d, INF, sizeof d); int a, b, c; for(int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; arr[a][b] = min(arr[a][b], c); //有可能给你多条相同的，所以要取最短的那条 &#125; dijstra(); if(d[n] == INF)cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; d[n] &lt;&lt; endl; return 0;&#125; 2.堆优化的Dijkstra： 主要是针对朴素版找到距离最小的一条路径用堆做了一个优化，我们可以用堆来储存已经更新过的点，每次取出堆中的最小的一条边即可，堆的时间复杂度为O(1)，所以在时间上要优化不少。 存图方式： 如果n和m非常大的话，比如1 &lt;= n, m &lt;= 1000000.用数组的方式肯定是存不下的，所以我们一般要用到邻接表的存图方式。也有很多人用vector动态数组来存，但当数据非常大时，vector动态数组开拓空间花费的时间也是非常大的，有的题就专门卡vector，所以邻接表最常用的一种存图方式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N = 1e5 + 10, INF = 0x3f3f3f3f;typedef pair&lt;int, int &gt; p;int h[N], e[N], ne[N], idx, w[N];//邻接表，由n个单链表组成，w[idx]用来存边权值int dis[N], n, m;bool vis[N];//判断这条边是否被选过void add(int a, int b, int c) //建图&#123; e[idx] = b, w[idx] = c, ne[idx]= h[a], h[a] = idx++;&#125;void dijstra()&#123; dis[1] = 0;//起点的距离为0 priority_queue&lt;p, vector&lt;p&gt;, greater&lt;p&gt; &gt; q; //优先队列 q.push(&#123;0, 1&#125;); while(q.size())&#123; p t = q.top(); q.pop(); int u = t.second, d = t.first; if(vis[u])continue; vis[u] = true; for(int i = h[u]; i != -1; i = ne[i])&#123;//遍历每一条边 int j = e[i]; if(dis[j] &gt; d + w[i])&#123;//不断更新为最短距离 dis[j] = d + w[i]; q.push(&#123;dis[j], j&#125;);//放入到队列中 &#125; &#125; &#125;&#125;int main()&#123; memset(dis, INF, sizeof dis);//初始化 memset(vis, false, sizeof vis); memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m; int a, b, c; while(m--)&#123; cin &gt;&gt; a&gt;&gt; b &gt;&gt; c; add(a, b, c); &#125; dijstra(); if(dis[n] == INF)cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; dis[n] &lt;&lt;endl; return 0;&#125; 二.bellman-ford算法简介： 循环n次，每次遍历所有的边，遍历的同时，不断更新a到b的最短距离即dis[b] = min(dis[b], backup[a] + w)，循环完一遍后，得到的所有路径一定满足dis[b] &lt;= dis[a] + w[i] 适用条件： 可以用来判断是否存在负边，时间复杂度为O(nm)，一般情况下不会用到这个算法，常用来求有边数限制的最短路问题，用结构体存储所有的边即可， 代码如下： 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10, INF = 0x3f3f3f3f;int n, m, k;int dis[N], backup[N];struct p&#123; //结构体存边 int a, b, c;&#125;arr[N];void bellman_ford()&#123; memset(dis, INF, sizeof dis); dis[1] = 0; for(int i = 0; i &lt; k; i++)&#123; //限制条件为k条边 memcpy(backup, dis, sizeof dis); //防止出现连锁反应，所以这里的用backup将上一次的最 //短路备份一下 for(int j = 0; j &lt; m; j++)&#123;//遍历所有的边 int a = arr[j].a, b = arr[j].b, w = arr[j].c; dis[b] = min(dis[b], backup[a] + w);//更新 &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 0; i &lt; m; i++) cin &gt;&gt; arr[i].a &gt;&gt; arr[i].b &gt;&gt; arr[i].c; bellman_ford(); if(dis[n] &gt; INF / 2)cout &lt;&lt; \"impossible\" &lt;&lt; endl; //有可能有负权边，所以要大于INF/2 else cout &lt;&lt; dis[n] &lt;&lt; endl; return 0;&#125; 三.spfa算法简介： spfa算法是对bellman-ford算法的一个优化，要想dis[b]变小，前提一定是dis[a]变小了，所以我们用队列来存储已经更新过的点，再用该点不断去更新其他的点，原理跟dijstra算法类似 如何判断负环 用一个变量cnt[i]表示到达 i 这个点的最短路径中经过了多少条边，如果cnt[i] &gt;= n表示有至少经过了n条边，那么就说明至少多走了一条边，那么这条边一定是一个负环。 适用条件： 用来求最短路以及判断是否存在负环，时间复杂度为O(m) 1.spaf算法求最短路 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N = 1e6 + 10, INF = 0x3f3f3f3f;int h[N], e[N], ne[N], w[N], idx;//邻接表存图int n, m;int dis[N];bool vis[N]; //vis含义跟dijstra算法中的不太一样，在这里表示当前这个点是否在队列当中void add(int a, int b, int c)//建边&#123; e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;&#125;void spfa()&#123; memset(dis, INF, sizeof dis); dis[1] = 0; //起点距离为0 queue&lt;int&gt; q; q.push(1); //将1放入队列 while(q.size())&#123; int u = q.front(); q.pop(); vis[u] = false; //表示u不在这个队列中 for(int i = h[u]; i != -1; i = ne[i])&#123; //遍历所有能够到达的点 int v = e[i]; if(dis[v] &gt; dis[u] + w[i])&#123; //更新距离 dis[v] = dis[u] + w[i]; if(!vis[v])&#123; //如果不在队列中 q.push(v); //放入队列 vis[v] = true;//表示v已经在队列当中 &#125; &#125; &#125; &#125;&#125;int main()&#123; memset(h, -1, sizeof h);//初始化 memset(vis, false, sizeof vis); cin &gt;&gt; n &gt;&gt; m; int a, b, c; while(m--)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); &#125; spfa(); if(dis[n] == INF)cout &lt;&lt; \"impossible\" &lt;&lt; endl; else cout &lt;&lt; dis[n] &lt;&lt; endl;&#125; 2.spfa判断是否存在负环 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N = 1e6 + 10, INF = 0x3f3f3f3f;int h[N], e[N], ne[N], w[N], idx;int dis[N], cnt[N]; //cnt[i]表示到达i这个点经过了多少条边bool vis[N];int n, m;void add(int a, int b, int c)&#123; e[idx] = b, w[idx]= c, ne[idx] = h[a], h[a] = idx++;&#125;bool spfa()&#123; queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i++)&#123;//因为不知道负环出现在哪一个起点，所以要将所有的点放入到队列中 vis[i] = true; q.push(i); &#125; while(q.size())&#123; int u = q.front(); q.pop(); vis[u] = false; for(int i = h[u]; i != -1; i = ne[i])&#123; int v = e[i]; if(dis[v] &gt; dis[u] + w[i])&#123; dis[v] = dis[u] +w[i]; cnt[v] = cnt[u] + 1; //边数+1 if(cnt[v] &gt;= n)return true; //如果大于n说明一定存在负环 if(!vis[v])&#123; q.push(v); vis[v] = true; &#125; &#125; &#125; &#125; return false;&#125;int main()&#123; memset(dis, INF, sizeof dis); memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m; int a, b, c; while(m--)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); &#125; if(spfa())puts(\"Yes\"); else puts(\"No\"); return 0;&#125; 四.floyd算法简介： 从任意节点A到任意节点B的最短路径不外乎2种可能，1是直接从A到B，2是从A经过若干个节点到B，所以，我们假设dist(AB)为节点A到节点B的最短路径的距离，对于每一个节点K，我们检查dist(AK) + dist(KB) &lt; dist(AB)是否成立，如果成立，证明从A到K再到B的路径比A直接到B的路径短，我们便设置 dist(AB) = dist(AK) + dist(KB)，这样一来，当我们遍历完所有节点K，dist(AB)中记录的便是A到B的最短路径的距离。 适用条件 能求出任意俩条边的最短路，时间复杂度为O(n^3) 代码如下： 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;const int N = 210, INF = 0x3f3f3f3f;int arr[N][N];int main()&#123; int n ,m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) arr[i][j] = i == j ? 0 : INF; //初始化 int a, b, c; for(int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; arr[a][b] = min(arr[a][b], c); &#125; //floyd算法核心 for(int k = 1; k &lt;= n; k++) for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) arr[i][j] = min(arr[i][j], arr[i][k] + arr[k][j]); while(k--)&#123; cin &gt;&gt; a &gt;&gt; b; if(arr[a][b] &gt; INF / 2)puts(\"impossible\");//可能有负环，所以这里是大于INF/2 else cout &lt;&lt; arr[a][b] &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://zhumenger.top/categories/图论/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://zhumenger.top/tags/图论/"},{"name":"最短路问题","slug":"最短路问题","permalink":"http://zhumenger.top/tags/最短路问题/"}]},{"title":"八数码(bfs)","slug":"搜索/八数码","date":"2019-06-21T13:22:10.000Z","updated":"2019-06-21T15:09:15.721Z","comments":true,"path":"2019/06/21/搜索/八数码/","link":"","permalink":"http://zhumenger.top/2019/06/21/搜索/八数码/","excerpt":"","text":"在一个3×3的网格中，1~8这8个数字和一个“X”恰好不重不漏地分布在这3×3的网格中。 例如： 1 2 3X 4 67 5 8 在游戏过程中，可以把“X”与其上、下、左、右四个方向之一的数字交换（如果存在）。 我们的目的是通过交换，使得网格变为如下排列（称为正确排列）： 1 2 34 5 67 8 X 例如，示例中图形就可以通过让“X”先后与右、下、右三个方向的数字交换成功得到正确排列。 交换过程如下： 1 2 3 1 2 3 1 2 3 1 2 3X 4 6 4 X 6 4 5 6 4 5 67 5 8 7 5 8 7 X 8 7 8 X 现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换。 输入格式输入占一行，将3×3的初始网格描绘出来。 例如，如果初始网格如下所示：1 2 3 x 4 6 7 5 8 则输入为：1 2 3 x 4 6 7 5 8 输出格式输出占一行，包含一个整数，表示最少交换次数。 如果不存在解决方案，则输出”-1”。 输入样例： 2 3 4 1 5 x 7 6 8 输出样例 19 题解：图的最短路问题，肯定要用到bfs, 可以将这个图转化为一个字符串,终点状态就是到达特定字符串”12345678x”，最先到达的一定是最短的 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;unordered_map&gt;using namespace std;unordered_map&lt;string, int &gt; d; //字符串哈希来表示到达该字串的距离string End, cur;int dx[] = &#123;0, 1, 0, -1&#125;;int dy[] = &#123;1, 0, -1, 0&#125;;int bfs()&#123; End = \"12345678x\"; d[cur] = 0; queue&lt;string &gt;q; q.push(cur); while(q.size())&#123; string u = q.front(); if(u == End)return d[u];//如果找到了，返回距离 int distance = d[u]; q.pop(); int x = u.find('x'); //在字符串里找到x int i = x / 3, j = x % 3; //得到x在图里的行和列 for(int k = 0; k &lt; 4; k++)&#123; //上下左右4个方向交换 int xx = i + dx[k]; int yy = j + dy[k]; if(xx &gt;= 0 &amp;&amp; xx &lt; 3 &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; 3)&#123; swap(u[x], u[xx * 3 + yy]);//交换 if(!d.count(u))&#123; //如果该字符串没有出现过，放入到队列中 d[u] = distance + 1; q.push(u); &#125; swap(u[x], u[xx * 3 + yy]); //恢复 &#125; &#125; &#125; return -1;&#125;int main()&#123; char ch; for(int i = 0; i &lt; 9; i++)&#123; cin &gt;&gt; ch; cur += ch; &#125; cout &lt;&lt; bfs() &lt;&lt; endl; return 0;&#125;","categories":[{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/categories/搜索/"}],"tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"dfs和bfs简介","slug":"搜索/dfs和bfs简介","date":"2019-06-15T16:03:24.000Z","updated":"2019-07-07T03:07:36.178Z","comments":true,"path":"2019/06/16/搜索/dfs和bfs简介/","link":"","permalink":"http://zhumenger.top/2019/06/16/搜索/dfs和bfs简介/","excerpt":"","text":"dfs和bfs简介一.深度优先遍历(dfs)本质： 通过递归的方式遍历图中的每一个点。 遍历流程： 从起点开始，在其一条分支上一条路走到黑，走不通了就开始往回走，只要当前有分支就继续往下走，直到将所有的点遍历一遍。 剪枝： 如果已经确定这条路没有我们想要的答案，那么就不用继续在这条路上走下去了，于是我们就开始走其他的分支或者往回走，这样节省时间的方法称之为剪枝。 回溯： 当我们一条路走到头，往回走时，就叫做回溯。 恢复现场： 当我们回溯的时候，原来这个图是什么样的，我们还要变回什么样。这是一个好习惯，我们用了什么东西，就需要还回什么东西。这样做的目的： 当我们遍历完这条分支，去遍历下一条分支的时候，我们需要保证当前图其他条件的一致性，也就是遍历每一条分支的时候，当前图的状态都是一样的。保证遍历每一条分支的时候都是公平的。 下面是流程图： 二.广度优先遍历(bfs)遍历流程： 逐层逐层的遍历，先遍历第一层，再遍历第二层…，也就是遍历当前节点所能到达的所有子节点。直到遍历所有的点。不存在剪枝，回溯和恢复现场的操作。 流程图如下： 三.对比dfs和bfs时间复杂度： dfs: 因为我们需要枚举没一个点，以及每一条边，所示它的时间复杂度为O(n + e) 即点的个数+边的个数 bfs:跟dfs时间复杂度一样，都为O(n + e) 不同的是对每个点的访问顺序是不一样的 用到的数据结构： dfs: stack bfs: queue 空间复杂度： dfs: O(h) h为树的深度 bfs: O(2^h) 特性： dfs: 不具有最短性 bfs: 具有最短性","categories":[{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/categories/搜索/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"},{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"有向图的拓扑排序(bfs)","slug":"搜索/有向图的拓扑排序","date":"2019-06-15T01:20:57.000Z","updated":"2019-06-15T01:52:49.694Z","comments":true,"path":"2019/06/15/搜索/有向图的拓扑排序/","link":"","permalink":"http://zhumenger.top/2019/06/15/搜索/有向图的拓扑排序/","excerpt":"","text":"题目描述 给定一个n个点m条边的有向图，图中可能存在重边和自环。 请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出-1。 若一个由图中所有点构成的序列A满足：对于图中的每条边(x, y)，x在A中都出现在y之前，则称A是该图的一个拓扑序列。 输入格式 第一行包含两个整数n和m 接下来m行，每行包含两个整数x和y，表示点x和点y之间存在一条有向边(x, y)。 输出格式 共一行，如果存在拓扑序列，则输出拓扑序列。 否则输出-1。 数据范围 1≤n,m≤10^5, 1≤n,m≤10^5 输入样例： 3 31 22 31 3 输出样例： 1 2 3 拓扑序列简介： 若一个由图中所有点构成的序列A满足：对于图中的每条边(x, y)，x在A中都出现在y之前，则称A是该图的一个拓扑序列。范围是有向图， 无向图是没有拓扑排序的。 入度： 有多少个点指向该元素，就表示该元素的入度是多少。 初出度： 该元素指向了多少个点，就表示该元素的出度是多少、 拓扑序列的起点： ​ 因为入度为0的点，没有其他的点指向它，所以它一定是一个起点，如果入度为0的点有多个，那么该拓扑序列不唯一，如果没有入度为0的点，也就是这个图是一个环，那么它没有拓扑排序。所以我们要求拓扑序列，那么该图一定是一个有向无环图 如何求拓扑序列： ​ 将入度为0的点加入队列当中，每次从入度为0的点开始遍历它的每一个子节点，不断删去前一个点，并且该节点的入度–，如果入度为0,则加入队列当中，在删去节点的同时用一个数组来存储该拓扑排序的顺序，最后输出答案即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int h[N], e[N], ne[N], idx;//邻接表int d[N], n ,m;//入度vector&lt;int &gt; ans;void add(int a, int b)//邻接表建图&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;int bfs()&#123; queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i++) if(!d[i])q.push(i); //将入度为0的点入队 while(q.size())&#123; int u = q.front(); q.pop(); ans.push_back(u); //储存该拓扑排序 for(int i = h[u]; i != -1; i = ne[i])&#123; int s = e[i]; d[s]--; if(!d[s])q.push(s); &#125; &#125; return (ans.size() == n); //判断是否所有的点都已经入队&#125;int main()&#123; int a, b; memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; a &gt;&gt; b; add(a, b); d[b]++; //入度++ &#125; if(bfs())&#123; for(int i = 0; i &lt; ans.size(); i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; cout &lt;&lt; endl; &#125; else cout &lt;&lt; -1 &lt;&lt; endl; return 0;&#125;","categories":[{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/categories/搜索/"}],"tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"树与图的广度优先遍历(bfs)","slug":"搜索/树与图的广度优先遍历","date":"2019-06-15T01:11:29.000Z","updated":"2019-06-15T01:19:40.832Z","comments":true,"path":"2019/06/15/搜索/树与图的广度优先遍历/","link":"","permalink":"http://zhumenger.top/2019/06/15/搜索/树与图的广度优先遍历/","excerpt":"","text":"题目描述 给定一个n个点m条边的有向图，图中可能存在重边和自环。 所有边的长度都是1，点的编号为1~n。 请你求出1号点到n号点的最短距离，如果从1号点无法走到n号点，输出-1。 输入格式 第一行包含两个整数n和m。 接下来m行，每行包含两个整数a和b，表示存在一条从a走到b的长度为1的边。 输出格式 输出一个整数，表示1号点到n号点的最短距离。 数据范围 1≤n,m≤10^5, 1≤n,m≤10^5 输入样例： 4 51 22 33 41 31 4 输出样例： 1 题解： 找图的最短路，所以用到的一定是bfs,首先将起点入队，然后不断的弹出队列元素，让该元素的所有没有走过的叶子节点的距离+1, 然后让子节点入队，直到弹出队首元素为n，这样最先得到的距离一定是最短的。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 +10;int e[N], h[N], ne[N], idx;int d[N], n, m;queue&lt;int&gt; q;void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;void bfs()&#123; d[1] = 0; q.push(1); while(q.size())&#123; int u = q.front(); q.pop(); if(u == n)break; for(int i = h[u]; i != -1; i = ne[i])&#123; int s = e[i]; if(d[s] == -1)&#123; d[s] = d[u] + 1; q.push(s); &#125; &#125; &#125;&#125;int main()&#123; int a, b; memset(d, -1, sizeof d); memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; a &gt;&gt; b; add(a, b); &#125; bfs(); cout &lt;&lt; d[n] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/categories/搜索/"}],"tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"迷宫问题(bfs)","slug":"搜索/迷宫问题","date":"2019-06-14T15:37:25.000Z","updated":"2019-06-14T16:10:56.581Z","comments":true,"path":"2019/06/14/搜索/迷宫问题/","link":"","permalink":"http://zhumenger.top/2019/06/14/搜索/迷宫问题/","excerpt":"","text":"题目描述给定一个n*m的二维整数数组，用来表示一个迷宫，数组中只包含0或1，其中0表示可以走的路，1表示不可通过的墙壁。 最初，有一个人位于左上角(1, 1)处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。 请问，该人从左上角移动至右下角(n, m)处，至少需要移动多少次。 数据保证(1, 1)处和(n, m)处的数字为0，且一定至少存在一条通路。 输入格式 第一行包含两个整数n和m。 接下来n行，每行包含m个整数（0或1），表示完整的二维数组迷宫。 输出格式 输出一个整数，表示从左上角移动至右下角的最少移动次数。 数据范围 1≤n,m≤1001≤n,m≤100 输入样例： 5 50 1 0 0 00 1 0 1 00 0 0 0 00 1 1 1 00 0 0 1 0 输出样例： 8 题解： 经典的bfs问题：bfs有最短路的性质，如果每条边的边权值都是1的话，bfs最先遍历到的点离起点的距离一定是最短的，所以我们可以用bfs来做这道题，用队列的方法是bfs的主要特征。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int N = 1000, INF = 0x3f3f3f3f;int a[N][N], d[N][N]; //a数组用来存图， d数组表示距离int dx[] = &#123;0, 1, 0, -1&#125;;//往上下左右4个方向遍历int dy[] = &#123;1, 0, -1, 0&#125;; int n ,m;typedef pair&lt;int ,int &gt;P;queue&lt;P&gt; q;void bfs()&#123; memset(d, INF, sizeof d); //将开始的距离都初始化为最大值， d[1][1] = 0; //起点的距离为0 q.push(&#123;1, 1&#125;); while(q.size())&#123; P cur = q.front(); q.pop(); if(cur.first == n &amp;&amp; cur.second == m)&#123; cout &lt;&lt; d[n][m] &lt;&lt; endl; break; &#125; //4个方向遍历 for(int i = 0; i &lt; 4; i++)&#123; int x = cur.first + dx[i]; int y = cur.second + dy[i]; if(x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m &amp;&amp; d[x][y] == INF &amp;&amp; a[x][y] == 0)&#123;//x，y一定是合法的 &amp;&amp; 判断这条路是否可通 &amp;&amp; 判断这条路是否已经走过了 d[x][y] = d[cur.first][cur.second] +1; //距离+1 q.push(&#123;x, y&#125;);//放入到队列中 &#125; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) cin &gt;&gt; a[i][j]; bfs(); return 0;&#125;","categories":[{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/categories/搜索/"}],"tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"n-皇后问题(dfs)","slug":"搜索/n-皇后问题","date":"2019-06-14T15:25:28.000Z","updated":"2019-07-07T03:07:50.225Z","comments":true,"path":"2019/06/14/搜索/n-皇后问题/","link":"","permalink":"http://zhumenger.top/2019/06/14/搜索/n-皇后问题/","excerpt":"","text":"题目描述n-皇后问题是指将 n 个皇后放在 n∗n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。 现在给定整数n，请你输出所有的满足条件的棋子摆法。 输入格式 共一行，包含整数n。 输出格式 每个解决方案占n行，每行输出一个长度为n的字符串，用来表示完整的棋盘状态。其中”.”表示某一个位置的方格状态为空，”Q”表示某一个位置的方格上摆着皇后。每个方案输出完成后，输出一个空行。 数据范围 1≤n≤9 输入样例： 4 输出样例： .Q..…QQ…..Q. ..Q.Q……Q.Q.. 题解：经典的n皇后问题:dfs深搜每一行，用col[J]， dg[J], udg[J]数组分别来标记第J列， 正对角线， 反对角线是否有皇后，如果有我们就剪掉， 否则就把皇后放到该位置。代码如下： 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;const int N = 20;int arr[N][N], col[N], dg[N], udg[N], n; void dfs(int cur)&#123; if(cur == n)&#123; //如果放了n个皇后，直接输出 for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(arr[i][j])cout &lt;&lt; 'Q'; else cout &lt;&lt; '.'; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl; return ; &#125; for(int i = 0; i &lt; n; i++)&#123; if(col[i] || dg[cur + i] ||udg[n - cur + i])continue; //如果有了皇后，剪枝 arr[cur][i] = col[i] = dg[cur + i] = udg[n - cur + i] = 1; dfs(cur + 1); arr[cur][i] = col[i] = dg[cur + i] = udg[n - cur + i] = 0; //恢复现场 &#125;&#125;int main()&#123; cin &gt;&gt; n; dfs(0); return 0;&#125;","categories":[{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/categories/搜索/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"树的重心(dfs)","slug":"搜索/树的重心","date":"2019-06-14T09:50:40.000Z","updated":"2019-06-14T13:31:40.286Z","comments":true,"path":"2019/06/14/搜索/树的重心/","link":"","permalink":"http://zhumenger.top/2019/06/14/搜索/树的重心/","excerpt":"","text":"题目描述 给定一颗树，树中包含n个结点（编号1~n）和n-1条无向边。请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。 输入格式 第一行包含整数n，表示树的结点数。接下来n-1行，每行包含两个整数a和b，表示点a和点b之前存在一条边。 输出格式 输出一个整数m，表示重心的所有的子树中最大的子树的结点数目。 数据范围 1≤n≤105 输入样例 91 21 71 42 82 54 33 94 6 输出样例： 4 解题思路：这道题就是树的深度优先遍历，我们只需套用模板，遍历每个点的同时，返回该子树的点的个数，以及计算去掉该点时连通块点的最大值即可，最后用ans取去掉每个点之后的最大联通块的最小值就是最后的答案。具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int h[N], e[N], ne[N], idx, n;int ans = N; //答案bool vis[N]; //判断是否遍历过void add(int a, int b) //邻接表存树与图&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;int dfs(int cur)&#123; vis[cur] = true; int res = 0, sum = 1; //res表示去掉cur这个节点，联通块点的最大值， sum表示该子树点的个数 for(int i = h[cur]; i != -1; i = ne[i])&#123; //遍历树 int u = e[i]; if(!vis[u])&#123; int s = dfs(u); res = max(res, s); sum += s; &#125; &#125; res = max(res, n - sum); // sum是该子树的点的个数， n - sum表示它的父节点所连接的联通块点的个数 ans = min(res, ans); //取最大连通块点的最小值 return sum;&#125;int main()&#123; int a, b; cin &gt;&gt; n; //初始化 memset(h, -1, sizeof h); memset(vis, false, sizeof vis); for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; a &gt;&gt; b; //建树，双向图 add(a, b); add(b, a); &#125; dfs(1); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/categories/搜索/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"树与图的深度优先遍历(dfs)","slug":"搜索/树与图的深度优先遍历","date":"2019-06-14T09:47:20.000Z","updated":"2019-07-07T03:08:27.865Z","comments":true,"path":"2019/06/14/搜索/树与图的深度优先遍历/","link":"","permalink":"http://zhumenger.top/2019/06/14/搜索/树与图的深度优先遍历/","excerpt":"","text":"树与图的深度优先遍历:树其实也是图的一种图: 分为有向图和无向图图的储存: 第一种：邻接矩阵，就是一个二维数组，缺点：当点和边特别多的时候，存不下，一般用的比较少，而且非常浪费空间第二种：邻接表:由n个单链表组成，也可以用vector动态数组来实现，但vector有很大的缺点，当点和边非常大时，用vector动态数组的方法很容易超时，所以我们常用n个但链表的方式来存储图 邻接表如何存图呢：假设有这样一个图:那么我们可以给每个节点开一个单链表，如下图所示：这样我们就把图用邻接表的方法存了下来树与图深度优先遍历的大致流程：一条路走到黑，直到撞到南墙，走不通了，然后往回走，只要有分支就继续往下走，示例图如下: 树与图的遍历模板： 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int h[N], e[N], ne[N], idx, n;//这里跟单链表一样，只不过这里是N个头节点，H[N]bool vis[N]; //判断是否遍历过void add(int a, int b) //邻接表存树与图&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;void dfs(int cur)&#123; vis[cur] = true; for(int i = h[cur]; i != -1; i = ne[i])&#123; //遍历树 int u = e[i]; if(!vis[u])&#123; dfs(u); &#125; &#125;&#125;int main()&#123; int a, b; cin &gt;&gt; n; //初始化 memset(h, -1, sizeof h); memset(vis, false, sizeof vis); for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; a &gt;&gt; b; //建树，双向图 add(a, b); add(b, a); &#125; dfs(1); return 0;&#125; 这样我们就遍历了每个点。","categories":[{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/categories/搜索/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"字符串哈希","slug":"数据结构基础/字符串哈希","date":"2019-06-13T01:45:46.000Z","updated":"2019-06-14T15:51:18.497Z","comments":true,"path":"2019/06/13/数据结构基础/字符串哈希/","link":"","permalink":"http://zhumenger.top/2019/06/13/数据结构基础/字符串哈希/","excerpt":"","text":"字符串哈希：简介：为了方便的找到某个字符串，我们可以把该字符串转化为一个数值，每一个字符串都有一个唯一确定的编号，这样在绝大多数情况下可以在O(1)的时间复杂度中完成对字符串元素的查找 字符串哈希函数：为每一个字符串赋予唯一确定的数值或编号。 题目描述 给定一个长度为n的字符串，再给定m个询问，每个询问包含四个整数l1,r1,l2,r2l1,r1,l2,r2，请你判断[l1,r1l1,r1]和[l2,r2l2,r2]这两个区间所包含的字符串子串是否完全相同。 字符串中只包含大小写英文字母和数字。 输入格式 第一行包含整数n和m，表示字符串长度和询问次数。 第二行包含一个长度为n的字符串，字符串中只包含大小写英文字母和数字。 接下来m行，每行包含四个整数l1,r1,l2,r2l1,r1,l2,r2，表示一次询问所涉及的两个区间。 注意，字符串的位置从1开始编号。 输出格式 对于每个询问输出一个结果，如果两个字符串子串完全相同则输出“Yes”，否则输出“No”。 每个结果占一行。 数据范围 1≤n,m≤1051≤n,m≤105 输入样例： 8 3aabbaabb1 3 5 71 3 6 81 2 1 2 输出样例： YesNoYes 代码如下： 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef unsigned long long ULL;const int N = 1e6 + 10, base = 131;ULL h[N], p[N];char s[N];ULL solve(int l, int r)&#123; return h[r] - h[l - 1] * p[r - l + 1];&#125;int main()&#123; int n, m; int a, b, c, d; cin &gt;&gt; n &gt;&gt; m; cin &gt;&gt; (s + 1); p[0] = 1; for(int i = 1; i &lt;= n; i++) &#123; h[i] = h[i - 1] * base + s[i] - 'a' + 1; p[i] = p[i - 1] * base; &#125; while(m--)&#123; cin &gt;&gt; a&gt;&gt; b &gt;&gt; c &gt;&gt; d; if(solve(a, b) == solve(c, d))cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"字符串哈希","slug":"字符串哈希","permalink":"http://zhumenger.top/tags/字符串哈希/"}]},{"title":"哈希表(散列表)","slug":"数据结构基础/哈希表-散列表","date":"2019-06-11T16:08:08.000Z","updated":"2019-06-13T03:21:42.542Z","comments":true,"path":"2019/06/12/数据结构基础/哈希表-散列表/","link":"","permalink":"http://zhumenger.top/2019/06/12/数据结构基础/哈希表-散列表/","excerpt":"","text":"简介：哈希表又称为散列表，是实现字典操作的一种有效的数据结构。通过哈希函数将关键字映射到表中的某个位置上进行存放，以实现快速插入和查询的。时间复杂度可达到O(n).为什么要用到哈希：比如说有n(1&lt;=n&lt;=1e6)个数,当给你一个非常大的数时，为了方便查找这个数是否出现过，我们可以给这个数重新编号到1~n，这样我们就可以快速的找到想要的答案。 题目描述 维护一个集合，支持如下几种操作：“I x”，插入一个数x；“Q x”，询问数x是否在集合中出现过；现在要进行N次操作，对于每个询问操作输出对应的结果。 输入格式 第一行包含整数N，表示操作数量。接下来N行，每行包含一个操作指令，操作指令为”I x”，”Q x”中的一种。 输出格式 对于每个询问指令“Q x”，输出一个询问结果，如果x在集合中出现过，则输出“Yes”，否则输出“No”。每个结果占一行。 数据范围 1≤N≤105−109≤x≤109 输入样例： 5I 1I 2I 3Q 2Q 5 输出样例： YesNo 题解： 拉链法： ​ 先找出编号的数据范围MOD，最好是一个质数，这样冲突的几率是最小的，让输入的数字x%mod，这样就可以让x重新编号到0~mod - 1， 有的时候我们得到的余数是一样的，我们可以以这个余数为head， 把这些余数相同的储存到一个链表当中，具体代码如下： 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10, mod = 100003;int h[N], e[N], ne[N], idx = 1;void insert(int x)&#123; int k = (x % mod + mod) % mod; //得到余数head e[idx] = x, ne[idx] = h[k], h[k] = idx++;//在以head为头结点的链表中插入数值&#125;bool Find(int x)&#123; int k = (x % mod + mod) % mod; for(int i = h[k]; i != -1; i = ne[i]) //在以head为头结点的链表中查找x if(e[i] == x)return true; return false;&#125;int main()&#123; int n, x; string s; memset(h, -1, sizeof h); cin &gt;&gt; n; while(n--)&#123; cin &gt;&gt; s &gt;&gt;x; if(s == \"I\")&#123; insert(x); &#125; else &#123; if(Find(x))cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; &#125; return 0;&#125; 开放寻址法： ​ 这种方法也是先让x对mod取模， 得到x应该去到哪个坑里，如果这个坑已经被占了，就继续往下遍历直到寻找到一个没有人的坑位，数据范围往往开到n的俩到三倍。 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 200003, Max = 0x3f3f3f3f;int h[N];int Find(int x)&#123; int k = (x % N + N) % N; //取模 while(h[k] != Max &amp;&amp; h[k] != x)&#123; //找到一个没有人的坑位 k++; if(k == N)k = 0; //如果到头了，就从0重新开始遍历，因为一共就只有n个数，所以肯定有剩余的 //坑位供x使用 &#125; return k; //返回坑位的下标&#125;int main()&#123; int n, x; string s; cin &gt;&gt; n; memset(h, Max, sizeof h);//初始化，开始的时候都没有人 while(n--)&#123; cin &gt;&gt; s &gt;&gt; x; if(s == \"I\")&#123; int k = Find(x); h[k] = x; //把x放到该坑位 &#125; else &#123; int k = Find(x); if(h[k] != Max)cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"哈希","slug":"哈希","permalink":"http://zhumenger.top/tags/哈希/"}]},{"title":"最大异或对","slug":"数据结构基础/最大异或对","date":"2019-06-11T03:37:08.000Z","updated":"2019-06-11T03:45:19.192Z","comments":true,"path":"2019/06/11/数据结构基础/最大异或对/","link":"","permalink":"http://zhumenger.top/2019/06/11/数据结构基础/最大异或对/","excerpt":"","text":"Acwing-&gt;143.最大异或对 题目描述在给定的N个整数A1，A2……AN中选出两个进行xor（异或）运算，得到的结果最大是多少？ 输入格式 第一行输入一个整数N。第二行输入N个整数A1～AN。 输出格式 输出一个整数表示答案。 数据范围 1≤N≤105,0≤Ai&lt;231 输入样例： 31 2 3 输出样例： 3题解：异或+前缀+字典树其实来说,一个整数,是可以转化成为一个32位的二进制数,而也就可以变成长度为32位的二进制字符串.既然如此话,那么我们可以这么做,每一次检索的时候,我们都走与当前Ai的二进制位的数值相反的位置走,这样就可以让Xor值最大,如果说没有路可以走的话,那么就走相同的路.时间复杂度：位数*n，所以是O(32 * n) 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int a[N], trie[N * 32][5], idx;void insert(int x) //建树&#123; int p = 1; for(int i = 30; i &gt;= 0; i--)&#123; int u = x &gt;&gt; i &amp; 1; if(!trie[p][u])trie[p][u] = idx++; p = trie[p][u]; &#125;&#125;int search(int x)//找最大的&#123; int p = 1, ans = 0; for(int i = 30; i &gt;= 0; i--)&#123; int u = x &gt;&gt; i &amp;1; if(trie[p][u^1])&#123; p = trie[p][u^1]; ans +=(1 &lt;&lt; i); &#125; else p = trie[p][u]; &#125; return ans;&#125;int main()&#123; int n; cin &gt;&gt; n; idx =2; for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; a[i]; insert(a[i]); &#125; int res = 0; for(int i = 0; i &lt; n; i++)res = max(res, search(a[i])); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"Trie","slug":"Trie","permalink":"http://zhumenger.top/tags/Trie/"}]},{"title":"Trie-字典树","slug":"数据结构基础/Trie-字典树","date":"2019-06-11T00:57:01.000Z","updated":"2019-06-23T08:24:31.227Z","comments":true,"path":"2019/06/11/数据结构基础/Trie-字典树/","link":"","permalink":"http://zhumenger.top/2019/06/11/数据结构基础/Trie-字典树/","excerpt":"","text":"Trie(字典树): 一种用于实现字符串快速检索的多叉树结构 Trie插入： 当需要插入一个字符串s时，我们令一个指针P起始指向根节点。然后，依次扫描S中的每个字符c：若P的c字符指针指向一个已经存在的节点Q，则令P = Q。若P的c字符指针指向空，则新建一个节点Q，令P的c字符指针指向Q，然后令P = Q。当S中的字符扫描完毕时，在当前节点P上标记它是一个字符串的结尾。 检索： 当需要检索一个字符串S在Trie中是否存在时，我们令一个指针P起初指向根节点，然后依次扫描S中的每个字符c：若P的c字符指针指向空，则说明S没有被插入过Trie，结束检索。若P的c字符指针指向一个已经存在的节点Q，则令P = Q。当S中的字符扫描完毕时，若当前节点P被标记为一个字符串的结尾，则说明S在Trie中存在，否则说明S没有被插入过Trie。 问题描述 “I x”向集合中插入一个字符串x；“Q x”询问一个字符串在集合中出现了多少次。共有N个操作，输入的字符串总长度不超过 105，字符串仅包含小写英文字母。 输入格式 第一行包含整数N，表示操作数。接下来N行，每行包含一个操作指令，指令为”I x”或”Q x”中的一种。 输出格式 对于每个询问指令”Q x”，都要输出一个整数作为结果，表示x在集合中出现的次数。每个结果占一行。 数据范围 1≤N≤2∗104 输入样例： 5I abcQ abcQ abI abQ ab 输出样例： 101 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int trie[N][26], cnt[N], idx;char str[N], c;void insert(char *str)&#123; int len = strlen(str), p = 1; //从根节点开始 for(int i = 0; i &lt; len; i++)&#123; int u = str[i] - 'a'; if(!trie[p][u])//如果没有节点，便创造一个节点 trie[p][u] = idx++; //对每个字符串进行编号 p = trie[p][u]; //p等于该节点，继续往下遍历 &#125; cnt[p]++;// 统计编号为p的字符串的个数&#125;int search(char *str)&#123; int len = strlen(str), p = 1; for(int i = 0; i &lt; len; i++)&#123; int u = str[i] - 'a'; if(!trie[p][u])return 0; //如果该节点为空，说明该字符串没有出现 p = trie[p][u]; &#125; return cnt[p];&#125;int main()&#123; int n; cin &gt;&gt; n; idx = 1; while(n--)&#123; cin &gt;&gt; c &gt;&gt; str; if(c == 'I')insert(str); else cout &lt;&lt; search(str) &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"Trie","slug":"Trie","permalink":"http://zhumenger.top/tags/Trie/"}]},{"title":"单链表","slug":"数据结构基础/单链表","date":"2019-06-10T14:32:06.000Z","updated":"2019-06-10T14:33:06.797Z","comments":true,"path":"2019/06/10/数据结构基础/单链表/","link":"","permalink":"http://zhumenger.top/2019/06/10/数据结构基础/单链表/","excerpt":"","text":"题目描述实现一个单链表，链表初始为空，支持三种操作： (1) 向链表头插入一个数； (2) 删除第k个插入的数后面的数； (3) 在第k个插入的数后插入一个数 现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。 注意:题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。 输入格式 第一行包含整数M，表示操作次数。接下来M行，每行包含一个操作命令，操作命令可能为以下几种：(1) “H x”，表示向链表头插入一个数x。(2) “D k”，表示删除第k个输入的数后面的数（当k为0时，表示删除头结点）。(3) “I k x”，表示在第k个输入的数后面插入一个数x（此操作中k均大于0）。 输出格式 共一行，将整个链表从头到尾输出。 数据范围 1≤M≤100000所有操作保证合法。 输入样例： 10H 9I 1 1D 1D 0H 6I 3 6I 4 5I 4 5I 3 4D 6 输出样例： 6 4 6 5 1.单链表的简单介绍 单链表是一种链式存取的数据结构，用一组任意地址空间（地址空间即存储单元）来存放线性表的数据元素。单链表中的数据是以节点的形式来表示，而节点是用结构体来描述，每个节点都是由元素和指针构成，即该结构体中包含两个成员变量：存放元素的成员变量和存放下一个节点地址的成员变量。 2.顺序表与链表的区别 顺序表的特点为：逻辑相邻的两节点其物理地址也是相邻的；链表的特点为：逻辑相邻的两节点其物理地址不相邻。顺序表的存储方式是：节点元素连续存放在存储单元；链表的存储方式是：节点元素随机存放在存储单元。 链表的插入和删除操作：代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int head; //表示头结点int idx; //表示当前是第几个数int e[N]; //表示第i个数所存储的值int ne[N]; //i的下一个节点void init()&#123; head = -1; //初始化 idx = 0; //下标从0开始&#125;//插入到头结点//1.先用e[idx]存储该值//2.将ne[idx]即第idx个数的下一个节点指向头结点//3.头结点head更新为idx;//4.idx++;void add_to_head(int x)&#123; e[idx] = x, ne[idx] = head, head = idx, idx++; &#125;// 将x插入到第k个数的后面//1.先用e[idx]存储该值x//2.将ne[idx]即第idx个数的下一个节点指向第k个数的下一个节点//3.将ne[k]指向idx;//4.idx++;void add(int k, int x)&#123; e[idx] = x, ne[idx] = ne[k], ne[k] = idx, idx++;&#125;//删除第k个数后面的数//直接让ne[k] = ne[ne[k]]即可void move(int k)&#123; ne[k] = ne[ne[k]];&#125;int main()&#123; int t; init(); cin &gt;&gt; t; while(t--)&#123; char c; int k, x; cin &gt;&gt; c; if(c == 'H')&#123; cin &gt;&gt; x; add_to_head(x); &#125; else if(c == 'D')&#123; cin &gt;&gt; k; if(!k)head = ne[head]; //如果k == 0, 要删除头结点，即让head等于下一个节点 else move(k - 1); &#125; else if(c == 'I')&#123; cin &gt;&gt; k &gt;&gt; x; add(k - 1, x); &#125; &#125; for(int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; ' ' ; cout &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"单链表","slug":"单链表","permalink":"http://zhumenger.top/tags/单链表/"}]},{"title":"直方图中最大的矩形（单调栈2）","slug":"数据结构基础/直方图中最大的矩形（单调栈2）","date":"2019-06-10T14:16:22.000Z","updated":"2019-07-07T03:07:04.215Z","comments":true,"path":"2019/06/10/数据结构基础/直方图中最大的矩形（单调栈2）/","link":"","permalink":"http://zhumenger.top/2019/06/10/数据结构基础/直方图中最大的矩形（单调栈2）/","excerpt":"","text":"题目描述直方图是由在公共基线处对齐的一系列矩形组成的多边形。 矩形具有相等的宽度，但可以具有不同的高度。 例如，图例左侧显示了由高度为2,1,4,5,1,3,3的矩形组成的直方图，矩形的宽度都为1:通常，直方图用于表示离散分布，例如，文本中字符的频率。 现在，请你计算在公共基线处对齐的直方图中最大矩形的面积。 图例右图显示了所描绘直方图的最大对齐矩形。 输入格式 输入包含几个测试用例。每个测试用例占据一行，用以描述一个直方图，并以整数n开始，表示组成直方图的矩形数目。然后跟随n个整数h1，…，hn。这些数字以从左到右的顺序表示直方图的各个矩形的高度。每个矩形的宽度为1。同行数字用空格隔开。当输入用例为n=0时，结束输入，且该用例不用考虑。 输出格式 对于每一个测试用例，输出一个整数，代表指定直方图中最大矩形的区域面积。每个数据占一行。请注意，此矩形必须在公共基线处对齐。 数据范围 1≤n≤100000,0≤hi≤1000000000 输入样例： 7 2 1 4 5 1 3 34 1000 1000 1000 10000 输出样例： 84000 题解：以H[ i ]为高的矩形向左右扩展，找到能够到达的最远距离，即找到左右边界第一个小于H[ i ]的位置， 实际上就是一道单调栈的问题，用一个栈来维护一个单调递增的序列，如果栈中的某个元素比当前的数值的小，那么该元素之后的元素肯定是用不到了，所以就可以直接丢出栈， 并将该值加入栈中，遍历一遍，用ans记录最大值即可 代码如下: 123456789101112131415161718192021222324252627282930313233//这样就形成了一个单调栈#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e6 + 10;typedef long long int ll;int l[N], r[N], h[N], q[N];int n;void get(int a[])&#123; int t = 0; h[0] = -1; for(int i = 1; i &lt;= n; i++)&#123; while(h[q[t]] &gt;= h[i])t--; //找到栈中第一个比该值小的位置 a[i] = q[t]; //记录以H[i]为高能够到达的左右边界 q[++t] = i; //加入栈中 &#125;&#125;int main()&#123; while(cin &gt;&gt; n &amp;&amp; n)&#123; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; h[i]; get(l); //get左边界 reverse(h + 1, h + 1 + n); //翻转 get(r); //get有边界 ll ans = 0; for(int i = 1, j = n; i &lt;= n; i++, j--) ans = max(ans, (ll)h[i] * (n - r[i] - l[j])); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"栈","slug":"栈","permalink":"http://zhumenger.top/tags/栈/"},{"name":"单调栈","slug":"单调栈","permalink":"http://zhumenger.top/tags/单调栈/"}]},{"title":"堆","slug":"数据结构基础/堆","date":"2019-06-10T11:07:00.000Z","updated":"2019-06-10T14:24:17.724Z","comments":true,"path":"2019/06/10/数据结构基础/堆/","link":"","permalink":"http://zhumenger.top/2019/06/10/数据结构基础/堆/","excerpt":"","text":"堆：一种支持插入，删除，查询最值的数据结构，是一颗完全二叉树，实际上就是一个优先队列priority_queue,这里我们用数组的实现这个堆大根堆：树中的任意一个节点的权值都小于等于其父节点小根堆：树中的任意一个节点的权值都大于等于其父节点如何实现堆：直接用一个数组来保存二叉堆， 逐层的从左到右依次编号，将此编号作为节点在数组中存储的位置。所以，父亲点编号等于子节点编号除以2，左子节点编号等于父节点编号乘以2，又子节点等于父节点编号乘2加1 堆的基本操作：1求集合中的最小值：h[ 1 ]2.插入一个数：h[++n] = x;up(n); //up函数将x向上调整，找到x的位置，保证堆的有序性3.删除最小值：h[1] = h[n–];down(1) //down函数，将x向下调整，找到x的位置，保证堆的有序性4.删除任意一个元素：h[x] = h[n–];down(x);up(x);//因为不确定x的大小，所以可能是向上调整，也可能是向下调整，这俩个函数虽然都写上了，但实际上只会执行一个，5.修改任意一个元素：h[k] = x;down(k);up(k)//跟4同理时间复杂度：与堆的高度有关，所以是O（logN）代码如下： 题目描述 输入一个长度为n的整数数列，从小到大输出前m小的数。 输入格式 第一行包含整数n和m。第二行包含n个整数，表示整数数列。 输出格式 共一行，包含m个整数，表示整数数列中前m小的数。 数据范围 1≤m≤n≤105，1≤数列中元素≤109 输入样例： 5 34 5 1 3 2 输出样例： 1 2 3 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int h[N], n ,m;void down(int p) //向上调整&#123; int s = 2 * p; //子节点 while(s &lt;= n)&#123; if(s &lt; n &amp;&amp; h[s] &gt; h[s + 1])s++; //找到左右子节点的最小值 if(h[s] &lt; h[p])&#123; //如果子节点比父节点小 swap(h[s], h[p]); //则交换 p = s; //继续向下调整 s = 2 * p; &#125; else break; &#125;&#125;void up(int p) //向上调整，&#123; while(p &gt; 1)&#123; if(h[p] &lt; h[p / 2])&#123; //如果子节点小于父节点 swap(h[p], h[p / 2]); //则交换 p /= 2; //继续向上调整 &#125; else break; &#125;&#125;int main()&#123; cin&gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; h[i]; for(int i = n / 2; i &gt;= 1; i--)down(i); while(m--)&#123; cout &lt;&lt; h[1] &lt;&lt; ' '; h[1] = h[n--]; down(1); &#125; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"堆","slug":"堆","permalink":"http://zhumenger.top/tags/堆/"}]}]}