{"meta":{"title":"zhumenger ❤ blog","subtitle":null,"description":"穿过落雁修竹, 看过日升月暮<br/>你说总有一天你会名扬天下实现你的抱负!","author":"zhumenger","url":"http://zhumenger.top","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"06-10","excerpt":""},{"title":"search","text":"","path":"search/index-1.html","date":"07-09","excerpt":""},{"title":"tags","text":"","path":"tags/index-1.html","date":"06-10","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"06-10","excerpt":""},{"title":"timeline","text":"","path":"timeline/index.html","date":"06-14","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"06-10","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"06-10","excerpt":""},{"title":"guestbook","text":"","path":"guestbook/index.html","date":"06-13","excerpt":""},{"title":"about","text":"人生是一个很长很长的梦 每个人都想着把这个梦做得完美 却奈何，奇怪的东西总是会出现在梦里 而我们只会不断沉迷，越陷越深 早已忘却了 这，只是一场梦…","path":"about/index.html","date":"06-10","excerpt":""}],"posts":[{"title":"出现次数最多的子串(AC自动机)","text":"题目传送门题目描述有 n 个由小写字母组成的字符串和一个文本串T, 你的任务是找出哪些字符串在文本中出现的次数最多。例如字符串 aba 在 ababa中出现了俩次, 但字符串bab只出现了一次。 输入描述The entire input contains multi cases. The first line of each case is an integer, which is the number ofpatterns N, 1 ≤ N ≤ 150. Each of the following N lines contains one pattern, whose length is in range[1, 70]. The rest of the case is one line contains a large string as the text to lookup, whose length is upto 106.At the end of the input file, number ‘0’ indicates the end of input file 输出描述For each of the input cases, output the appearing times of the dominating pattern(s). If there are morethan one dominating pattern, output them in separate lines; and keep their input order to the output. 输入样例 2 abababababababac6 betaalphahahadeltadedetatadedeltalphahahahototatalpha0 输出样例 4 aba2 alphahaha 题解：AC自动机模板 新加入俩个数组：val[ p ]：以节点p结尾的字符串对应的是哪一个字符串last[ p ]：以字符p结尾的下一个出现过的字符串 cnt[ ]数组用来记录以 p 结尾的字符串出现过多少次 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define MAX_N 1000006 //最后一行的字符串长度#define MAX_Tot 500005 //节点的个数using namespace std;map&lt;string, int &gt; mp;struct Aho&#123; /*struct Trie&#123; //定义每个节点的状态 int next[26]; int fail, cnt; //记录fail指针， cnt记录以该节点结束的串的个数 &#125;trie[MAX_Tot];*/ int trie[MAX_Tot][26]; int fail[MAX_Tot]; int cnt[MAX_Tot]; //记录以p节点结尾的字符串所对应的下标为i的字符串出现的个数 int val[MAX_Tot]; //以节点p结尾的字符串对应的是哪一个字符串 int last[MAX_Tot]; //以字符p结尾的下一个出现过的字符串 int size; //记录AC自动机的节点个数 queue&lt;int&gt; q; void init()&#123; //初始化 while(q.size())q.pop(); memset(trie, 0, sizeof trie); memset(fail, 0, sizeof fail); memset(cnt, 0, sizeof cnt); memset(last, 0, sizeof last); memset(val, 0, sizeof val); size = 1; mp.clear(); &#125; void insert(char S[], int v)&#123; //trie树上构建字符串 int n = strlen(S); int p = 0; //记录走到了哪个节点 for(int i = 0; i &lt; n; i++)&#123; int u = S[i] - 'a'; if(!trie[p][u]) // trie树, 如果没有这个节点 trie[p][u] = size++; //新开一个节点 p = trie[p][u]; &#125; val[p] = v; //记录以节点p结尾的字符串所对应的序号为v mp[S] = v; &#125; void build()&#123; //构建fail失配指针 相当于KMP中的next数组 fail[0] = -1; //根节点的失配指针为-1 q.push(0); while(q.size())&#123; int u = q.front(); q.pop(); for(int i = 0; i &lt; 26; i++)&#123; //遍历所有的子节点 int p = trie[u][i]; //得到子节点 if(p)&#123; //如果存在该节点 if(u == 0)fail[p] = 0, last[p] = 0; //如果为根节点的子节点, 失配指针为0, else&#123; int v = fail[u]; //得到父亲节点的失配指针 while(v &amp;&amp; !trie[v][i])v = fail[v]; // 如果不存在该子节点, 继续向上寻找失配指针 fail[p] = trie[v][i]; //记录该子节点的失配指针 &#125; //last数组更新以p字符节点为结尾且出现过的字符串所对应的字符节点 last[p] = val[fail[p]] ? fail[p] : last[fail[p]]; q.push(p); &#125; &#125; &#125; &#125; int get_cnt(int j)&#123; if(j)&#123; //如果j不为根节点 cnt[val[j]]++; //以j字符为结尾的字符串的数量+1, get_cnt(last[j]); //寻找下一个出现过的字符并更新 &#125; &#125; int match(char S[])&#123; //匹配该字符串 int n = strlen(S); int res = 0, p = 0; //记录答案和当前节点 for(int i = 0; i &lt; n; i++)&#123; int u = S[i] - 'a'; while(p &amp;&amp; !trie[p][u])p = fail[p]; //如果不存在子节点，寻找父节点的失配节点 p = trie[p][u]; //跳到相应的节点上 if(val[p]) +//如果以p字符为结尾的字符串出现过 get_cnt(p); //更新所有以字符p为结尾的cnt数组 else if(last[p])get_cnt(last[p]); //如果该字符串没有出现过，判断以p为结尾的上一个字符串是否出现过, 并更新cnt数组 &#125; return res; &#125;&#125;aho;int t, n;char s[160][MAX_N];char test[MAX_N];int main()&#123; while(scanf(\"%d\", &amp;n) != EOF &amp;&amp; n)&#123; aho.init(); //初始化 for(int i = 1; i &lt;= n; i++)&#123; scanf(\"%s\", s[i]); aho.insert(s[i], i); //trie树上插入该字符串, 并记录该字符串是第几个字符串 &#125; aho.build(); //构建fail失配指针 scanf(\"%s\", test); aho.match(test); int Max = -1; for(int i = 1; i &lt;= n; i++) Max = max(Max, aho.cnt[i]); cout &lt;&lt; Max &lt;&lt; endl; for(int i = 1; i &lt;= n; i++) if(aho.cnt[mp[s[i]]] == Max)printf(\"%s\\n\", s[i]); &#125; return 0;&#125;","path":"2019/11/14/数据结构进阶/AC自动机/出现次数最多的子串-AC自动机/","date":"11-14","excerpt":"","tags":[{"name":"字符串","slug":"字符串","permalink":"http://zhumenger.top/tags/字符串/"},{"name":"AC自动机","slug":"AC自动机","permalink":"http://zhumenger.top/tags/AC自动机/"}]},{"title":"AC自动机(模板题)","text":"题目传送门Problem DescriptionIn the modern time, Search engine came into the life of everybody like Google, Baidu, etc.Wiskey also wants to bring this feature to his image retrieval system.Every image have a long description, when users type some keywords to find the image, the system will match the keywords with description of image and show the image which the most keywords be matched.To simplify the problem, giving you a description of image, and some keywords, you should tell me how many keywords will be match. 输入描述First line will contain one integer means how many cases will follow by.Each case will contain two integers N means the number of keywords and N keywords follow. (N &lt;= 10000)Each keyword will only contains characters ‘a’-‘z’, and the length will be not longer than 50.The last line is the description, and the length will be not longer than 1000000. 输出描述Print how many keywords are contained in the description. 输入样例 1 5shehesayshrheryasherhs 输出描述 3 题目大意给你n个字符串和一个模板串, 求模板串中有多少个字符串再之前出现过 题解AC自动机 用来求多个字符串的匹配问题，trie树上走KMP算法构建fail指针 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define MAX_N 1000006 //最后一行的字符串长度#define MAX_Tot 500005 //节点的个数using namespace std;struct Aho&#123; /*struct Trie&#123; //定义每个节点的状态 int next[26]; int fail, cnt; //记录fail指针， cnt记录以该节点结束的串的个数 &#125;trie[MAX_Tot];*/ int trie[MAX_Tot][26]; int fail[MAX_Tot], cnt[MAX_Tot]; int size; //记录AC自动机的节点个数 queue&lt;int&gt; q; void init()&#123; //初始化 while(q.size())q.pop(); memset(trie, 0, sizeof trie); memset(fail, 0, sizeof fail); memset(cnt, 0, sizeof cnt); size = 1; &#125; void insert(char S[])&#123; //trie树上构建字符串 int n = strlen(S); int p = 0; //记录走到了哪个节点 for(int i = 0; i &lt; n; i++)&#123; int u = S[i] - 'a'; if(!trie[p][u]) // trie树, 如果没有这个节点 trie[p][u] = size++; //新开一个节点 p = trie[p][u]; &#125; cnt[p]++; &#125; void build()&#123; //构建fail失配指针 相当于KMP中的next数组 fail[0] = -1; //根节点的失配指针为-1 q.push(0); while(q.size())&#123; int u = q.front(); q.pop(); for(int i = 0; i &lt; 26; i++)&#123; //遍历所有的子节点 if(trie[u][i])&#123; //如果存在该节点 if(u == 0)fail[trie[u][i]] = 0; //如果为根节点的子节点, 失配指针为0 else&#123; int v = fail[u]; //得到父亲节点的失配指针 while(v &amp;&amp; !trie[v][i])v = fail[v]; //如果不存在该子节点, 继续向上寻找失配指针 fail[trie[u][i]] = trie[v][i]; //纪律该子节点的失配指针 &#125; q.push(trie[u][i]); &#125; &#125; &#125; &#125; int get(int u)&#123; int res = cnt[u]; cnt[u] = 0; u = fail[u]; while(u &amp;&amp; cnt[u])&#123; res = res + cnt[u]; // 获得以当前节点结尾的字符串的数量 cnt[u] = 0; //算过之后，清零 u = fail[u]; //继续寻找失配指针 &#125; return res; &#125; int match(char S[])&#123; //匹配该字符串 int n = strlen(S); int res = 0, p = 0; //记录答案和当前节点 for(int i = 0; i &lt; n; i++)&#123; int u = S[i] - 'a'; while(p &amp;&amp; !trie[p][u])p = fail[p]; //如果不存在子节点，寻找父节点的失配节点 p = trie[p][u]; //跳到相应的节点上 res += get(p); //获得所有以当前节点为结尾的字符串的数量 &#125; return res; &#125;&#125;aho;int t, n;char s[MAX_N];int main()&#123; scanf(\"%d\", &amp;t); while(t--)&#123; aho.init(); //初始化 scanf(\"%d\", &amp;n); for(int i = 0; i &lt; n; i++)&#123; scanf(\"%s\", s); aho.insert(s); //trie树上插入该字符串 &#125; aho.build(); //构建fail失配指针 scanf(\"%s\", s); printf(\"%d\\n\", aho.match(s)); //寻找答案 &#125; return 0;&#125;","path":"2019/11/13/数据结构进阶/AC自动机/AC自动机-模板题/","date":"11-13","excerpt":"","tags":[{"name":"字符串","slug":"字符串","permalink":"http://zhumenger.top/tags/字符串/"},{"name":"AC自动机","slug":"AC自动机","permalink":"http://zhumenger.top/tags/AC自动机/"}]},{"title":"不要62(数位DP)","text":"题目传送门题目描述杭州人称那些傻乎乎粘嗒嗒的人为 6262（音：laoer）。 杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。 不吉利的数字为所有含有 4 或 62 的号码。例如：62315,73418,88914 都属于不吉利号码。但是，61152虽然含有 6 和 2，但不是 连号，所以不属于不吉利数字之列。 你的任务是，对于每次给出的一个牌照号区间 [n,m]，推断出交管局今后又要实际上给多少辆新的士车上牌照了。 输入格式输入包含多组测试数据，每组数据占一行。 每组数据包含一个整数对 n 和 m。 当输入一行为“0 0”时，表示输入结束。 输出格式对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。 数据范围 1≤n≤m≤107 输入样例： 1 1000 0 输出样例： 80 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//简简单单#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;const int N = 15;int f[N][N]; //有 i 位, 最高位为 j且不包含62 和 4 的方案数void init()&#123; for(int i = 0; i &lt;= 9; i++)f[1][i] = 1; f[1][4] = 0; for(int i = 2; i &lt; N; i++) for(int j = 0; j &lt;= 9; j++) for(int k = 0; k &lt;= 9; k++)&#123; if(j == 4 || k == 4) continue; if(j == 6 &amp;&amp; k == 2) continue; f[i][j] += f[i - 1][k]; &#125;&#125;int dp(int n)&#123; if(!n) return 1; vector&lt;int&gt; nums; while(n)nums.push_back(n % 10), n /= 10; int res = 0; int last = 0; for(int i = nums.size() - 1; i &gt;= 0; i--)&#123; int x = nums[i]; for(int j = 0; j &lt; x; j++)&#123; if(j == 4)continue; if(last == 6 &amp;&amp; j == 2)continue; res += f[i + 1][j]; &#125; if(x == 4)break; if(last == 6 &amp;&amp; x == 2)break; last = x; if(i == 0 &amp;&amp; x != 4)res++; &#125; return res;&#125;int main()&#123; int l, r; init(); while(cin &gt;&gt; l &gt;&gt; r &amp;&amp; l &amp;&amp; r)&#123; cout &lt;&lt; dp(r) - dp(l - 1) &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/11/10/动态规划/数位DP/不要62-数位DP/","date":"11-10","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"数位DP","slug":"数位DP","permalink":"http://zhumenger.top/tags/数位DP/"}]},{"title":"数字游戏2(数位DP)","text":"题目传送门题目描述由于科协里最近真的很流行数字游戏。 某人又命名了一种取模数，这种数字必须满足各位数字之和 mod N为 0。 现在大家又要玩游戏了，指定一个整数闭区间 [a.b]，问这个区间内有多少个取模数。 输入格式输入包含多组测试数据，每组数据占一行。 每组数据包含三个整数 a,b,N。 输出格式对于每个测试数据输出一行结果，表示区间内各位数字和 mod N 为 0 的数的个数。 数据范围 1≤a,b≤2^31−11≤N&lt;100 输入样例： 1 19 9 输出样例： 2 题解：数位DP: 跟之前的题都是一个思路,只不过处理左分支的做法不同 f(i, j, k)表示当前有 i 位,最高位为 j,且 % m 的余数为 k 的情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;const int N = 15;int f[N][N][110];int l, r, m;int mod(int a, int b) //防止出现负数&#123; return (a % b + b) % b;&#125;void init()&#123; memset(f, 0, sizeof f); for(int i = 0; i &lt;= 9; i++)f[1][i][i % m]++; for(int i = 2; i &lt; N; i++) for(int j = 0; j &lt;= 9; j++) for(int k = 0; k &lt; m; k++) for(int x = 0; x &lt;= 9; x++) f[i][j][k] += f[i - 1][x][mod(k - j, m)];//等于i - 1位,最高位为 x, 所有模数为K - J的情况之和，&#125;int dp(int n)&#123; if(n == 0)return 1; vector&lt;int&gt; nums; while(n)nums.push_back(n % 10), n /= 10; int res = 0; //存答案 int last = 0; //存前面各位数字之和 for(int i = nums.size() - 1; i &gt;= 0; i--)&#123; int x = nums[i]; for(int j = 0; j &lt; x; j++) res += f[i + 1][j][mod(-last, m)]; //前面各位数的和为last, (last + p) % m == 0 等同于(last - last) % m = 0,即模数为-last last += x; if(i == 0 &amp;&amp; last % m == 0)res++;//判断最后一位的情况 &#125; return res;&#125;int main()&#123; while(cin &gt;&gt; l &gt;&gt; r &gt;&gt; m)&#123; init(); cout &lt;&lt; dp(r) - dp(l - 1) &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/11/10/动态规划/数位DP/数字游戏2-数位DP/","date":"11-10","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"数位DP","slug":"数位DP","permalink":"http://zhumenger.top/tags/数位DP/"}]},{"title":"Windy数(数位DP)","text":"题目传送门题目描述Windy 定义了一种 Windy 数：不含前导零且相邻两个数字之差至少为 2 的正整数被称为 Windy 数。 Windy 想知道，在 A 和 B 之间，包括 A 和 B，总共有多少个 Windy 数？ 输入格式共一行，包含两个整数 A 和 B。 输出格式输出一个整数，表示答案。 数据范围 1≤A≤B≤2×10^9 输入样例1： 1 10 输入样例2： 25 50 题解：数位DP: 跟之前的情况一样,分离每一位数,从高位开始枚举,因为不能存在前导0,所以可以让最高位为1, 计算一下方案数 再特殊处理一下最高位为0,且无前导零的情况 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;vector&gt;using namespace std;const int N = 15;int f[N][N];void init()&#123; for(int i = 0; i &lt;= 9; i++)f[1][i] = 1; //预处理出每一位左分支的情况, for(int i = 2; i &lt; N; i++) for(int j = 0; j &lt;= 9; j++) for(int k = 0; k &lt;= 9; k++) if(abs(j - k) &gt;= 2) f[i][j] += f[i - 1][k];&#125;int dp(int n)&#123; if(!n ) return 0; vector&lt;int&gt; nums; while(n)nums.push_back(n % 10), n /= 10; int res = 0; int last = -2; for(int i = nums.size() - 1; i &gt;= 0; i--)&#123; int x = nums[i]; for(int j = i == nums.size() - 1; j &lt; x; j++) //i为最高位时, 让j = 1, 这样就去掉了前导零的情况 if(abs(j - last) &gt;= 2) res += f[i + 1][j]; if(abs(x - last) &lt; 2) break; last = x; if(i == 0)res++; &#125; //特殊处理最高位为0时,有前导零的情况, for(int i = 1; i &lt; nums.size(); i++) //从低位到高位 for(int j = 1; j &lt;= 9; j++) //从1开始枚举 res += f[i][j]; return res;&#125;int main()&#123; int l, r; init(); cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; dp(r) - dp(l - 1) &lt;&lt; endl; return 0;&#125;","path":"2019/11/10/动态规划/数位DP/Windy数-数位DP/","date":"11-10","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"数位DP","slug":"数位DP","permalink":"http://zhumenger.top/tags/数位DP/"}]},{"title":"数字游戏(数位DP)","text":"题目传送门题目描述科协里最近很流行数字游戏。 某人命名了一种不降数，这种数字必须满足从左到右各位数字呈非下降关系，如 123123，446446。 现在大家决定玩一个游戏，指定一个整数闭区间 [a,b]，问这个区间内有多少个不降数。 输入格式输入包含多组测试数据。 每组数据占一行，包含两个整数 a 和 b。 输出格式每行给出一组测试数据的答案，即 [a,b] 之间有多少不降数。 数据范围1 ≤ a ≤ b ≤ 2^31−1 输入样例： 1 91 19 输出样例： 9 18 题解：数位DP：从最高位开始考虑: *假设第 i 位的数为 x, 它前面的数为 j, 将 x 分为0 ~ x - 1, x俩个分支, * 考虑左分支的方案数: 假设填k(j &lt;= k &lt; x, 保证非下降)则方案为f[ i ] [ k ] ( f(i, k)表示有i位，且最高位为k的方 案数,可用DP求出) 那么左分支的的方案为∑(j &lt;= k &lt; x)f[ i ] [ k ] 右分支: 如果x &lt; last 无法满足非下降条件, 直接break, 否则填x进入又分支,继续判断下一位的情况 如果i == 0, 可以填任意数，也是一种方案， res++ 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N = 15;int f[N][N]; //表示一共有 i 位, 且最高位为 j 的方案数void init()&#123; for(int i = 0; i &lt;= 9; i++)f[1][i] = 1; for(int i = 2; i &lt; N; i++) for(int j = 0; j &lt;= 9; j++) for(int k = j; k &lt;= 9; k++) f[i][j] += f[i - 1][k];&#125;int dp(int n)&#123; if(n == 0) return 1; vector&lt;int&gt; nums; while(n)nums.push_back(n % 10), n /= 10; int res = 0; //记录方案数 int last = 0; //记录上一位的数是多少 for(int i = nums.size() - 1; i &gt;= 0; i--)&#123; int x = nums[i]; for(int j = last; j &lt; x; j++) res += f[i + 1][j]; if(x &lt; last)break; last = x; if(i == 0)res++; &#125; return res;&#125;int main()&#123; init(); int l, r; while(cin &gt;&gt; l &gt;&gt; r)&#123; cout &lt;&lt; dp(r) - dp(l - 1) &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/11/10/动态规划/数位DP/数字游戏-数位DP/","date":"11-10","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"数位DP","slug":"数位DP","permalink":"http://zhumenger.top/tags/数位DP/"}]},{"title":"度的数量(数位DP)","text":"求给定区间 [X,Y][X,Y] 中满足下列条件的整数个数：这个数恰好等于 KK 个互不相等的 BB 的整数次幂之和。 例如，设 X=15,Y=20,K=2,B=2X=15,Y=20,K=2,B=2，则有且仅有下列三个数满足题意： 17=24+2017=24+2018=24+2118=24+2120=24+2220=24+22 输入格式第一行包含两个整数 X 和 Y，接下来两行包含整数 K 和 B。 输出格式只包含一个整数，表示满足条件的数的个数。 数据范围1≤ X ≤ Y ≤2 ^31−11 ≤ K ≤ 20,2 ≤ B ≤10 输入样例： 15 202 2 输出样例： 3 题解：数位DP:首先将N转化为b进制数,则一个数能由b的整数次方合成,则转化为b进制后，对应的b的次方的位置为1, 那么我们 只需判断转化为b进制后，那一位上填0, 哪一位上填 1,得到总的方案数就可以了 假设 N 转化为 b 进制后有 n 位数,从最高位开始遍历,当前位的数为 x, 枚举填 0 和填 1 的方案： 1.如果 x == 0,直接跳过(不能由b的多少次方组成) *2.如果x == 1, 当前位置 i 可以填0, 还需要填 k 个 1 ，则需要从剩下的 i - 1 位中填 k 个 1 ,即C(i - 1, k), 并让x = * 1，继续判断下一位; 3.如果x &gt; 1, 则该位上可以填 0 ,方案数为C(i - 1, k), 也可以填 1 ,即方案数为C(i - 1, k - 1), 因为填大于 1 的数不 合法，所以直接break掉 4.判断 i 是否等于 0，即判断i是否为最后一位, 如果是的话, 那么最后以后可以填 0 , ans++; f(i, j)表示从i个数里面选j个数的方案数,预处理出每一位上左分支的方案数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;const int N = 32;int f[N][N];int l, r, k, b;void init()//预处理&#123; for(int i = 0; i &lt; N; i++) //从i个数里面选j个数 for(int j = 0; j &lt;= i; j++) if(j == 0)f[i][j] = 1; else f[i][j] = f[i - 1][j] + f[i - 1][j - 1];&#125;int dp(int n)&#123; if(n == 0) return 0; //判断边界 vector&lt;int&gt; nums; while(n) nums.push_back(n % b), n /= b; //转化为b进制数, int res = 0; //记录答案个数 int last = 0; // 记录已经有多少个1了 for(int i = nums.size() - 1; i &gt;= 0; i--)&#123; //从最高位开始 int x = nums[i]; //得到第i位上的数 //两种情况 if(x)&#123; //求左边的分支 res += f[i][k - last]; //如果是0的方案 if(x &gt; 1)&#123; //只有x &gt; 1才能枚举左边的分支 if(k - last - 1 &gt;= 0)res += f[i][k - last - 1]; //表示在该位上填1的方案 break; //0 和 1 的情况都判断了, 若果x &gt; 1的话,就没有方案了，直接break掉 &#125; //x == 1 else &#123; //进入右边的分支 last++; if(last &gt; k)break; &#125; &#125; //求右边的分支的方案 if(i == 0 &amp;&amp; last == k) res++; //最后一位 &#125; return res;&#125;int main()&#123; init(); cin &gt;&gt; l &gt;&gt; r &gt;&gt; k &gt;&gt; b; cout &lt;&lt; dp(r) - dp(l - 1) &lt;&lt; endl; return 0;&#125;","path":"2019/11/10/动态规划/数位DP/度的数量-数位DP/","date":"11-10","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"数位DP","slug":"数位DP","permalink":"http://zhumenger.top/tags/数位DP/"}]},{"title":"皇宫看守(树形DP)","text":"题目传送门题目描述太平王世子事件后，陆小凤成了皇上特聘的御前一品侍卫。 皇宫以午门为起点，直到后宫嫔妃们的寝宫，呈一棵树的形状，某些宫殿间可以互相望见。 大内保卫森严，三步一岗，五步一哨，每个宫殿都要有人全天候看守，在不同的宫殿安排看守所需的费用不同。 可是陆小凤手上的经费不足，无论如何也没法在每个宫殿都安置留守侍卫。 帮助陆小凤布置侍卫，在看守全部宫殿的前提下，使得花费的经费最少。 输入格式输入中数据描述一棵树，描述如下： 第一行 n，表示树中结点的数目。 第二行至第 n+1 行，每行描述每个宫殿结点信息，依次为：该宫殿结点标号 i，在该宫殿安置侍卫所需的经费 kk，该结点的子结点数 m，接下来 m 个数，分别是这个结点的 mm 个子结点的标号 r1,r2,…,rm。 对于一个 n 个结点的树，结点标号在 1 到 n 之间，且标号不重复。 输出格式输出一个整数，表示最少的经费。 数据范围1≤n≤1500 输入样例： 6 1 30 3 2 3 42 16 2 5 63 5 04 4 05 11 06 5 0 输出样例： 25 样例解释：在2、3、4结点安排护卫，可以观察到全部宫殿，所需经费最少，为 16 + 5 + 4 = 25。 题解：树形DP: f[ N ] [ 3 ],表示3种状态: 0 表示父节点放了守卫, 1 表示子节点放了守卫, 2 表示自身放了守卫 则f[ u ] [ 0 ] += min(f[ j ] [ i ], f[ j ] [ 2 ]) 父节点放了守卫, 那么它的字节点可放可不放,我们取最小值 f[ u ] [ 2 ] += min(f[ j ] [ 0 ], min(f[ j ] [ 1 ], f[ j ] [ 2 ])) 自身放了守卫, 子节点可放可不放, 去3种状态的最小值 思考子节点放了守卫的情况: 枚举哪个子节点放了守卫, 即f[ j ] [ 2 ], 其他子节点可放可不放, 可以先用sum求出子节点值的总和, 即f[ u ] [ 0 ], f[ u ] [ 0 ] - min(f[ j ] [ 1 ], - f[ j ] [ 2 ]) 表示去掉j这个子节点其他子节点的总和; 推出:f[ u ] [ 1 ] = min(f[ u ] [ 1 ], f[ j ] [ 2 ] + f[ u ] [ 0 ] - min(f[ j ] [ 1 ], f[ j ] [ 2 ])); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1510;int h[N], e[N], w[N], ne[N], idx;int f[N][3]; //3种状态 0 表示父节点放了守卫,1 表示子节点放了守卫,2 表示自身放了守卫int n, m, a, b, c;int vis[N];void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;void dfs(int u)&#123; f[u][2] = w[u]; int sum = 0; // 记录所有子节点f[j][1], f[j][2] 的最小值 for(int i = h[u]; i != -1; i = ne[i])&#123; int j = e[i]; dfs(j); f[u][0] += min(f[j][1], f[j][2]); f[u][2] += min(f[j][0], min(f[j][1], f[j][2])); &#125; f[u][1] = 1e9; for(int i = h[u]; i != -1; i = ne[i])&#123; int j = e[i]; //枚举子节点 j 放了守卫 //f[u][0] - min(f[j][1], - f[j][2]) 表示去掉j这个子节点其他子节点的总和; f[u][1] = min(f[u][1], f[j][2] + f[u][0] - min(f[j][1], f[j][2])); &#125;&#125;int main()&#123; cin &gt;&gt; n; memset(h, -1, sizeof h); memset(vis, false, sizeof vis); for(int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; a &gt;&gt; c &gt;&gt; m; w[a] = c; while(m--)&#123; cin &gt;&gt; b; add(a, b); vis[b] = true; &#125; &#125; int root = 1; while(vis[root])root++; //寻找根节点 dfs(root); cout &lt;&lt; min(f[root][1], f[root][2]) &lt;&lt; endl; return 0;&#125;","path":"2019/11/10/动态规划/树形DP/皇宫看守-树形DP/","date":"11-10","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"树形DP","slug":"树形DP","permalink":"http://zhumenger.top/tags/树形DP/"}]},{"title":"战略游戏(树形DP)","text":"题目传送门题目描述鲍勃喜欢玩电脑游戏，特别是战略游戏，但有时他找不到解决问题的方法，这让他很伤心。 现在他有以下问题。 他必须保护一座中世纪城市，这条城市的道路构成了一棵树。 每个节点上的士兵可以观察到所有和这个点相连的边。 他必须在节点上放置最少数量的士兵，以便他们可以观察到所有的边。 你能帮助他吗？ 例如，下面的树： 只需要放置1名士兵（在节点1处），就可观察到所有的边。 输入格式输入包含多组测试数据，每组测试数据用以描述一棵树。 对于每组测试数据，第一行包含整数N，表示树的节点数目。 接下来N行，每行按如下方法描述一个节点。 节点编号：(子节点数目) 子节点 子节点 … 节点编号从0到N-1，每个节点的子节点数量均不超过10，每个边在输入数据中只出现一次。 输出格式对于每组测试数据，输出一个占据一行的结果，表示最少需要的士兵数。 数据范围0&lt;N≤1500 输入样例： 4 0:(1) 11:(2) 2 32:(0)3:(0)5 3:(3) 1 4 21:(1) 02:(0)0:(0)4:(0) 输出样例： 1 2 题解：*树形DP:* 就是在树或图上的一种DP，一般是某个父节点或子节点有特殊要求的时候用的一种DP 首先是建图，在图上遍历的时候进行DP操作，对于这道题来说我们用F(i, j)来表示i这个节点最少需要的士兵数， 状态为 j (用0来表示不选，用1来表示选)值的最小值，对于每个节点我们有俩种操作： 1.选当前这个节点，j 状态为1，它的子节点可以选可以不选，取较小的那一个,所以f(i, 1) += min(f(u, 1) , f(u,0))(u表示 i 的子节点) 2.不选当前这个节点，j 的状态为0，它的子节点必须选， f(i, 0) += f[ u ] [ 1 ]; 3.从任意一个跟节点开始搜索，所以还需要一个数组来储存哪些节点有父节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1510;int h[N], e[N], ne[N], idx;void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;int n, m;int f[N][2];bool vis[N];void dfs(int u)&#123; f[u][0] = 0, f[u][1] = 1; //初始化 for(int i = h[u]; i != -1; i = ne[i])&#123; int j = e[i]; dfs(j); f[u][0] += f[j][1]; //当前节点不选 f[u][1] += min(f[j][0], f[j][1]);//选当前节点 &#125;&#125;int main()&#123; while(cin &gt;&gt; n)&#123; int a, b; memset(vis, false, sizeof vis); idx = 0; memset(h, -1, sizeof h); for(int i = 0; i &lt; n; i++)&#123; scanf(\"%d:(%d)\", &amp;a, &amp;m); while(m--)&#123; cin &gt;&gt; b; vis[b] = true; add(a, b); &#125; &#125; int root = 0; while(vis[root])root++; //寻找一个根节点 dfs(root); cout &lt;&lt; min(f[root][0], f[root][1]) &lt;&lt; endl; //输出俩种情况的最小值 &#125; return 0;&#125;","path":"2019/11/10/动态规划/树形DP/战略游戏-树形DP/","date":"11-10","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"树形DP","slug":"树形DP","permalink":"http://zhumenger.top/tags/树形DP/"}]},{"title":"二叉苹果树(树形DP)","text":"题目传送门题目描述有一棵二叉苹果树，如果树枝有分叉，一定是分两叉，即没有只有一个儿子的节点。 这棵树共 N 个节点，编号为 1 至 N，树根编号一定为 1。 我们用一根树枝两端连接的节点编号描述一根树枝的位置。 一棵苹果树的树枝太多了，需要剪枝。但是一些树枝上长有苹果，给定需要保留的树枝数量，求最多能留住多少苹果。 这里的保留是指最终与1号点连通。 输入格式第一行包含两个整数 N 和 Q，分别表示树的节点数以及要保留的树枝数量。 接下来 N−1 行描述树枝信息，每行三个整数，前两个是它连接的节点的编号，第三个数是这根树枝上苹果数量。 输出格式输出仅一行，表示最多能留住的苹果的数量。 数据范围1≤Q&lt;N≤100.N≠1每根树枝上苹果不超过 30000个。 输入样例： 5 21 3 11 4 102 3 203 5 20 输出样例： 5 21 3 11 4 102 3 203 5 20 题解：树形DP之有依赖的分组背包问题： f[ i ] [ j ]表示以 i 为根节点, 选 j 条边的最大价值 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 210;int h[N], e[N], ne[N], w[N], idx;int f[N][N];int n, m;void add(int a, int b, int c)&#123; e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;&#125;void dfs(int u, int father)&#123; for(int i = h[u]; i != -1; i = ne[i])&#123; //枚举每一个分组 if(e[i] == father)continue; dfs(e[i], u); for(int j = m; j &gt;= 0; j--) //枚举分支的个数 for(int k = 0; k &lt; j; k++) //枚举决策 f[u][j] = max(f[u][j], f[u][j - k - 1] + f[e[i]][k] + w[i]); &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof h); for(int i = 0; i &lt; n - 1; i++)&#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); add(b, a, c); &#125; dfs(1, -1); cout &lt;&lt; f[1][m] &lt;&lt; endl; return 0;&#125;","path":"2019/11/10/动态规划/树形DP/二叉苹果树-树形DP/","date":"11-10","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"树形DP","slug":"树形DP","permalink":"http://zhumenger.top/tags/树形DP/"}]},{"title":"数字转换(树形DP)","text":"题目传送门如果一个数 x 的约数之和 y（不包括他本身）比他本身小，那么 x 可以变成 y，y 也可以变成 x。 例如，4 可以变为 3，1 可以变为 7。 限定所有数字变换在不超过 n 的正整数范围内进行，求不断进行数字变换且不出现重复数字的最多变换步数。 输入格式输入一个正整数 n。 输出格式输出不断进行数字变换且不出现重复数字的最多变换步数。 数据范围 1≤n≤50000 输入样例： 7 输出样例： 3 样例解释一种方案为：4→3→1→7。 题解：树形DP： 首先预处理出每个数的约数之和,我们可以对每一个合法的路径进行建边 最后就可以转化为求树的最长路径问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 50010;int n;int h[N], e[N], ne[N], idx;int sum[N];bool vis[N];int ans;void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;int dfs(int u) //求以u为根节点的最长路径&#123; int d1 = 0, d2 = 0; //记录最长路径和次长路径 for(int i = h[u]; i != -1; i = ne[i])&#123; int j = e[i]; int d = dfs(j) + 1; if(d &gt;= d1)&#123; d2 = d1; d1 = d; &#125; else if(d &gt;= d2)d2 = d; &#125; ans = max(ans, d1 + d2); return d1;&#125;int main()&#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) //预处理出每个数的约数之和 for(int j = 2; j &lt;= n / i; j++) sum[i * j] += i; memset(h, -1, sizeof h); //1的约数之和为0， 所以从2开始建边 for(int i = 2; i &lt;= n; i++)&#123; if(i &gt; sum[i])&#123; //对合法路径进行建边 add(sum[i], i); vis[i] = true; //记录树根 &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; if(!vis[i])&#123; //如果该点是树根 dfs(i); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","path":"2019/11/10/动态规划/树形DP/数字转换-树形DP/","date":"11-10","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"树形DP","slug":"树形DP","permalink":"http://zhumenger.top/tags/树形DP/"}]},{"title":"树的中心(树形DP)","text":"树的中心题目传送门题目描述给定一棵树，树中包含 n 个结点（编号1~n）和 n−1 条无向边，每条边都有一个权值。 请你在树中找到一个点，使得该点到树中其他结点的最远距离最近。 输入格式第一行包含整数 n。 接下来 n−1 行，每行包含三个整数 ai,bi,ci，表示点 ai 和 bi 之间存在一条权值为 ci 的边。 输出格式输出一个整数，表示所求点到树中其他结点的最远距离。 数据范围 1≤n≤100001≤ai,bi≤n−105≤ci≤105 输入样例： 5 2 1 13 2 14 3 15 1 1 输出样例： 2 题解：树形DP：dfs俩次，第一次求以u为节点，用d1和d2来记录向下走的最长路和次长路, 并用p1 p2来记录最长路和次长路来自哪个节点, 最后取以u为节点向下走的最远距离和向上走的最远距离的最小值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 10010;int h[N], e[N * 2], w[N * 2], ne[N * 2], idx;// d1 和 d2 分别表示以 i 为起点向下走的最大值和次大值//up表示向上走的最长路径是多少//p1 和 p2 表示最长路和次长路分别是从哪条边走上来的int d1[N], d2[N], up[N], p1[N], p2[N];int ans;void add(int a, int b, int c)&#123; e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;&#125;int dfs_d(int u, int father)//向下走&#123; if(h[u] == -1) return 0; d1[u] = d2[u] = -1e9; for(int i = h[u]; i != -1; i = ne[i])&#123; int j = e[i]; if(j == father)continue; int d = dfs_d(j, u) + w[i]; if(d &gt;= d1[u])&#123; d2[u] = d1[u]; d1[u] = d; p2[u] = p1[u], p1[u] = j; &#125; else if(d &gt; d2[u])&#123; d2[u] = d; p2[u] = j; &#125; &#125; if(d1[u] == -1e9)d1[u] = d2[u] = 0; // 判断是否为叶子节点 return d1[u];&#125; void dfs_u(int u, int father)//向上走&#123; for(int i = h[u]; i != -1; i = ne[i])&#123; int j = e[i]; if(j == father)continue; if(p1[u] == j)up[j] = max(up[u], d2[u]) + w[i]; //要么是次长路, 要什么是up[u]; else up[j] = max(up[u], d1[u]) + w[i]; //可以是最长路，要么是up[u]; dfs_u(j, u); &#125;&#125;int main()&#123; int n; cin &gt;&gt; n; memset(h, -1, sizeof h); for(int i = 0; i &lt; n - 1; i++)&#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); add(b, a, c); &#125; ans = 1e9; dfs_d(1, -1);//往下走 dfs_u(1, -1); int res = 1e9; for(int i = 1; i &lt;= n; i++)res = min(res, max(d1[i], up[i])); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;","path":"2019/11/09/动态规划/树形DP/树的中心-树形DP/","date":"11-09","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"树形DP","slug":"树形DP","permalink":"http://zhumenger.top/tags/树形DP/"}]},{"title":"树的最长路径(树形DP)","text":"题目传送门题目描述给定一棵树，树中包含 n 个结点（编号1~n）和 n−1 条无向边，每条边都有一个权值。 现在请你找到树中的一条最长路径。 换句话说，要找到一条路径，使得使得路径两端的点的距离最远。 注意：路径中可以只包含一个点。 输入格式第一行包含整数 n。 接下来 n−1 行，每行包含三个整数 ai,bi,ci，表示点 ai 和 bi 之间存在一条权值为 ci 的边。 输出格式输出一个整数，表示树的最长路径的长度。 数据范围 1≤n≤100001≤ai,bi≤n−105≤ci≤105 输入样例： 6 5 1 61 4 56 3 92 6 86 1 7 输出样例： 22 题解：树形DP：用俩个变量d1, d2分别记录以 u 为根节点向下走的最长和次长路径, 并用ans记录d1 + d2的最大和 1234567891011121314151617181920212223242526272829303132333435363738394041424344//以u为根节点向下传递的最长路径#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 10010;int h[N], e[N * 2], ne[N * 2], w[N * 2], idx;int ans, n;void add(int a, int b, int c)&#123; e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; &#125;int dfs(int u, int father) //father用来判断, 不能向上搜&#123; int dist = 0; // 从当前点往下走的最大长度 int d1 = 0, d2 = 0;//表示最长距离和次长距离 for(int i = h[u]; i != -1; i = ne[i])&#123; int j = e[i]; if(j == father)continue; int d = dfs(j, u) + w[i]; dist = max(dist, d); if(d &gt;= d1)&#123; d2 = d1; d1 = d; &#125; else if(d &gt;= d2)d2 = d; &#125; ans = max(ans, d1 + d2); //表示以u为顶点，向下走的俩条最大路径之和, 找到最大值便是答案 return dist;&#125;int main()&#123; cin &gt;&gt; n; memset(h, -1, sizeof h); n -= 1; while(n--)&#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); add(b, a, c); &#125; dfs(1, -1); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","path":"2019/11/09/动态规划/树形DP/树的最长路径-树形DP/","date":"11-09","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"树形DP","slug":"树形DP","permalink":"http://zhumenger.top/tags/树形DP/"}]},{"title":"棋盘分割(区间DP)","text":"棋盘分割题目传送门题目描述将一个８*８的棋盘进行如下分割：将原棋盘割下一块矩形棋盘并使剩下部分也是矩形，再将剩下的部分继续如此分割，这样割了(n-1)次后，连同最后剩下的矩形棋盘共有n块矩形棋盘。(每次切割都只能沿着棋盘格子的边进行) 原棋盘上每一格有一个分值，一块矩形棋盘的总分为其所含各格分值之和。 现在需要把棋盘按上述规则分割成n块矩形棋盘，并使各矩形棋盘总分的均方差最小。 均方差 ，其中平均值 ，xi为第 i 块矩形棋盘的总分。 请编程对给出的棋盘及n，求出均方差的最小值。 输入格式第1行为一个整数n。 第2行至第9行每行为8个小于100的非负整数，表示棋盘上相应格子的分值。每行相邻两数之间用一个空格分隔。 输出格式输出最小均方差值（四舍五入精确到小数点后三位）。 数据范围 1&lt;n&lt;15 输入样例： 3 1 1 1 1 1 1 1 31 1 1 1 1 1 1 11 1 1 1 1 1 1 11 1 1 1 1 1 1 11 1 1 1 1 1 1 11 1 1 1 1 1 1 11 1 1 1 1 1 1 01 1 1 1 1 1 0 3 输出样例： 1.633 题解：我们可以用记忆化搜索来做, 对于当前方块, 我们可以横向切,也可以纵向切,切完之后我们可以选择其中的一半继续 进行切割找出所有情况的最小值 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;using namespace std;const int N = 15, M = 9, INF = 1e9;int n;int s[N][N]; //存前缀和double f[M][M][M][M][N]; //表示坐标(x1, y1),(x2, y2)这个方块切割k次的最小值double x; //存平均值double get(int x1, int y1, int x2, int y2) //获得题目要求的方差&#123; double sum = s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1] - x; return sum * sum * 1.0 / n; //化简后的公式&#125;double dp(int x1, int y1, int x2, int y2, int k)&#123; double &amp;v = f[x1][y1][x2][y2][k]; if(v &gt;= 0) return v; //如果已经有值了，直接返回 if(k == 1)return v = get(x1, y1, x2, y2); //如果是最后一次分割了,直接返回 v = INF; for(int i = x1; i &lt; x2; i++) &#123;//枚举横切 v = min(v, dp(x1, y1, i, y2, k - 1) + get(i + 1, y1, x2, y2));//选上面的继续进行切割 v = min(v, dp(i + 1, y1, x2, y2, k - 1) + get(x1, y1, i, y2)); //选下面的继续进行切割 &#125; for(int i = y1; i &lt; y2; i++)&#123;//枚举纵切 v = min(v, dp(x1, y1, x2, i, k - 1) + get(x1, i + 1, x2, y2));//选左边的继续进行切割 v = min(v, dp(x1, i + 1, x2, y2, k - 1) + get(x1, y1, x2, i)); //选右边的继续进行切割 &#125; return v;&#125;int main()&#123; cin &gt;&gt; n; for(int i =1; i &lt;= 8; i++) for(int j = 1; j &lt;= 8; j++)&#123; cin &gt;&gt; s[i][j]; s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; //求前缀和 &#125; memset(f, -1, sizeof f); x = s[8][8]*1.0 / n; //得到平均值 printf(\"%.3lf\\n\", sqrt(dp(1, 1, 8, 8, n))); return 0;&#125;","path":"2019/11/09/动态规划/区间DP/棋盘分割-区间DP/","date":"11-09","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"区间DP","slug":"区间DP","permalink":"http://zhumenger.top/tags/区间DP/"}]},{"title":"凸多边形的划分(区间DP)","text":"题凸多边形的划分题目传送门题目描述给定一个具有 N 个顶点的凸多边形，将顶点从 1 至 N 标号，每个顶点的权值都是一个正整数。 将这个凸多边形划分成 N−2 个互不相交的三角形，对于每个三角形，其三个顶点的权值相乘都可得到一个权值乘积，试求所有三角形的顶点权值乘积之和至少为多少。 输入格式第一行包含整数 N，表示顶点数量。 第二行包含 N 个整数，依次为顶点 1 至顶点 N 的权值。 输出格式输出仅一行，为所有三角形的顶点权值乘积之和的最小值。 数据范围 N≤50数据保证所有顶点的权值都小于10^9 输入样例： 5 121 122 123 245 231 输出样例： 12214884 题解：区间DP： DP[ i ] [ j ]表示当底边为i ~ j时, 权值的最小值,枚举顶点k,因为不能相交,所以k属于[i + 1, j - 1], 这样我们就可以把图形划分为3个区间(i ~ k - 1), (k + 1, r) 和(i, j, k)这个三角形 所以d[ l ] [ r ] = min(d[ l ] [ r ], d[ l ] [ k - 1] + d[k + 1] [ r ] + w[l] * w[k] * w[r]） 这道题要用高精度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const int N = 55, M = 35;int n, a[N];ll f[N][N][M];ll c[M];void add(ll a[], ll b[]) //高精度加法&#123; ll t = 0; memset(c, 0, sizeof c); for(int i = 0; i &lt; M; i++)&#123; t += a[i] + b[i]; c[i] = t % 10; t /= 10; &#125; memcpy(a, c, sizeof c);&#125;void mul(ll a[], ll b)&#123; //高精度乘法 memset(c, 0, sizeof c); ll t = 0; for(int i = 0; i &lt; M; i++)&#123; t += a[i] * b; c[i] = t % 10; t /= 10; &#125; memcpy(a, c, sizeof c);&#125;int cmp(ll a[], ll b[]) //高精度比较&#123; for(int i = M - 1; i &gt;= 0; i--)&#123; if(a[i] &gt; b[i])return 1; else if(a[i] &lt; b[i])return -1; &#125; return 0;&#125;void print(ll a[]) //高精度输出&#123; int k = M - 1; while(k &gt; 0 &amp;&amp; a[k] == 0)k--; while(k &gt;= 0)&#123; cout &lt;&lt; a[k]; k--; &#125; cout &lt;&lt; endl;&#125;int main()&#123; int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; a[i]; &#125; ll temp[N]; for(int len = 3; len &lt;= n; len++)&#123; //枚举长度 for(int l = 1; l + len - 1 &lt;= n; l++)&#123; //枚举区间 int r = l + len - 1; f[l][r][M - 1] = 1; //先初始化为最大值，让最高位等于1 for(int k = l + 1; k &lt; r; k++)&#123; memset(temp, 0, sizeof temp); temp[0] = a[l]; mul(temp, a[k]); mul(temp, a[r]); add(temp, f[l][k]); add(temp, f[k][r]); if(cmp(f[l][r], temp) &gt; 0)&#123; memcpy(f[l][r], temp, sizeof temp); &#125; &#125; &#125; &#125; print(f[1][n]); return 0;&#125;","path":"2019/11/09/动态规划/区间DP/凸多边形的划分-区间DP/","date":"11-09","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"区间DP","slug":"区间DP","permalink":"http://zhumenger.top/tags/区间DP/"}]},{"title":"加分二叉树(区间DP)","text":"加分二叉树题目传送门题目描述设一个n个节点的二叉树tree的中序遍历为（1,2,3,…,n），其中数字1,2,3,…,n为节点编号。 每个节点都有一个分数（均为正整数），记第i个节点的分数为di，tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下： subtree的左子树的加分 × subtree的右子树的加分 ＋ subtree的根的分数 若某个子树为空，规定其加分为1。叶子的加分就是叶节点本身的分数，不考虑它的空子树。 试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。 要求输出： （1）tree的最高加分 （2）tree的前序遍历 输入格式第1行：一个整数n，为节点个数。 第2行：n个用空格隔开的整数，为每个节点的分数（0&lt;分数&lt;100）。 输出格式第1行：一个整数，为最高加分（结果不会超过4,000,000,000）。 第2行：n个用空格隔开的整数，为该树的前序遍历。如果存在多种方案，则输出字典序最小的方案。 数据范围n&lt;30 输入样例： 5 5 7 1 2 10 输出样例： 1453 1 2 4 5 题解：区间DP同样适用于二叉树： 枚举二叉树的节点个数 len, 枚举二叉树的组成区间(l, r), 枚举根节点 k, 从而得到状态转移方程式： f[ l ] [ r ] = max(f[ l ] [ r ], f[ l ] [ k - 1] + f[ l ] [k + 1], + w[k]) 更新最大值的同时, 记录每一个树的根节点 12345678910111213141516171819202122232425262728293031323334353637383940414243//DP[i][j] 表示区间[i ~ j] 表示为一个二叉树时的分数的最大值#include&lt;iostream&gt;using namespace std;const int N = 35;int n;int w[N];int f[N][N], g[N][N]; // g数组用来存储每一个区间的根节点void dfs(int l, int r, int k)&#123; if(l &gt; r)return ; cout &lt;&lt; k &lt;&lt; ' '; dfs(l, k - 1, g[l][k - 1]); dfs(k + 1, r, g[k + 1][r]);&#125;int main()&#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i]; for(int len = 1; len &lt;= n; len++)&#123; //枚举区间长度 for(int l = 1; l + len - 1 &lt;= n; l++)&#123; //枚举起点 int r = l + len - 1; //得到右端点 if(len == 1)&#123; //如果是根节点 f[l][r] = w[l]; g[l][r] = l; &#125; else&#123; for(int k = l; k &lt;= r; k++)&#123; //枚举根节点 //判断左子树是否为空 int left = k == l ? 1 : f[l][k - 1]; //得到左子树和右子树的分数 int right = k == r ? 1 : f[k + 1][r]; if(left * right + w[k] &gt; f[l][r])&#123; //更新最大值 f[l][r] = left * right + w[k]; g[l][r] = k; //跟新根节点 &#125; &#125; &#125; &#125; &#125; cout &lt;&lt; f[1][n] &lt;&lt; endl; dfs(1, n, g[1][n]); return 0;&#125;","path":"2019/11/09/动态规划/区间DP/加分二叉树-区间DP/","date":"11-09","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"区间DP","slug":"区间DP","permalink":"http://zhumenger.top/tags/区间DP/"}]},{"title":"环形石子合并(区间DP)","text":"环形石子合并题目传送门题目描述将 n 堆石子绕圆形操场排放，现要将石子有序地合并成一堆。 规定每次只能选相邻的两堆合并成新的一堆，并将新的一堆的石子数记做该次合并的得分。 请编写一个程序，读入堆数 n 及每堆的石子数，并进行如下计算： 选择一种合并石子的方案，使得做 n−1 次合并得分总和最大。 选择一种合并石子的方案，使得做 n−1 次合并得分总和最小。 输入格式第一行包含整数 n，表示共有 n 堆石子。 第二行包含 n 个整数，分别表示每堆石子的数量。 输出格式输出共两行： 第一行为合并得分总和最小值， 第二行为合并得分总和最大值。 数据范围 1≤n≤200 输入样例： 4 4 5 9 4 输出样例： 4354 题解：区间DP： *预处理前缀和，因为是环形, 所以数组扩大俩倍, 枚举长度，枚举起点和终点, 得到状态转移方程式： * f[ l ] [ r ] = min(f[ l ] [ r ], f[ l ] [ k ] + f[ k + 1] [ r ] + sum[r] - sum[l - 1]); 1234567891011121314151617181920212223242526272829303132333435363738394041//区间DP#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 410, INF = 0x3f3f3f3f;int a[N], sum[N], g[N][N], f[N][N];int main()&#123; int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++)&#123; //环形扩大俩倍 cin &gt;&gt; a[i]; a[i + n] = a[i]; &#125; for(int i = 1; i &lt;= 2 * n; i++)&#123; //求前缀和 sum[i] = sum[i - 1] + a[i]; &#125; memset(f, 0x3f, sizeof f); memset(g, -0x3f, sizeof g); for(int len = 1; len &lt;= n; len++)&#123; //枚举长度 for(int l = 1; l + len - 1 &lt;= n * 2; l++)&#123; //枚举起点 int r = l + len - 1; //得到终点 if(l == r)g[l][r] = f[l][r] = 0; // l == r 花费为0 else &#123; for(int k = l; k &lt; r; k++)&#123; // 枚举中点， 分为俩部分 g[l][r] = max(g[l][r], g[l][k] + g[k + 1][r] + sum[r] - sum[l - 1]); f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + sum[r] - sum[l - 1]); &#125; &#125; &#125; &#125; int Max = -INF; int Min = INF; for(int i = 1; i &lt;= n; i++)&#123; Max = max(Max, g[i][i + n - 1]); Min = min(Min, f[i][i + n - 1]); &#125; cout &lt;&lt; Min &lt;&lt; endl; cout &lt;&lt; Max &lt;&lt; endl; return 0;&#125;","path":"2019/11/09/动态规划/区间DP/环形石子合并-区间DP/","date":"11-09","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"区间DP","slug":"区间DP","permalink":"http://zhumenger.top/tags/区间DP/"}]},{"title":"Acwing.炮兵阵地（状压DP）","text":"Acwing.炮兵阵地题目传送门题目描述司令部的将军们打算在N * M的网格地图上部署他们的炮兵部队。一个N * M的地图由N行M列组成，地图的每一格可能是山地（用”H” 表示），也可能是平原（用”P”表示），如下图。 在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示： 如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。 图上其它白色网格均攻击不到。 从图上可见炮兵的攻击范围不受地形的影响。 现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。 输入格式第一行包含两个由空格分割开的正整数，分别表示N和M； 接下来的N行，每一行含有连续的M个字符(‘P’或者’H’)，中间没有空格。按顺序表示地图中每一行的数据。 输出格式仅一行，包含一个整数K，表示最多能摆放的炮兵部队的数量。 数据范围 N ≤ 100, M ≤ 10 输入样例： 5 4PHPPPPHHPPPPPHPPPHHP 输出样例： 6 题解：状态压缩DP： 1.明确状态表达式：假设f[ i ] [ j ] [ k ] 表示当前为第 i 行， 状态为 j ， 第 i - 1 的状态为 k的方案数； 2.预处理出地图的状图以及每一行所有状态的合法方案：即满足(state &gt;&gt; i &amp; 1) &amp;&amp; ((state &gt;&gt; i + 1 &amp; 1) | (state &gt;&gt; i + 2 &amp; 1)) == 0 3.假设第 i - 2 的状态为u，ones[ j ]表示该状态下的炮兵数量(1的个数), 只要这些状态满足合法方案，即： （state[ j ] &amp; state[ k ]) | (state[ u ] &amp; state[ j ]) | (state[ u ] &amp; state[ k ]) == 0 则可以得到状态转移方程式为： f[ i ] [ j ] [ k ] = max(f[ i ] [ j ] [ k ], f[ i - 1 ] [ k ] [ u ] + ones[ j ]); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 11;int n, m;int g[110];int state[1 &lt;&lt; N], ones[1 &lt;&lt; N];int f[2][1 &lt;&lt; N][1 &lt;&lt; N];bool check(int state) //判断该状态是否合法&#123; for(int i = 0; i &lt; m; i++) &#123; if((state &gt;&gt; i &amp; 1) &amp;&amp; ((state &gt;&gt; i + 1 &amp; 1) | (state &gt;&gt; i + 2 &amp; 1))) return false; &#125; return true;&#125;int get_ones(int x) //获取每个状态1的个数&#123; int sum = 0; while(x)&#123; if(x &amp; 1)sum++; x &gt;&gt;= 1; &#125; return sum;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; char c; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; cin &gt;&gt;c; if(c == 'H')g[i] += 1 &lt;&lt; (m - j); // 把每一行的状态记录下来 1 表示山地 &#125; &#125; int cnt = 0; for(int i = 0; i &lt; 1 &lt;&lt; m; i++)&#123; //预处理出合法状态 if(check(i))&#123; state[cnt] = i; ones[cnt++] = get_ones(i); &#125; &#125; int ans = 0; int t = 0; //滚动数组 for(int i = 1; i &lt;= n; i++)&#123; for(int j = 0; j &lt; cnt; j++) // 第i行的状态 for(int k = 0; k &lt; cnt; k++) // 第i - 1行的状态 for(int u = 0; u &lt; cnt; u++)&#123; //第i - 2行的状态 int a = state[j], b = state[k], c = state[u]; if((a &amp; b) | (a &amp; c) | (b &amp; c))continue; //判断是否合法 if(a &amp; g[i] | b &amp; g[i - 1])continue; //不能放在山地上 f[t][j][k] = max(f[t][j][k], f[t ^ 1][k][u] + ones[j]); ans = max(ans, f[t][j][k]); &#125; t ^= 1; &#125; cout &lt;&lt;ans &lt;&lt; endl; return 0;&#125;","path":"2019/10/30/动态规划/状压DP/Acwing-炮兵阵地（状压DP）/","date":"10-30","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"状压DP","slug":"状压DP","permalink":"http://zhumenger.top/tags/状压DP/"}]},{"title":"Acwing.玉米田（状压DP）","text":"Acwing.玉米田(状压DP)题目传送门题目描述农夫约翰的土地由M*N个小方格组成，现在他要在土地里种植玉米。 非常遗憾，部分土地是不育的，无法种植。 而且，相邻的土地不能同时种植玉米，也就是说种植玉米的所有方格之间都不会有公共边缘。 现在给定土地的大小，请你求出共有多少种种植方法。 土地上什么都不种也算一种方法。 输入格式第1行包含两个整数M和N。 第2..M+1行：每行包含N个整数0或1，用来描述整个土地的状况，1表示该块土地肥沃，0表示该块土地不育。 输出格式输出总种植方法对100000000取模后的值。 数据范围 1 ≤ M,N ≤ 12 输入样例： 2 31 1 10 1 0 输出样例： 9 题解：状态压缩DP： 1.明确状态表达式：假设第 i 行的状态为 j ，第 i - 1 的状态为 k ，DP[ i ] [ j ]表示前 i 行，状态为 j 时的方案数 则：d[ i ] [ j ] = d[ i ] [ j ] + d[ i - 1 ] [ k ] *2.先预处理出地图的状态, 并预处理出每一行所有状态的合法方案, * *3.假设第 i 行的状态为state[ j ], 地图状态为map[ i ]，则必须满足state[ j ] | map[ i ] == map[ i ] * 4.相邻俩行不能有相临边， 则state[ j ] &amp; state[ k ] == 0 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;const int N = 15, M = 1 &lt;&lt; 12, mod = 100000000;int mp[M], temp[M];int d[N][M];int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt;m; int x; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; cin &gt;&gt; x; if(x)mp[i] += (1 &lt;&lt; (m - j)); //预处理出地图的状态 &#125; &#125; int cnt = 0; for(int i = 0; i &lt; 1 &lt;&lt; m ;i++)&#123; if(i &amp; (i &lt;&lt; 1))continue; // 去掉不合法的状态 temp[cnt++] = i; &#125; d[0][0] = 1; for(int i = 1; i &lt;= n; i++)&#123; //枚举每一行 for(int j = 0; j &lt; cnt; j++)&#123; //枚举第i行的所有状态 for(int k = 0; k &lt; cnt; k++)&#123; //枚举第i - 1行的所有状态 if((temp[j] &amp; temp[k]) || ((temp[j] | mp[i]) != mp[i]))continue; //不能与上一行处于同一列，且不能再地图为0的地方 d[i][j] = (d[i][j] + d[i - 1][k]) % mod; &#125; &#125; &#125; int ans = 0; for(int i = 0; i &lt; cnt; i++) ans = (ans + d[n][i]) % mod; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","path":"2019/10/30/动态规划/状压DP/Acwing-玉米田（状压DP）/","date":"10-30","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"状压DP","slug":"状压DP","permalink":"http://zhumenger.top/tags/状压DP/"}]},{"title":"Acwing.骑士（状压DP）","text":"Acwing.骑士（状压DP）题目传送门题目描述在 n×n 的棋盘上放 k 个国王，国王可攻击相邻的 8 个格子，求使它们无法互相攻击的方案总数。 输入格式共一行，包含两个整数 n 和 k。 输出格式共一行，表示方案总数，若不能够放置则输出00。 数据范围 1 ≤ n ≤ 100 ≤ k ≤ n^2 输入样例： 3 2 输出样例： 16 题解：状态压缩DP： dp[ i ] [ j ] [ k ]表示第 i 行，状态为 j ， 放国王的个数为k时的方案数其中j用二进制表示, 1表示该位置上放国王，0表示该位置上不放国王 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;const int N = 12;typedef long long ll;ll d[12][1 &lt;&lt; N][110];int n, m;int num[1 &lt;&lt; N], temp[1 &lt;&lt; N];int get_ones(int x)&#123; int cnt = 0; while(x)&#123; if(x &amp; 1)cnt++; x &gt;&gt;= 1; &#125; return cnt;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; int t = 0; for(int i = 0; i &lt; 1 &lt;&lt; n; i++)&#123; //预处理出每一行的n种状态, 1表示放了国王，0表示没有放国王 if(i &amp; (i &lt;&lt; 1))continue; //相邻俩个不能同为1 temp[t] = i; //记录该状态 num[t++] = get_ones(i); //记录该状态下国王的个数 &#125; d[0][0][0] = 1; for(int i = 1; i &lt;= n; i++)&#123; //枚举每一行 for(int j = 0; j &lt; t; j++)&#123; //枚举改行的所有状态 for(int k = 0; k &lt; t; k++)&#123; //枚举前一行所有的状态 //同一列上的不能全为1, 且对角不能都是1 if(temp[j] &amp; temp[k] || (temp[j] &gt;&gt; 1 &amp; temp[k] || temp[j] &lt;&lt; 1 &amp; temp[k]))continue; //枚举第i - 1行放国王的个数 for(int r = 0; r + num[j] &lt;= m; r++)&#123; d[i][j][r + num[j]] += d[i - 1][k][r]; &#125; &#125; &#125; &#125; ll ans = 0; for(int i = 0; i &lt; t; i++) //输出所有状态的总和 ans += d[n][i][m]; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","path":"2019/10/30/动态规划/状压DP/Acwing-骑士（状压DP）/","date":"10-30","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"状压DP","slug":"状压DP","permalink":"http://zhumenger.top/tags/状压DP/"}]},{"title":"动态规划之回文串","text":"一.DP求回文串[POJ-1159]A palindrome is a symmetrical string, that is, a string read identically from left to right as well as from right to left. You are to write a program which, given a string, determines the minimal number of characters to be inserted into the string in order to obtain a palindrome. As an example, by inserting 2 characters, the string “Ab3bd” can be transformed into a palindrome (“dAb3bAd” or “Adb3bdA”). However, inserting fewer than 2 characters does not produce a palindrome. 输入描述Your program is to read from standard input. The first line contains one integer: the length of the input string N, 3 &lt;= N &lt;= 5000. The second line contains one string with length N. The string is formed from uppercase letters from ‘A’ to ‘Z’, lowercase letters from ‘a’ to ‘z’ and digits from ‘0’ to ‘9’. Uppercase and lowercase letters are to be considered distinct. 输出描述Your program is to write to standard output. The first line contains one integer, which is the desired minimal number. 输入样例 5 Ab3bd 输出样例 2 题目描述： 给你一个字符串，问最少需要添加几个字符可以将该字符串变为回文串 设原序列S的逆序列为S’，最少需要补充的字母数 = 原序列S的长度 — S和S’的最长公共子串长度 代码如下： 123456789101112131415161718192021222324252627282930//题目意思呢就是给你一串字符，问最少需要插入几个字符能形成回文字符串//解题思路：这就是求该字符串正序和逆序最长公共子序列问题//这样就可以找到对称着的最长公共子序列了，然后用总长度减去这个就是我们要求的了。//这道题超内存, 所以要用#include&lt;iostream&gt;using namespace std;const int N = 5010;char s1[N], s2[N];int d[2][N];int main()&#123; int n; cin &gt;&gt;n; cin &gt;&gt; (s1 + 1); for(int i = 1; i &lt;= n; i++) s2[i] = s1[n - i + 1]; int ans = 0; int t = 0; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; if(s1[i] == s2[j]) d[t][j] = d[t ^ 1][j - 1] + 1; else d[t][j] = max(d[t ^ 1][j], d[t][j - 1]); ans = max(ans, d[t][j]); &#125; t ^= 1; &#125; cout &lt;&lt; n - ans &lt;&lt; endl; return 0;&#125; 二.DP求变成回文串的最小花费[POJ-3280]题目描述Keeping track of all the cows can be a tricky task so Farmer John has installed a system to automate it. He has installed on each cow an electronic ID tag that the system will read as the cows pass by a scanner. Each ID tag’s contents are currently a single string with length M (1 ≤ M ≤ 2,000) characters drawn from an alphabet of N (1 ≤ N ≤ 26) different symbols (namely, the lower-case roman alphabet). Cows, being the mischievous creatures they are, sometimes try to spoof the system by walking backwards. While a cow whose ID is “abcba” would read the same no matter which direction the she walks, a cow with the ID “abcb” can potentially register as two different IDs (“abcb” and “bcba”). FJ would like to change the cows’s ID tags so they read the same no matter which direction the cow walks by. For example, “abcb” can be changed by adding “a” at the end to form “abcba” so that the ID is palindromic (reads the same forwards and backwards). Some other ways to change the ID to be palindromic are include adding the three letters “bcb” to the begining to yield the ID “bcbabcb” or removing the letter “a” to yield the ID “bcb”. One can add or remove characters at any location in the string yielding a string longer or shorter than the original string. Unfortunately as the ID tags are electronic, each character insertion or deletion has a cost (0 ≤ cost ≤ 10,000) which varies depending on exactly which character value to be added or deleted. Given the content of a cow’s ID tag and the cost of inserting or deleting each of the alphabet’s characters, find the minimum cost to change the ID tag so it satisfies FJ’s requirements. An empty ID tag is considered to satisfy the requirements of reading the same forward and backward. Only letters with associated costs can be added to a string. 输入格式Line 1: Two space-separated integers: N and MLine 2: This line contains exactly M characters which constitute the initial ID stringLines 3.. N+2: Each line contains three space-separated entities: a character of the input alphabet and two integers which are respectively the cost of adding and deleting that character. 输出格式Line 1: A single line with a single integer that is the minimum cost to change the given name tag. 输入样例 3 4abcba 1000 1100b 350 700c 200 800 输出样例 900 题目大意： 给你一个字符串，可以对每个字符串进行添加或删除，添加和删除都有对应的花费，问：变为回文串的最小花费 123456789101112131415161718192021222324252627282930313233343536//我们用dp[i][j]表示将i~j位置的字符串变为回文串的最低消费。//当str[i]==str[j]时：dp[i][j]==dp[i+1][j-1]//当i+1到j是回文串时：dp[i][j]==dp[i+1][j] + min ( add[str[i]]，reduce[str[i]] )//当i到j-1是回文串时：dp[i][j]==dp[i][j-1] + min( add[str[j]]，reduce[str[j]] )#include&lt;iostream&gt;using namespace std;const int N = 2010, INF = 0x3f3f3f3f;char s[N];int cost[N], d[N][N];int main()&#123; int n, m; cin &gt;&gt;n &gt;&gt; m; cin &gt;&gt; (s + 1); char c; int a, b; for(int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; c &gt;&gt; a &gt;&gt; b; cost[c - 'a'] = min(a, b); &#125; //区间DP for(int len = 2; len &lt;= m; len++)&#123; // 枚举长度 for(int l = 1, r = len; r &lt;= m; l++, r ++)&#123; //枚举起点和终点 d[l][r] = INF; if(s[l] == s[r]) d[l][r] = d[l + 1][r - 1]; else &#123; d[l][r] = min(d[l][r], d[l + 1][r] + cost[s[l] - 'a']); d[l][r] = min(d[l][r], d[l][r - 1] + cost[s[r] - 'a']); &#125; &#125; &#125; cout &lt;&lt; d[1][m] &lt;&lt; endl; return 0;&#125;","path":"2019/10/10/动态规划/基础DP/动态规划之回文串/","date":"10-10","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"}]},{"title":"窗内的星星(线段树 + 扫描线)","text":"题目描述在一个天空中有很多星星（看作平面直角坐标系），已知每颗星星的坐标和亮度（都是整数）。 求用宽为W、高为H的矩形窗户（W,H为正整数）能圈住的星星的亮度总和最大是多少。（矩形边界上的星星不算） 输入格式输入包含多组测试用例。 每个用例的第一行包含3个整数：n，W，H，表示星星的数量，矩形窗口的宽和高。 然后是n行，每行有3个整数：x，y，c，表示每个星星的位置（x，y）和亮度。 没有两颗星星在同一点上。 输出格式每个测试用例输出一个亮度总和最大值。 每个结果占一行。 数据范围 1≤n≤10000,1≤W,H≤1000000,0≤x,y&lt;2 ^ 31 输入样例： 3 5 41 2 32 3 26 3 13 5 41 2 32 3 25 3 1 输出样例： 5 6 题解：1.因为我们已经知道了矩形的长和宽，所以对于任意一个星星(x, y, c), 都可以得到一个确切的矩形，所以每一个 星星，我们建立一个固定大小的矩形，矩形的左下角为(x, y), 因为边界上的星星不算,所以右上角表示为(x + w, y + h - 1),目标是求出固定矩形区域内的最大值 2.所以这道题我们可以用扫描线来做,取出每个区域的左右边界,保存俩个四元组(x, y, y + h - 1, c), (x + w, y, y + h - 1, -c)并将这些四元组按照x坐标排序 3.同时用线段树来维护纵坐标的区间最大值, 逐一扫描四元组(x, y1, y2, c), 并执行线段树的修改操作,将[y1, y2]区间 上的值都加上c, 不断向上更新父节点最大值,然后得到根节点的dat值得到最终的答案 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int N = 20010;struct node&#123; //存四元组 int x, y1, y2, dat;&#125;a[N * 2];struct p&#123; //树 int l, r; ll dat, add;&#125;t[N * 4];int mp[N];bool cmp(node a, node b) //将x坐标从小到大排序&#123; if(a.x == b.x)return a.dat &lt; b.dat; return a.x &lt; b.x;&#125;void build(int p, int l, int r) //建树&#123; t[p].l =l, t[p].r = r; t[p].add = 0, t[p].dat = 0; if(l == r)return ; int mid = (l + r) / 2; build(p * 2, l, mid); build(p * 2 + 1, mid + 1, r);&#125;void spread(int p) //表示p节点已经被修改，但子节点还没有被修改&#123; //修改子节点，并给子节点打延迟标记 t[p * 2].dat += t[p].add; t[p * 2 + 1].dat += t[p].add; t[p * 2].add += t[p].add; t[p * 2 + 1].add += t[p].add; t[p].add = 0; //清除p的标记&#125;//线段树维护的内容是在区间1 ~ m内,区域(x, y) ~ (x + w, y + h)亮度的最大值void change(int p, int l, int r, int x)&#123; if(l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r)&#123; t[p].add += x; t[p].dat += x; return ; &#125; if(t[p].add)spread(p);//延迟标记 int mid =(t[p].l + t[p].r) / 2; if(l &lt;= mid) change(p * 2, l, r, x); if(r &gt; mid) change(p * 2 + 1, l, r, x); t[p].dat = max(t[p * 2].dat, t[p * 2 + 1].dat); //更新节点&#125;int main()&#123; int n, w, h, x, y, c; while(scanf(\"%d%d%d\",&amp;n, &amp;w, &amp;h) != EOF)&#123; int num = 0; for(int i = 1; i &lt;= n; i++)&#123; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;c); //矩形边界上的星星不算，所以将矩形的上边界减1 a[++num] = &#123;x, y, y + h - 1, c&#125;; mp[num] = y; a[++num] = &#123;x + w, y, y + h - 1, -c&#125;; mp[num] = y + h - 1; &#125; sort(mp + 1, mp + 1 + num); int m = unique(mp + 1, mp + 1 + num) - mp - 1; //离散化 + 去重 for(int i = 1; i &lt;= num; i++)&#123; //预处理出所有坐标离散化之后的结果 a[i].y1 = lower_bound(mp + 1, mp + 1 + m, a[i].y1) - mp; a[i].y2 = lower_bound(mp + 1, mp + 1 + m, a[i].y2) - mp; &#125; sort(a + 1, a + 1 + num, cmp); build(1, 1, m); //建树 ll ans = 0; for(int i = 1; i &lt;= num; i++)&#123; change(1, a[i].y1, a[i].y2, a[i].dat); ans = max(ans, t[1].dat); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/09/14/数据结构进阶/线段树/窗内的星星-线段树-扫描线/","date":"09-14","excerpt":"","tags":[{"name":"数据结构进阶","slug":"数据结构进阶","permalink":"http://zhumenger.top/tags/数据结构进阶/"},{"name":"线段树","slug":"线段树","permalink":"http://zhumenger.top/tags/线段树/"}]},{"title":"求多个矩形面积(线段树+扫描线)","text":"题目描述有几个古希腊书籍中包含了对传说中的亚特兰蒂斯岛的描述。 其中一些甚至包括岛屿部分地图。 但不幸的是，这些地图描述了亚特兰蒂斯的不同区域。 您的朋友Bill必须知道地图的总面积。 你自告奋勇写了一个计算这个总面积的程序。 输入格式输入包含多组测试用例。 对于每组测试用例，第一行包含整数n，表示总的地图数量。 接下来n行，描绘了每张地图，每行包含四个数字x1,y1,x2,y2x1,y1,x2,y2（不一定是整数）,(x1,y1)(x1,y1)和(x2,y2)(x2,y2)分别是地图的左上角位置和右下角位置。 当输入用例n=0时，表示输入终止，该用例无需处理。 输出格式每组测试用例输出两行。 第一行输出”Test case #k”，其中k是测试用例的编号，从1开始。 第二行输出“Total explored area：a”，其中a是总地图面积（即此测试用例中所有矩形的面积并，注意如果一片区域被多个地图包含，则在计算总面积时只计算一次），精确到小数点后两位数。 在每个测试用例后输出一个空行。 数据范围 1≤n≤100,0≤x1&lt;x2≤100000,0≤y1&lt;y2≤100000 输入样例： 2 10 10 20 2015 15 25 25.50 输出样例： Test case #1Total explored area: 180.00 扫描线：现在假设我们有一根线，从下往上开始扫描 如图所示，我们可以把整个矩形分成如图若干个颜色不同的小矩形，我们要做到就是求出各个小矩形的面积之和： 1.首先我们可以先将y坐标从小到大排序，这样我们便可以得到每个小矩形的高度：h[i] = y[i + 1] - y[i] 2.如果我们知道了小矩形的长度，那么我们便可以求出该小矩形的面积了, 我们知道每个矩形都有上下俩条边，我 们把下面的这条边叫做入边，上面的边叫做出边，当我们遍历到入边时，就将该区间的cnt值加一，表示这条边已 经被覆盖，当遍历到出边时就将该区间的cnt值减一，表示该区间被覆盖的次数减一，这样我们便可以用线段树来 维护被覆盖区间的总长度, 用区间的总长度再乘以高度便得到了每个小矩形的面积 3.y的值很大，所以我们可以用离散化来做, 排序并去重，得到 m 条线段和 m - 1个区间 4.这里有一个细节,那就是每个节点t[x].l ~ t[x].r 维护的其实是线段t[x].l ~ (t[x].r+1)，即线段t[x].l ~ (t[x].r+1) 表示 的空间为 t[x].l ~ t[x].r,也就是若干条线段，因为点分成左右子节点的时候会有问题(比如[3,3]代表的只是一个点） 5.我们要把每个节点看成是一条线段。对于每个节点维护两个值： cnt：这个点所代表的线段被覆盖了多少次。 len：以这个点为根的子树中被覆盖的区间一共有多长。 当一条线段进来的时候，在代表它的那若干个节点上cnt++，其它节点cnt不用加。 然后len维护的就是这个区间内那些cnt &gt; 0的节点所覆盖的区间总长。 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;struct node&#123; double x1, x2, y; //记录该矩形的长度和高度 int cnt; //表示该边是入边还是出边&#125;a[N * 2];double mp[N * 2]; //实现y坐标的离散化struct p&#123; //线段树用来维护被覆盖区间的总长度 int l, r, cnt; double len; //记录区间的长度&#125;t[N * 4];bool cmp(node a, node b)&#123; return a.y &lt; b.y; //将y坐标从小到大排序&#125;void build(int p, int l, int r) //建树&#123; t[p].l = l, t[p].r = r; t[p].cnt = 0, t[p].len = 0; if(l == r)return ; int mid = (l + r) / 2; build(p * 2, l, mid); build(p * 2 + 1, mid + 1, r);&#125;void get_len(int p) //过去节点p的长度&#123; if(t[p].cnt &gt;= 1) //如果该区间完全被覆盖 //上面我已经讲过, t[p].l ~ t[p].r + 1维护的是区间 t[p].l ~ t[p].r t[p].len = mp[t[p].r + 1] - mp[t[p].l]; //得到该区间的长度 else if(t[p].l == t[p].r)//叶子节点,没有意义，长度为0 t[p].len = 0; //否则等于俩个子节点的长度之和 else t[p].len = t[p * 2].len + t[p * 2 + 1].len;&#125;void change(int p, int l, int r, int x)&#123; if(l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r)&#123; t[p].cnt += x; //计算该区间被覆盖的次数 get_len(p); return ; &#125; int mid = (t[p].l + t[p].r) / 2; if(l &lt;= mid)change(p * 2, l, r, x); if(r &gt; mid )change(p * 2 + 1, l, r , x); get_len(p);&#125;int main()&#123; int ts = 0, n; double x1, x2, y1, y2; while(cin &gt;&gt; n &amp;&amp; n)&#123; int num = 0; for(int i = 1; i &lt;= n; i++)&#123; scanf(\"%lf %lf %lf %lf\", &amp;x1, &amp;y1, &amp;x2, &amp;y2); a[num] = &#123;x1, x2, y1, 1&#125;; mp[num++] = x1; a[num] = &#123;x1, x2, y2, -1&#125;; mp[num++] = x2; &#125; sort(a, a + num, cmp);//按照y坐标从小到大排序 sort(mp, mp + num); int m = unique(mp, mp + num) - mp; //去重 build(1, 0, m - 1); //建树 double ans = 0; for(int i = 0; i &lt; num; i++)&#123; int l = lower_bound(mp, mp + m, a[i].x1) - mp; int r = lower_bound(mp, mp + m, a[i].x2) - mp - 1; change(1, l, r, a[i].cnt); //t[l].len表示被覆盖的区间长度, a[i + 1].y - a[i].y表示该小矩形的高度 ans += t[1].len * (a[i + 1].y - a[i].y); &#125; //最后输出答案 printf(\"Test case #%d\\n\", ++ts); printf(\"Total explored area: %.2f \\n\\n\", ans); &#125; return 0;&#125;","path":"2019/09/13/数据结构进阶/线段树/求多个矩形面积(线段树 + 扫描线)/","date":"09-13","excerpt":"","tags":[{"name":"数据结构进阶","slug":"数据结构进阶","permalink":"http://zhumenger.top/tags/数据结构进阶/"},{"name":"线段树","slug":"线段树","permalink":"http://zhumenger.top/tags/线段树/"}]},{"title":"一个简单的整数问题2(线段树)","text":"延迟标记​ 在“区间修改”指令中，如果某个节点被修改区间[l, r]完全覆盖, 那么以该节点为根的整颗子树的所有节点存储的信息都会发生变化, 若逐一进行更新,将使得区间修改指令的时间复杂度增加O(N), 这是我们不能接受的 ​ 如果我们将修改区间的所有子树p逐一进行了更新，但在之后的指令中并没有用到，那之前更新p的整颗子树就是徒劳的。所以我们可以在l &lt;= pl &lt;= pr &lt;= r的情况下立即返回，只不过在回溯之前向节点 p 增加一个标记, 标记“该点曾经被修改过，但其子节点并没有被更新” ​ 如果在后续的指令中，需要从节点p向下递归,我们再检查p是否被标记，如有标记,则根据标记更新p的俩个子节点,同时p的俩个子节点增加标记,然后清除p的标记 ​ 也就是说，除了在修改指令中直接划分成的O(logN)个节点之外，对任意节点的修改都延迟到“在后续操作中递归进入它的子节点时”再执行，这样一来，每条查询或修改指令的时间复杂度又降低到了O(logN).这些标记被称为“延迟标记”。延迟标记提供了线段树从上往下传递信息的方式 题目描述给定一个长度为N的数列A，以及M条指令，每条指令可能是以下两种之一： 1、“C l r d”，表示把 A[l],A[l+1],…,A[r] 都加上 d。 2、“Q l r”，表示询问 数列中第 l~r 个数的和。 对于每个询问，输出一个整数表示答案。 输入格式第一行两个整数N,M。 第二行N个整数A[i]。 接下来M行表示M条指令，每条指令的格式如题目描述所示。 输出格式对于每个询问，输出一个整数表示答案。 每个答案占一行。 数据范围 1≤N,M≤10^5|d|≤10000|A[i]|≤1000000000 输入样例： 10 51 2 3 4 5 6 7 8 9 10Q 4 4Q 1 10Q 2 4C 3 6 3Q 2 4 输出样例： 4 559 15 这道题前面讲树状数组的时候已经讲过了： 一个简单的问题2（树状数组） 在这篇文章中，我们用线段树来解决这道题： 除了左右端点l，r以外，线段树的每个节点上保存了sum(区间和)、add(增量延迟标记)俩个值, 其中延迟标记的含义为“该节点曾经被修改，但其子节点尚未被更新”。它自身保存的信息应该是已经被修改完毕 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;using namespace std;typedef long long ll;const int N = 1e5 + 10;int a[N];struct p&#123; int l, r; ll sum, add; //区间和sum，延迟标记add&#125;;p t[N * 4];void build(int p, int l, int r)//建树&#123; t[p].l = l, t[p].r = r; if(l == r)&#123; t[p].sum = a[l]; return ; &#125; int mid = (l + r) / 2; build(p * 2, l, mid); build(p * 2 + 1, mid + 1, r); t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;&#125;void spread(int p) //该函数实现了延迟标记的向下传递&#123; if(t[p].add)&#123; t[p * 2].sum += t[p].add * (t[p * 2].r - t[p * 2].l + 1); //更新左子节点的信息 t[p * 2 + 1].sum += t[p].add * (t[p * 2 + 1].r - t[p * 2 + 1].l + 1);//更新右子节点的信息 t[p * 2].add += t[p].add; //记录延迟标记 t[p * 2 + 1].add += t[p].add; t[p].add = 0; //清除p节点的延迟标记 &#125;&#125;void change(int p, int l, int r, int d)&#123; if(l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r)&#123; t[p].sum += (ll)d * (t[p].r - t[p].l + 1); t[p].add += d; //给节点d打延迟标记，然后直接回溯 return ; &#125; spread(p); //下传延迟标记 int mid = (t[p].l + t[p].r) / 2; if(l &lt;= mid) change(p * 2, l, r, d); if(r &gt; mid) change(p * 2 + 1, l, r, d); t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;&#125;ll ask(int p, int l, int r)&#123; if(l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r)return t[p].sum; spread(p); //下传延迟标记 int mid = (t[p].l + t[p].r) / 2; ll val = 0; if(l &lt;= mid) val += ask(p * 2, l, r); if(r &gt; mid) val += ask(p * 2 + 1, l, r); return val;&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, 1, n); while(m--)&#123; char s[2]; scanf(\"%s\", s); int l, r, x; if(s[0] == 'C')&#123; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;x); change(1, l, r, x); &#125; else &#123; cin &gt;&gt; l &gt;&gt; r; printf(\"%lld\\n\", ask(1, l, r)); &#125; &#125; return 0;&#125;","path":"2019/09/10/数据结构进阶/线段树/一个简单的整数问题2-线段树/","date":"09-10","excerpt":"","tags":[{"name":"数据结构进阶","slug":"数据结构进阶","permalink":"http://zhumenger.top/tags/数据结构进阶/"},{"name":"线段树","slug":"线段树","permalink":"http://zhumenger.top/tags/线段树/"}]},{"title":"区间最大公约数(线段树)","text":"题目描述给定一个长度为N的数列A，以及M条指令，每条指令可能是以下两种之一： 1、“C l r d”，表示把 A[l],A[l+1],…,A[r] 都加上 d。 2、“Q l r”，表示询问 A[l],A[l+1],…,A[r] 的最大公约数(GCD)。 对于每个询问，输出一个整数表示答案。 输入格式第一行两个整数N,M。 第二行N个整数A[i]。 接下来M行表示M条指令，每条指令的格式如题目描述所示。 输出格式对于每个询问，输出一个整数表示答案。 每个答案占一行。 数据范围 N≤500000,M≤100000 输入样例： 5 51 3 5 7 9Q 1 5C 1 5 1Q 1 5C 3 3 6Q 2 4 输出样例： 1 24 题解：1.我们知道gcd(x, y) = gcd(x, y - x). 它可以进一步扩展到三个数的情况：gcd(x, y, z) = gcd(x, y - x, z - y).实际上,该性质对任意多个整数都成立 *2.所以我们可以构造一个数组 A 的差分序列数组 B, 其中B[i] = A[i] - A[i - 1], 并用线段树维护 B 的区间最大公约数，这样一来，询问“Q l r”，就等要求出gcd(A[l], ask(1, l + 1, r)), * 3.在指令“C l r x” 下，只有b[l] 加了 d, b[r + 1] 被减掉了d，所以在线段树上只需俩次单点修改即可。另外询问时需要数列 a 中值,所以我们还需要一个可以实现“区间增加，单点查询”的树状数组来对数组 A 进行维护 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;iostream&gt;using namespace std;typedef long long ll;const int N = 5e5 + 10;ll a[N], b[N], c[N]; // 数组c维护a的区间和， b为a的差分序列struct p&#123; ll l, r; ll val;&#125;;p t[N * 4]; // struct 数组维护b区间的最大公约数ll n, m;ll gcd(ll a, ll b)&#123; return b ? gcd(b, a % b) : a;&#125;//树状数组用来维护数组a的区间和ll lowbit(ll x)&#123; return x &amp; -x;&#125;ll sum(ll x)&#123; ll ans = 0; while(x)&#123; ans += c[x]; x -= lowbit(x); &#125; return ans;&#125;void add(ll x, ll y)&#123; while(x &lt;= n)&#123; c[x] += y; x += lowbit(x); &#125;&#125;//线段树来维护区间最大公约数void build(ll p, ll l, ll r)&#123; t[p].l = l, t[p].r = r; if(l == r)&#123; t[p].val = b[l]; return ; &#125; ll mid = (l + r ) / 2; build(p * 2, l, mid); build(p * 2 + 1, mid + 1, r); t[p].val = gcd(t[p * 2].val, t[p * 2 + 1].val);&#125;void change(ll p, ll x, ll y)&#123; if(t[p].l == t[p].r)&#123; t[p].val += y; return ; &#125; ll mid = (t[p].l + t[p].r) / 2; if(x &lt;= mid)change(p * 2, x, y); else change(p * 2 + 1, x, y); t[p].val = gcd(t[p * 2].val, t[p * 2 + 1].val);&#125;ll ask(ll p, ll l, ll r)&#123; if(l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r)&#123; return t[p].val; &#125; ll val = 0; ll mid = (t[p].l + t[p].r) / 2; if(l &lt;= mid)val = gcd(val, ask(p * 2, l, r)); if(r &gt; mid)val = gcd(val, ask(p * 2 + 1, l, r)); return abs(val);&#125;int main()&#123; scanf(\"%lld%lld\", &amp;n, &amp;m); for(ll i = 1; i &lt;= n; i++)&#123; scanf(\"%lld\", &amp;a[i]); b[i] = a[i] - a[i - 1]; //得到a的差分序列 &#125; build(1, 1, n); //建树 while(m--)&#123; char s[2]; ll l, r, x; scanf(\"%s\", s); if(s[0] == 'Q')&#123; scanf(\"%lld%lld\", &amp;l, &amp;r); ll ans = a[l] + sum(l); //得到修改之后的a[l]; ll ans2 = l &lt; r ? ask(1, l + 1, r) : 0; printf(\"%lld\\n\", gcd(ans, ans2)); &#125; else&#123; scanf(\"%lld%lld%lld\", &amp;l, &amp;r, &amp;x); change(1, l, x); if(r &lt; n) change(1, r + 1, -x); add(l, x); add(r + 1, -x); &#125; &#125; return 0;&#125;","path":"2019/09/10/数据结构进阶/线段树/区间最大公约数-线段树/","date":"09-10","excerpt":"","tags":[{"name":"数据结构进阶","slug":"数据结构进阶","permalink":"http://zhumenger.top/tags/数据结构进阶/"},{"name":"线段树","slug":"线段树","permalink":"http://zhumenger.top/tags/线段树/"}]},{"title":"最大连续字段和(线段树)","text":"题目描述给定长度为N的数列A，以及M条指令，每条指令可能是以下两种之一： 1、“1 x y”，查询区间 [x,y] 中的最大连续子段和， 2、“2 x y”，把 A[x] 改成 y。 对于每个查询指令，输出一个整数表示答案。 输入格式第一行两个整数N,M。 第二行N个整数A[i]。 接下来M行每行3个整数k,x,y，k=1表示查询（此时如果x&gt;y，请交换x,y），k=2表示修改。 输出格式对于每个查询指令输出一个整数表示答案。 每个答案占一行。 数据范围 N≤500000,M≤100000 输入样例： 5 31 2 -3 4 51 2 32 2 -11 3 2 输出样例： 2 -1 题解：在线段树上的每个节点上，除了维护区间端点外, 再维护4个信息：区间和sum, 区间最大连续字段和dat, 在区间[l, r]中紧靠左端点l的左半边最大连续字段和lmax, 紧靠右端r的右半边最大连续字段和 rmax线段树的整体框架不变, 我们只需完善build和change函数中从下往上传递的信息 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;using namespace std;const int N = 5e5 + 10;struct pp&#123; int l, r, x; int lmax, rmax, sum;&#125;;pp t[N * 2];int a[N];void build(int p, int l, int r)&#123; t[p].l = l; t[p].r = r; if(t[p].l == t[p].r)&#123; t[p].x = t[p].sum = t[p].rmax = t[p].lmax = a[l]; return ; &#125; int mid = (l + r) / 2; build(p * 2, l, mid); build(p * 2 + 1, mid + 1, r); //计算区间和 t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum; ////记算该区间内与左端点相连的最大连续字段和, t[p].lmax = max(t[p * 2].lmax, t[p * 2].sum + t[p * 2 + 1].lmax); //记录该区间内与右端点相连的最大连续字段和 t[p].rmax = max(t[p * 2 + 1].rmax, t[p * 2 + 1].sum + t[p * 2].rmax); //// 记录该区间最大连续字段和, 在左边， 右边 和中间的选最大值 t[p].x = max(max(t[p * 2].x, t[p * 2 + 1].x), t[p * 2].rmax + t[p * 2 + 1].lmax);&#125;void change(int p, int x, int y)&#123; if(t[p].l == t[p].r)&#123; t[p].x = t[p].sum = t[p].rmax = t[p].lmax = y; return ; &#125; int mid = (t[p].l + t[p].r) / 2; if(x &lt;= mid)change(p * 2, x, y); else change(p * 2 + 1, x, y); //从下到上更新信息 t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum; t[p].lmax = max(t[p * 2].lmax, t[p * 2].sum + t[p * 2 + 1].lmax); t[p].rmax = max(t[p * 2 + 1].rmax, t[p * 2 + 1].sum + t[p * 2].rmax); t[p].x = max(max(t[p * 2].x, t[p * 2 + 1].x), t[p * 2].rmax + t[p * 2 + 1].lmax);&#125;pp ask(int p, int l, int r)&#123; if(l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r)&#123; return t[p]; &#125; int val = -(1 &lt;&lt; 30); int mid = (t[p].l + t[p].r) / 2; pp a, b, c; a.x = a.sum = a.lmax = a.rmax = val; //a用来记录左子节点的答案 b.x = b.sum = b.lmax = b.rmax = val; //b用来记录右子节点的答案 c.sum = 0; if(l &lt;= mid)&#123; a = ask(p * 2, l, r); c.sum += a.sum; &#125; if(r &gt; mid)&#123; b = ask(p * 2 + 1, l, r); c.sum += b.sum; &#125; c.x = max(max(a.x, b.x), a.rmax + b.lmax); c.lmax = max(a.lmax, a.sum + b.lmax); c.rmax = max(b.rmax, b.sum + a.rmax); return c;&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, 1, n); while(m--)&#123; int a, x, y; scanf(\"%d%d%d\", &amp;a, &amp;x, &amp;y); if(a == 1)printf(\"%d\\n\", ask(1, min(x, y), max(x, y)).x); else if(a == 2)change(1, x, y); &#125; return 0;&#125;","path":"2019/09/10/数据结构进阶/线段树/最大连续字段和-线段树/","date":"09-10","excerpt":"","tags":[{"name":"数据结构进阶","slug":"数据结构进阶","permalink":"http://zhumenger.top/tags/数据结构进阶/"},{"name":"线段树","slug":"线段树","permalink":"http://zhumenger.top/tags/线段树/"}]},{"title":"线段树简介","text":"​ 线段树是一种基于分治思想的二叉树结构，用于在区间上进行信息统计： ​ 1.线段树的每个节点都代表一个区间 ​ 2.线段树具有唯一的根节点，代表的区间是整个统计范围，如[1, N]; ​ 3.线段树的每个叶节点都代表一个长度为1的元区间[x, x]; ​ 4.对于每个内部节点[l ,r], 它的左子节点是[l, mid], 右节点是[mid + 1，r],其中mid = (l + r) / 2 ​ 上图展示了一颗线段树。我们可以发现，除去树的最后一层，整颗线段树一定是一颗完全二叉树，树的深度为O(logN)。因此，我们可以按照与二叉树类似的“父子2倍”节点编号方法： ​ 1.根节点编号为1； ​ 2.编号为x的节点的左节点编号为 x * 2，右子节点编号为 x * 2 + 1； ​ 这样一来，我们便可以简单的用一个struct 数组来保存线段树，如果有N个叶子节点, 则满二叉树有N + N / 2 + N / 4 + … 2 + 1 = 2 * n - 1 个节点, 因为在一层可能会产生空余， 所以保存线段树的数组长度要不小于 4N才能保证数组不会越界。 线段树的建树​ 线段树的基本用途是对序列进行维护，支持查询与修改指令。给定一个长度为N的序列A，我们可以在区间[1, N] 上建立一颗线段树，每个叶子节点[i, i] 保存A[i] 的值。线段树的二叉树结构可以很方便地从下往上传递信息。以区间最大值问题为例，记dat(l, r) = max{A[i]}(l &lt;= i &lt;= r), 显然dat(l, r) = max(dat(l, mid), dat(mid + 1, r)); 下面这段代码建立了一颗线段树并在每个节点上保存了对应区间的最大值。 123456789101112131415161718struct p&#123; int l, int r; int dat;&#125; t[size * 4]; //struct 数组存线段树void build(int p, int l, int r)&#123; t[p].l = r, t[p].r = r; //节点p代表的区间[l, r]; if(l == r)&#123; //叶子节点 t[p].dat = a[l]; return ; &#125; int mid = (l + r) / 2; //折半 build(p * 2, l, mid); //左子节点[l, mid], 编号p * 2 build(p * 2 + 1, mid + 1, r);// 又子节点[mid + 1, r], 编号p * 2 + 1 t[p].dat = max(t[p * 2].dat, t[p * 2 + 1].dat); //从下往上传递信息&#125;build(1, 1, n);// 调用入口 线段树的单点修改​ 单点修改是一条形如 “C x v” 的指令，表示把A[x] 的值修改为 v； ​ 在线段树中，根节点(编号为1的节点) 是执行各种指令的入口。我们需要从根节点出发，递归找到代表区间 [x, x] 的叶节点，然后从下往上更新[x, x] 以及它的是所有祖先节点上保存的信息， 时间复杂度为O(logN), 代码如下： 12345678910111213void change(int p, int x, int y)&#123; if(t[p].l == t[p].r)&#123; //找到叶子节点 t[x].dat = y; return ; &#125; int mid = (t[p].l + t[p].r) / 2; if(x &lt;= mid)change(p * 2, x, y); //x属于左半区间 else change(p * 2 + 1, x, y); //x属于右半区间 t[p].dat = max(t[p * 2].val, t[p * 2 + 1].val);// 从下往上更新信息&#125;change(1, x, y); // 调用入口 线段树的区间查询​ 区间查询是一条形如 “Q l r” 的指令，例如查询序列A在区间 [L, R] 的最大值，我们只需要从根节点开始，递归执行以下过程： ​ 1.若 [l, r] 完全覆盖当前节点代表的区间，则立即回溯， 并且该节点的dat值为候选答案。 ​ 2.若左子节点与 [l, r] 有重叠部分，则递归访问左子节点 ​ 3.若右子节点与 [l, r] 有重叠部分，则递归访问又子节点 123456789int ask(int p, int l, int r)&#123; if(l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r)return t[p].dat; //区间完全包含 int mid = (t[p].l + t[p].r) / 2; //折半 int val = -(1 &lt;&lt; 30); //记录答案 if(l &lt;= mid)val = max(val, ask(p * 2, l, r)); //左子节点有重叠部分 if(r &gt; mid) val = max(val, ask(p * 2 + 1, l, r)); //右子节点有重叠部分 return val;&#125;","path":"2019/09/10/数据结构进阶/线段树/线段树简介/","date":"09-10","excerpt":"","tags":[{"name":"数据结构进阶","slug":"数据结构进阶","permalink":"http://zhumenger.top/tags/数据结构进阶/"},{"name":"线段树","slug":"线段树","permalink":"http://zhumenger.top/tags/线段树/"}]},{"title":"谜一样的牛(树状数组)","text":"题目描述有n头奶牛，已知它们的身高为 1~n 且各不相同，但不知道每头奶牛的具体身高。 现在这n头奶牛站成一列，已知第i头牛前面有Ai头牛比它低，求每头奶牛的身高。 输入格式第1行：输入整数n。 第2..n行：每行输入一个整数AiAi,第i行表示第i头牛前面有AiAi头牛比它低。（注意：因为第1头牛前面没有牛，所以并没有将它列出） 输出格式输出包含n行，每行输出一个整数表示牛的身高。 第i行输出第i头牛的身高。 数据范围 1≤n≤10^5 输入样例： 5 12 10 输出样例： 2 45 31 题解：1.如果最后一头奶牛前面有 An 头牛比它低, 显然Hn = An + 1 2.如果倒数第二头牛有 A(n - 1) 头牛比它低,那么： (1).若A(n - 1) &lt; An, 则它的身高H(n - 1) = A(n - 1) + 1; (2).若A(n - 1) &gt;= An, 则它的身高H(n - 1) = A(n - 1) + 2; 3.依此类推，我们可以得到, 如果第 k 头牛前面有 Ak 头牛比它低, 则 Hk 为1 ~ n中第Ak + 1小的并且还没有出现过的数 4.具体来说,我们建立一个长度为n的01序列的数组b,开始的时候初始化为1, 表示所有的数都可以用, 然后倒序遍历； 对于每一个 Ai 执行以下俩个操作： (1).查询序列 b 中第Ak + 1个1在什么位置, 这个位置便是第 i 头奶牛的身高Hi (2).把b[Hi]减1，表示该数已经用过了 5.我们可以用树状数组来维护序列b的前缀和, 并用二分来查找第Ak + 1个1的位置 具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int c[N], a[N], ans[N];int n, m;int lowbit(int x)&#123; return x &amp; -x;&#125;void add(int x, int y) //维护01序列 b 的前缀和&#123; while(x &lt;= n)&#123; c[x] += y; x += lowbit(x); &#125;&#125;int ask(int x) //找到1 ~ x 中有多少个1&#123; int ans = 0; while(x)&#123; ans += c[x]; x -= lowbit(x); &#125; return ans;&#125;int main()&#123; cin &gt;&gt; n; add(1, 1); for(int i = 2; i &lt;= n; i++)&#123; cin &gt;&gt; a[i]; add(i, 1); //开始的时候全部初始化为1 &#125; for(int i = n; i &gt;= 1; i--)&#123; int l = 1, r = n; while(l &lt; r)&#123; //二分找出答案的位置 int mid = l + r &gt;&gt; 1; if(ask(mid) &lt; a[i] + 1)l = mid + 1; else r = mid; &#125; ans[i] = r; //记录答案 add(r, -1); //该数已经被用掉 &#125; for(int i = 1; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; endl; return 0;&#125;","path":"2019/09/08/数据结构进阶/树状数组/谜一样的牛-树状数组/","date":"09-08","excerpt":"","tags":[{"name":"数据结构进阶","slug":"数据结构进阶","permalink":"http://zhumenger.top/tags/数据结构进阶/"},{"name":"树状数组","slug":"树状数组","permalink":"http://zhumenger.top/tags/树状数组/"}]},{"title":" 一个简单的整数问题2 (树状数组)","text":"题目描述给定一个长度为N的数列A，以及M条指令，每条指令可能是以下两种之一： 1、“C l r d”，表示把 A[l],A[l+1],…,A[r] 都加上 d。 2、“Q l r”，表示询问 数列中第 l~r 个数的和。 对于每个询问，输出一个整数表示答案。 输入格式第一行两个整数N,M。 第二行N个整数A[i]。 接下来M行表示M条指令，每条指令的格式如题目描述所示。 输出格式对于每个询问，输出一个整数表示答案。 每个答案占一行。 数据范围 1≤N,M≤10^5|d|≤10000|A[i]|≤1000000000 输入样例： 10 51 2 3 4 5 6 7 8 9 10Q 4 4Q 1 10Q 2 4C 3 6 3Q 2 4 输出样例： 4 559 15 题解：树状数组区间修改加区间查询1.设原数组第i位的值为ai，di=ai−a(i−1)，则有(这里认为a0 = 0)：ax = ∑(i=1 ~ x)di 2.所以有：∑(i = 1 ~ x)ai = ∑(i = 1 ~ x)∑(j = 1 ~ i)dj = ∑ (i = 1 ~ x)(x − i + 1) * di 3.于是我们得到了: ∑(i = 1 ~ x)ai = (x + 1)∑(i = 1 ~ x)di − ∑(i = 1 ~ x)*di * i 4.于是我们把原数组差分后维护两个树状数组，一个维护di，一个维护di×i。这样区间求和时可以在两个树状数组中查询得到前缀和，区间修改时就是差分数组的修改，每次修改两个点即可。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;typedef long long ll;const int N = 1e5 + 10;int a[N];ll sum[N], c1[N], c2[N];int n, m;int lowbit(int x)&#123; return x &amp; -x;&#125;void add(int x, int y)&#123; for(int i = x; i &lt;= n; i += lowbit(i))&#123; c1[i] += y; c2[i] += (ll)x * y; &#125;&#125;ll ask(int x)&#123; ll ans = 0; for(int i = x; i; i -=lowbit(i)) ans += (ll)(x + 1) * c1[i] - c2[i]; return ans;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; a[i]; add(i, a[i] - a[i - 1]); &#125; while(m--)&#123; char c; int l, r, x; cin &gt;&gt; c; if(c == 'C')&#123; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; add(l, x); add(r + 1, -x); &#125; else&#123; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; ask(r) - ask(l - 1) &lt;&lt; endl; &#125; &#125; return 0;&#125;","path":"2019/09/07/数据结构进阶/树状数组/一个简单的整数问题2-树状数组/","date":"09-07","excerpt":"","tags":[{"name":"数据结构进阶","slug":"数据结构进阶","permalink":"http://zhumenger.top/tags/数据结构进阶/"},{"name":"树状数组","slug":"树状数组","permalink":"http://zhumenger.top/tags/树状数组/"}]},{"title":"一个简单的整数问题(树状数组)","text":"题目描述给定长度为N的数列A，然后输入M行操作指令。 第一类指令形如“C l r d”，表示把数列中第l~r个数都加d。 第二类指令形如“Q X”，表示询问数列中第x个数的值。 对于每个询问，输出一个整数表示答案。 输入格式第一行包含两个整数N和M。 第二行包含N个整数A[i]。 接下来M行表示M条指令，每条指令的格式如题目描述所示。 输出格式对于每个询问，输出一个整数表示答案。 每个答案占一行。 数据范围 1≤N,M≤10^5|d|≤10000|A[i]|≤1000000000 输入样例： 10 51 2 3 4 5 6 7 8 9 10Q 4Q 1Q 2C 1 6 3Q 2 输出样例： 4 12 5 题解：1.这道题的操作有”区间增加”和“单点查询”两种操作, 而树状数组仅支持“单点增加”, 需要作出一些转化来解决这个问题 2.我们想到可以用前缀和的形式来记录区间的变化情况, 新建一个数组 c,对于指令”C l r x”, 让c[l] += x, c[r + 1] -= x; 并用树状数组来维护数组c的前缀和,想要求若干指令后第x的值,直接调用ask()函数求出c[1 ~ x]区间值的变化情况再加上a[i]变得到了答案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int n, m;int a[N], c[N], sum[N];int lowbit(int x)&#123; return x &amp; -x;&#125;int ask(int x) &#123; int ans = 0; while(x)&#123; ans += c[x]; x -= lowbit(x); &#125; return ans;&#125;void add(int x, int y) &#123; while(x &lt;= n)&#123; c[x] += y; x += lowbit(x); &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; a[i]; &#125; while(m--)&#123; char s; int l, r, x; cin &gt;&gt; s; if(s == 'C')&#123; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; add(l, x); add(r + 1, -x); &#125; else&#123; cin &gt;&gt; x; cout &lt;&lt; a[x] + ask(x) &lt;&lt; endl; &#125; &#125; return 0;&#125;","path":"2019/09/07/数据结构进阶/树状数组/一个简单的整数问题-树状数组/","date":"09-07","excerpt":"","tags":[{"name":"数据结构进阶","slug":"数据结构进阶","permalink":"http://zhumenger.top/tags/数据结构进阶/"},{"name":"树状数组","slug":"树状数组","permalink":"http://zhumenger.top/tags/树状数组/"}]},{"title":"树状数组简介","text":"对于任意一个正整数x，都可以被二进制分解成: x = 2 ^ i1 + 2 ^ i2 + … + 2^im 不妨设 i1 &gt; i2 &gt; …im，进一步地，区间 [1, x] 可以分成O(logx)个小区间： 1.长度为2 ^ i1 的小区间 [1, 2 ^ i1] 2.长度为2 ^ i2 的小区间 [2 ^ i1 + 1, 2 ^ i1 + 2 ^ i2]; 3.长度为2 ^ i3 的小区间 [2 ^ i1 + 2 ^ i2 + 1, 2 ^ i1 + 2 ^ i2 + 2 ^ i3] …… m.长度为2 ^ im 的小区间 [2 ^ i1 + 2 ^ i2 + … + 2 ^ (im - 1) + 1, 2 ^ i1 + 2 ^ i2 + … + 2 ^ im] ​ 这些小区间的共同特点是：若区间结尾为 R ，则区间长度就等于 R 的二进制分解下最小的 2 的次幂，即lowbit(R). 例如 x = 7 = 2 ^ 2 + 2 ^ 1 + 2 ^ 0, 区间[1, 7]可以分成 [1, 4], [5, 6] 和 [7, 7] 三个区间，长度为别为lowbit(4) = 4, lowbit(6) = 2 和 lowbit(7) = 1 利用 lowbit 运算找出整数在二进制下所有等于 1 的位, 给你一个整数 x ，下面这段代码可以计算出区间[1, x] 分成的 O(logx) 个小区间： 123456while(x &gt; 0)&#123; //lowbit(x) = x &amp; -x, 返回x的最后一位1及后面的0 printf(\"[%d, %d]\\n\", x - (x &amp; -x) + 1, x); x -= x &amp; -x;// x -= lowbit(x)&#125; 树状数组就是一种基于上述思想的数据结构, 其用途是维护序列的前缀和。对于给定的序列 a，我们建立一个数组c，其中 c[x] 保存序列 a 的区间 [x - lowbit(x) + 1] 中所有数的和, ** 即 **∑(i = x - lowbit(x) + 1 ~ x)a[i] 数组c的树形结构如下图所示, 图中最下边一行是 N 个叶子节点（N = 16）， 代表数组a[1 ~ N]. 该结构满足一下性质： ​ 1.每个内部节点 c[x] 保存以它为根的子树中所有叶节点的和 ​ 2.每个内部节点 c[x] 的子节点个数等于 lowbit(x) 的位数 ​ 3.除树根外，每个内部节点 c[x] 的父节点等于lowbit(x) 的位数 ​ 4.树的深度为O（logN） 树状数组支持的基本操作有俩个，第一个操作是查询前缀和,根据上面所述，对于每一个整数 x ，我们都可以把[1, x] 分成 O(logN) 个小区间，而每个小区间的区间和都已经存在了数组 c 中。所以我们可以在O（logN）的时间内查询任意区间的前缀和。 123456789int ask(int x)&#123; int ans = 0; while(x &lt;= n)&#123; ans += c[x]; x -= x &amp; -1;// x -= lowbit(x) 加上各个小区间的区间和 &#125; return ans;&#125; 树状数组支持的第二个基本操作就是单点增加 ，即在一个数 a[x] 上加上 y，同时正确维护序列的前缀和。根据上图所示，只有节点 c[x] 以及所有祖先节点保存的区间和包含 a[x], 于是我们可以在O(logN)的时间内执行单点增加的操作： 1234567void add(int x, int y)&#123; while(x &lt;= n)&#123; c[x] += y; x -= x &amp; -x; //更新节点c[x]及所有祖先节点 &#125;&#125; 树状数组求逆序对给定任意一个集合 a，创建一个数组 t, t[val] 保存数值 val 在集合 a 中出现的次数, 那么数组 t 在 [l, r] 上的区间和(即∑(l &lt;= i &lt;= r)t[i])就表示集合 a 中范围在[l, r]内的数总共有多少个; 对于一个序列 a，若i &lt; j 且 a[i] &gt; a[j], 则称 a[i] 与 a[j] 构成逆序对。按照上述思路，利用树状数组求出一个序列的逆序对个数： ​ 1.我们可以在集合 a 的数值范围上建立一个树状数组，来维护 t 的前缀和, 初始化为0 ​ 2.倒序扫描给定的序列a,对于每个数 a[i]: ​ (1).在树状数组中查询前缀和 [1, a[i] - 1], 并用r[i]记录()​ (2).执行增加操作,即把位置a[i] 上的数 + 1(即t[a[i]]++), 同时正确维护 t 的前缀和, 表示数值a[i]又出现了一次 在这个算法中，因为倒序扫描，“已经出现过的数” 就是在 a[i] 后面的数，所以我们可以通过树状数组来统计范围在 [1 ~ a[i] - 1]中已经出现过的数, 从而得到每个a[i]后边有多少个比它小,将答案累加起来便是最终的答案 【例题】 楼兰图腾相传很久以前这片土地上(比楼兰古城还早)生活着两个部落，一个部落崇拜尖刀(‘V’)，一个部落崇拜铁锹(‘∧’)，他们分别用V和∧的形状来代表各自部落的图腾。 西部314在楼兰古城的下面发现了一幅巨大的壁画，壁画上被标记出了N个点，经测量发现这N个点的水平位置和竖直位置是两两不同的。 西部314认为这幅壁画所包含的信息与这N个点的相对位置有关，因此不妨设坐标分别为(1,y1), (2,y2),…, (n,yn),其中y1 ~ yn是1到n的一个排列。 西部314打算研究这幅壁画中包含着多少个图腾。 如果三个点(i, yi), (j, yj), (k, yk)满足1 ≤ i &lt; j &lt; k ≤ n 且 yi &gt; yj, yj &lt; yk，则称这三个点构成V图腾; 如果三个点(i, yi), (j, yj), (k, yk)满足1 ≤ i &lt; j &lt; k ≤ n 且 yi &lt; yj ,yj &gt; yk，则称这三个点构成∧图腾; 西部314想知道，这n个点中两个部落图腾的数目。 因此，你需要编写一个程序来求出V的个数和∧的个数。 输入格式第一行一个数n。 第二行是n个数，分别代表y1，y2,…,yn。 输出格式两个数，中间用空格隔开，依次为V的个数和∧的个数。 数据范围对于所有数据，n≤20000,且输出答案不会超过int64。 输入样例： 5 1 5 3 2 4 输出样例： 3 4 题解：1.对于序列中的每个数a[i]，我们可以分别求出a[i]的右侧和左侧比a[i]的大的数各有多少个,用r[i]和l[i]记录 2.然后我们枚举每个点作为中心点,以该点为中心的“V”或“^” 显然有r[i] * l[i]个,所以最终的答案就是∑(1 &lt;= l &lt;= r)r[i] * l[i]的总和 3.这道题的数据范围很大,所以我们可以用树状数组来做,创建一个数组 t,t[val] 保存数值 val 在集合中出现的次数, 那么数组 t 在[l, r]上的区间和(即∑(l &lt;= i &lt;= r)t[i])就表示集合 a 中范围在[l, r]内的数有多少个; 4.倒序扫描给定的序列a，利用树状求出每一 a[i] 后边有几个数比它大，记为r[i] 5.正序扫描序列 a，利用树状求出每一 a[i] 前边有几个数比它大，记为l[i] 6.按照同样的方法，我们可以统计出“^”字图腾的个数 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const int N = 2e5 + 10;ll c[N], r[N], l[N];int a[N];int n;int lowbit(int x)&#123; return x &amp; -x;&#125;int ask(int x) //这里表示范围1 ~ x 在序列中出现的次数&#123; int ans = 0; while(x)&#123; ans += c[x]; x -= lowbit(x); &#125; return ans;&#125;void add(int x, int y)&#123; while(x &lt;= n)&#123; c[x]++; x += lowbit(x); &#125;&#125;int main()&#123; ll sum1 = 0, sum2 = 0; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for(int i = n; i &gt;= 1; i--)&#123; r[i] = ask(n) - ask(a[i]); //统计a[i]的右侧比a[i]大的数有多少个 add(a[i], 1); &#125; memset(c, 0, sizeof c); for(int i = 1; i &lt;= n; i++)&#123; l[i] = ask(n) - ask(a[i]);//统计a[i]的左侧比a[i]大的数有多少个 add(a[i], 1); &#125; for(int i = 1; i &lt;= n; i++)&#123; //得到“V”字形的答案 sum1 += l[i] * r[i]; &#125; memset(l, 0, sizeof l); memset(r, 0, sizeof r); memset(c, 0, sizeof c); for(int i = n; i &gt;= 1; i--)&#123; //统计a[i]的右侧比a[i]小的数有多少个 r[i] = ask(a[i] - 1); add(a[i], 1); &#125; memset(c, 0, sizeof c); for(int i = 1; i &lt;= n; i++)&#123; //统计a[i]的左侧比a[i]大的数有多少个 l[i] = ask(a[i] - 1); add(a[i], 1); &#125; for(int i = 1; i &lt;= n; i++) //得到“^”字形的答案 sum2 += l[i] * r[i]; cout &lt;&lt; sum1 &lt;&lt; ' ' &lt;&lt; sum2 &lt;&lt; endl; return 0;&#125;","path":"2019/09/07/数据结构进阶/树状数组/树状数组简介/","date":"09-07","excerpt":"","tags":[{"name":"数据结构进阶","slug":"数据结构进阶","permalink":"http://zhumenger.top/tags/数据结构进阶/"},{"name":"树状数组","slug":"树状数组","permalink":"http://zhumenger.top/tags/树状数组/"}]},{"title":"奇偶游戏(并查集)","text":"题目描述小A和小B在玩一个游戏。 首先，小A写了一个由0和1组成的序列S，长度为N。 然后，小B向小A提出了M个问题。 在每个问题中，小B指定两个数 l 和 r，小A回答 S[l~r] 中有奇数个1还是偶数个1。 机智的小B发现小A有可能在撒谎。 例如，小A曾经回答过 S[13] 中有奇数个1， S[46] 中有偶数个1，现在又回答 S[1~6] 中有偶数个1，显然这是自相矛盾的。 请你帮助小B检查这M个答案，并指出在至少多少个回答之后可以确定小A一定在撒谎。 即求出一个最小的k，使得01序列S满足第1k个回答，但不满足第1k+1个回答。 输入格式 第一行包含一个整数N，表示01序列长度。 第二行包含一个整数M，表示问题数量。 接下来M行，每行包含一组问答：两个整数l和r，以及回答“even”或“odd”，用以描述S[l~r] 中有奇数个1还是偶数个1。 输出格式 输出一个整数k，表示01序列满足第1k个回答，但不满足第1k+1个回答，如果01序列满足所有回答，则输出问题总数量。 数据范围 N≤10^9,M≤1000 输入样例： 105 1 2 even3 4 odd5 6 even1 6 even7 10 odd 输出样例： 3 题解：1.如果我们用 sum 数组表示序列 S 的前缀和, 那么在每个回答中: 1.S[l ~ r] 有偶数个1, 等价于 sum[l - 1] 与 sum[r] 奇偶性相同(奇 或 偶 + 偶 = 奇 或 偶） 2.S[l ~ r] 有奇数个1, 等价于 sum[l - 1] 与 sum[r] 奇偶性不同(奇 或 偶 + 奇 = 偶 或 奇) 3.所以我们就可以将这道题给出的俩个数 l 和 r , 转化为 l - 1 和 r 的奇偶性的关系 2.这道题的序列长度 N 非常大, 而 M 非常小, 需要进行离散化 3.根据关系的传递性，我们可以用”边带权”的并查集来做边权d[x] = 0,表示x 与 f[x]的奇偶性相同; 为 1，表示 x 与 f[x] 的奇偶性不同,在路径压缩的过程中,对x到树根路径的所有边权做异或(xor)运算，即可得到 x 与树根的奇偶性关系 4.对于每个问题, 设离散化后 l - 1 和 r 的值分别是 x 和 y , 设ans表示问题的回答(0表示偶数个, 1表示奇数个) 若 x 和 y 在一个集合中, 直接判断d[x] ^ d[y] 是否等于ans, 若不等于,则矛盾，直接输出结果 若 x 和 y 不在一个集合中,合并俩个集合，得到俩个的树根p 和 q, d[x]与d[y]分别表示 x ~ p 与 y ~ q 之间所有边权的 “xor” 和,p ~ q之间的边权为d[p], 显然, 路径x ~ y 由 x ~ p, p ~ q, q ~ y 组成，所以x 与 y 的奇偶性关系ans = d[x] ^ d[y] ^ d[p],得到 d[p] = d[x] ^ d[y] ^ ans 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;using namespace std;const int N = 10010;int f[N* 2], d[N* 2];int n, m, t = 1;struct p&#123; int x, y, q;&#125;;p arr[N];int mp[2 * N];int Find(int x)&#123; if(x == f[x])return x; int root = Find(f[x]); d[x] ^= d[f[x]]; return f[x] = root;&#125;void read_in()//读入&#123; cin &gt;&gt; n &gt;&gt; m; int a, b; string c; for(int i = 1; i &lt;= m; i++)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; mp[++t] = a - 1; mp[++t] = b; arr[i].x = a, arr[i].y = b; if(c[0] == 'e')arr[i].q = 0; else arr[i].q = 1; &#125; sort(mp + 1, mp + t + 1); //排序 n = unique(mp + 1, mp + 1 + t) - mp - 1; //去重, 离散化 &#125;int main()&#123; read_in(); for(int i = 1; i &lt;= n; i++) f[i] = i; bool flag = false; for(int i = 1; i &lt;= m; i++)&#123; //求出l - 1 和 r 离散化后的值 int x = lower_bound(mp + 1, mp + 1 + n, arr[i].x - 1) - mp; int y = lower_bound(mp + 1, mp + 1 + n, arr[i].y) - mp; int p = Find(x); int q = Find(y); if(p == q)&#123; //如果 p 和 q 在一个集合中 if(d[x] ^ d[y] != arr[i].q)&#123; //矛盾，直接输出 cout &lt;&lt; i - 1 &lt;&lt; endl; flag = true; break; &#125; &#125; else&#123; f[p] = q; d[p] = d[x] ^ d[y] ^ arr[i].q; &#125; &#125; if(!flag)cout &lt;&lt; m &lt;&lt; endl; return 0;&#125;","path":"2019/09/05/数据结构进阶/并查集/奇偶游戏(并查集)/","date":"09-05","excerpt":"","tags":[{"name":"数据结构进阶","slug":"数据结构进阶","permalink":"http://zhumenger.top/tags/数据结构进阶/"},{"name":"并查集","slug":"并查集","permalink":"http://zhumenger.top/tags/并查集/"}]},{"title":"银河英雄传说(并查集)","text":"题目描述有一个划分为N列的星际战场，各列依次编号为1,2,…,N。 有N艘战舰，也依次编号为1,2,…,N,其中第i号战舰处于第i列。 有T条指令，每条指令格式为以下两种之一： 1、M i j，表示让第i号战舰所在列的全部战舰保持原有顺序，接在第j号战舰所在列的尾部。 2、C i j，表示询问第i号战舰与第j号战舰当前是否处于同一列中，如果在同一列中，它们之间间隔了多少艘战舰。 现在需要你编写一个程序，处理一系列的指令。 输入格式 第一行包含整数T，表示共有T条指令。 接下来T行，每行一个指令，指令有两种形式：M i j或C i j。 其中M和C为大写字母表示指令类型，i和j为整数，表示指令涉及的战舰编号。 输出格式 你的程序应当依次对输入的每一条指令进行分析和处理： 如果是M i j形式，则表示舰队排列发生了变化，你的程序要注意到这一点，但是不要输出任何信息； 如果是C i j形式，你的程序要输出一行，仅包含一个整数，表示在同一列上，第i号战舰与第j号战舰之间布置的战舰数目，如果第i号战舰与第j号战舰当前不在同一列上，则输出-1。 数据范围 N≤30000,T≤50000 输入样例： 4 M 2 3C 1 2M 2 4C 4 2 输出样例： -11 题解：1.开始时,每一个战舰都可以看做是一个集合, 用并查集来维护2.建立一个数组d[x], 用来记录x到根节点的权值, 在状态压缩过程中,更新所有的d[x]即可3.此外我们还需要一个 num 数组用来在每个树根记录上集合的大小, 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;const int N = 30010;int f[N], num[N], d[N];int Find(int x)&#123; if(x == f[x])return x; int root = Find(f[x]); //root记录x的父节点 d[x] += d[f[x]]; //更新权值 return f[x] = root; //返回根节点&#125;void join(int x, int y)&#123; x = Find(x); y = Find(y); if(x != y)&#123; f[x] = y; d[x] = num[y]; //更新x与y之间的权值 num[y] += num[x]; //更新根节点y的集合大小 &#125;&#125;int main()&#123; int t; cin &gt;&gt; t; for(int i = 1; i &lt;= 30000; i++)&#123; f[i] = i; num[i] = 1; &#125; while(t--)&#123; char c; int a, b; cin &gt;&gt; c; scanf(\"%d%d\", &amp;a, &amp;b); if(c == 'M')&#123; join(a, b); &#125; else&#123; if(Find(a) != Find(b))puts(\"-1\"); else cout &lt;&lt; max(0, abs(d[a] - d[b]) - 1) &lt;&lt; endl; &#125; &#125; return 0;&#125;","path":"2019/09/05/数据结构进阶/并查集/银河英雄传说(并查集)/","date":"09-05","excerpt":"","tags":[{"name":"数据结构进阶","slug":"数据结构进阶","permalink":"http://zhumenger.top/tags/数据结构进阶/"},{"name":"并查集","slug":"并查集","permalink":"http://zhumenger.top/tags/并查集/"}]},{"title":"程序自动分析(并查集)","text":"题目描述在实现程序自动分析的过程中,常常需要判定一些约束条件是否能被同时满足。 考虑一个约束满足问题的简化版本：假设x1,x2,x3,…x1,x2,x3,…代表程序中出现的变量，给定n个形如xi=xjxi=xj或xi≠xjxi≠xj的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。 例如，一个问题中的约束条件为：x1=x2，x2=x3，x3=x4，x1≠x4x1=x2，x2=x3，x3=x4，x1≠x4，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。 现在给出一些约束满足问题，请分别对它们进行判定。 输入格式 输入文件的第1行包含1个正整数t，表示需要判定的问题个数，注意这些问题之间是相互独立的。 对于每个问题，包含若干行： 第1行包含1个正整数n，表示该问题中需要被满足的约束条件个数。 接下来n行，每行包括3个整数i,j,e，描述1个相等/不等的约束条件，相邻整数之间用单个空格隔开。若e=1，则该约束条件为xi=xjxi=xj；若e=0，则该约束条件为xi≠xjxi≠xj。 输出格式 输出文件包括t行。 输出文件的第k行输出一个字符串“YES”或者“NO”（不包含引号，字母全部大写），“YES”表示输入中的第k个问题判定为可以被满足，“NO”表示不可被满足。 数据范围 1≤n≤10000001≤i,j≤1000000000 输入样例： 2 21 2 11 2 02 1 2 12 1 1 输出样例： NOYES 题解：1.将每一个变量看成一颗树,如果俩个变量相等,则将俩个集合合并,最后将所有的不等类型的约数条件判断一下即可2.这里的数据范围很大,可以用离散化的方法将变量 x 映射到1 ~ 2*n之内, 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;unordered_map&gt;using namespace std;const int N = 1e6 +10;int f[2 * N];struct p&#123; int x, y;&#125;;unordered_map&lt;int, int&gt; mp;p arr[N];int Find(int x)&#123; if(x != f[x])f[x] = Find(f[x]); return f[x];&#125;void join(int x, int y)&#123; f[Find(x)] = Find(y);&#125;int main()&#123; int n, t, a, b, c; cin &gt;&gt; t; while(t--)&#123; mp.clear(); int n; int cnt = 0; int res = 1; cin &gt;&gt; n; for(int i = 1; i &lt;= 2 * n; i++)f[i] = i; while(n--)&#123; cin &gt;&gt; a &gt;&gt; b&gt;&gt; c; if(!mp.count(a))mp[a] = res++; if(!mp.count(b))mp[b] = res++; if(c == 1)join(mp[a], mp[b]); else arr[cnt++] = &#123;mp[a], mp[b]&#125;; &#125; bool flag = false; for(int i = 0; i &lt; cnt; i++)&#123; if(Find(arr[i].x) == Find(arr[i].y))&#123; flag = true; break; &#125; &#125; if(flag)puts(\"NO\"); else puts(\"YES\"); &#125; return 0;&#125;","path":"2019/09/05/数据结构进阶/并查集/程序自动分析(并查集)/","date":"09-05","excerpt":"","tags":[{"name":"数据结构进阶","slug":"数据结构进阶","permalink":"http://zhumenger.top/tags/数据结构进阶/"},{"name":"并查集","slug":"并查集","permalink":"http://zhumenger.top/tags/并查集/"}]},{"title":"并查集","text":"概念 并查集是一种可以动态维护若干个不重叠的结合,并且支持合并与查询的数据结构.也就是擅长维护各种各样的具有传递性质的关系 基本操作 1.find()操作 查询一个元素所属哪一个集合2.join()合并操作,把两个集合合并成为一个集合 具体实现 1.使用树形结构存储每个集合,刚开始的时候每个点就是一个独立的集合,即有n颗一个点的树 1234//预处理for(int i=1;i&lt;=n;i++) father[i]=i;//father数组为这个点的父亲,刚开始也就是树根祖宗 2.并查集的 Find() 操作 若x是树根，直接返回，否则递归访问f(x)直至根节点。 12345int Find(int x)&#123; if(x != f[x])f[x] = Find(f[x]); return f[x];&#125; 3.并查集的 join() 操作 合并元素 x 和元素 y 所在的集合，等于让 x 的树根作为 y 的树根的子节点 1234void join(int x, int y)&#123; f(Find(x)) = Find(y);&#125; 例题：合并集合题目描述一共有n个数，编号是1~n，最开始每个数各自在一个集合中。 现在要进行m个操作，操作共有两种： “M a b”，将编号为a和b的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作； “Q a b”，询问编号为a和b的两个数是否在同一个集合中； 输入格式 第一行输入整数n和m。 接下来m行，每行包含一个操作指令，指令为“M a b”或“Q a b”中的一种。 输出格式 对于每个询问指令”Q a b”，都要输出一个结果，如果a和b在同一集合内，则输出“Yes”，否则输出“No”。 每个结果占一行。 数据范围 1≤n,m≤10^5 输入样例： 4 5M 1 2M 3 4Q 1 2Q 1 3Q 3 4 输出样例： YesNoYes 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int f[N];int Find(int x)&#123; if(x != f[x])f[x] = Find(f[x]); return f[x];&#125;void join(int x, int y)&#123; x = Find(x); y = Find(y); if(x != y) f[x] = y;&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)f[i] = i; while(m--)&#123; char s; int a, b; cin &gt;&gt; s &gt;&gt; a &gt;&gt; b; if(s == 'M')join(a, b); else &#123; if(Find(a) != Find(b))cout &lt;&lt; \"No\" &lt;&lt; endl; else cout &lt;&lt; \"Yes\" &lt;&lt; endl; &#125; &#125; return 0;&#125;","path":"2019/09/04/数据结构进阶/并查集/并查集/","date":"09-04","excerpt":"","tags":[{"name":"数据结构进阶","slug":"数据结构进阶","permalink":"http://zhumenger.top/tags/数据结构进阶/"},{"name":"并查集","slug":"并查集","permalink":"http://zhumenger.top/tags/并查集/"}]},{"title":"剪纸游戏","text":"题目描述给定一张N*M的矩形网格纸，两名玩家轮流行动。 在每一次行动中，可以任选一张矩形网格纸，沿着某一行或某一列的格线，把它剪成两部分。 首先剪出1*1的格纸的玩家获胜。 两名玩家都采取最优策略行动，求先手是否能获胜。 提示：开始时只有一张纸可以进行裁剪，随着游戏进行，纸张被裁剪成2,3,…更多张，可选择进行裁剪的纸张就会越来越多。 输入格式 输入包含多组测试数据，每组数据占一行。 每组数据包括两个整数N和M，表示初始网格纸的尺寸。 输出格式 每组测试数据输出一个结果，结果占一行。 如果先手方必胜，则输出”WIN”； 如果先手方必输，则输出”LOSE”。 数据范围 2≤N,M≤200 输入样例： 2 23 24 2 输出样例： LOSELOSEWIN 题解：1.在游戏过程中可能会有若干张大小不同的矩形网格图,每一个矩形网格图都是一个子游戏,所有子游戏构成了一个”游戏的和” 2.因为俩人都是选择的最优策略, 所以他们肯定不会最先剪出1 * x 或 x * 1的纸张，这样的话对手就可以直接剪出1 * 1 的纸张而获胜 3.所以要剪出1 * 1的纸张必定先经过2 * 2, 2 * 3, 3 * 2三种局面之一,4.所以我们可以枚举如何行动,把这张纸剪成俩部分,根据SG函数定理,二者执行xor运算，再对合法行动中产生的子局面构成的集合做mex运算，便得到父亲游戏的的SG值,只要整个游戏开始的SG值不为0,先手必胜，否则先手必败 代码如下： 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int sg[1010][1010];int dfs(int x, int y)&#123; if(sg[x][y] != -1) return sg[x][y]; int f[210]; memset(f, 0, sizeof f); //枚举所有的情况 for(int i = 2; i &lt;= x - i; i++)f[dfs(i, y) ^ dfs(x - i, y)] = 1; for(int i = 2; i &lt;= y - i; i++)f[dfs(x, i) ^ dfs(x, y - i)] = 1; int t = 0; while(f[t])t++;//mex运算 return sg[x][y] = t;&#125;int main()&#123; int n, m; memset(sg, -1, sizeof sg); sg[0][0] = 0; while( cin &gt;&gt; n &gt;&gt; m)&#123; if(dfs(n, m))puts(\"WIN\"); else puts(\"LOSE\"); &#125; return 0;&#125;","path":"2019/09/04/数论/剪纸游戏/","date":"09-04","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"SG函数","slug":"SG函数","permalink":"http://zhumenger.top/tags/SG函数/"}]},{"title":"绿豆蛙的归宿(数学期望)","text":"题目描述给出一个有向无环的连通图，起点为1，终点为N，每条边都有一个长度。 数据保证从起点出发能够到达图中所有的点，图中所有的点也都能够到达终点。 绿豆蛙从起点出发，走向终点。 到达每一个顶点时，如果有K条离开该点的道路，绿豆蛙可以选择任意一条道路离开该点，并且走向每条路的概率为 1/K 。 现在绿豆蛙想知道，从起点走到终点所经过的路径总长度的期望是多少？ 输入格式 第一行: 两个整数 N， M，代表图中有N个点、M条边。 第二行到第 1+M 行: 每行3个整数 a, b, c，代表从a到b有一条长度为c的有向边。 输出格式 输出从起点到终点路径总长度的期望值，结果四舍五入保留两位小数。 数据范围 1≤N≤105,1≤M≤2N 输入样例：123454 41 2 11 3 22 3 33 4 4 输出样例：17.00 题解：设f(x)表示从节点 x 到终点所经过的路径的期望长度。若从 x 出发有 k 条边，分别到达y1,y2,..yk, 边长为z1,z2…zk, 根据数学期望定义有f(x) = (f[yi] + zi) / k (1 &lt;= i &lt;= k), 显然f(N) = 0, 我们的目标是求出f(1),所以我们可以从终点出发, 在反向图上执行拓扑排序在拓扑排序的过程中顺便计算f(x)即可 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int h[N], e[2 * N], ne[2 * N], w[2 * N], idx;int out[2 * N], deg[2 * N];double dis[N];int n, m;void add(int a, int b, int c)&#123; e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof h); while(m--)&#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(b, a, c); out[a]++; deg[a]++; &#125; queue&lt;int&gt; q; q.push(n); while(q.size())&#123; int x = q.front(); q.pop(); for(int i = h[x]; i != -1; i = ne[i])&#123; int y = e[i]; dis[y] += (dis[x] + w[i]) * 1.0 / deg[y]; out[y]--; if(!out[y])q.push(y); &#125; &#125; printf(\"%.2f\\n\", dis[1]); return 0;&#125;","path":"2019/09/04/数论/绿豆蛙的归宿-数学期望/","date":"09-04","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"数学期望","slug":"数学期望","permalink":"http://zhumenger.top/tags/数学期望/"}]},{"title":"开关问题(高斯消元)","text":"题目描述有N个相同的开关，每个开关都与某些开关有着联系，每当你打开或者关闭某个开关的时候，其他的与此开关相关联的开关也会相应地发生变化，即这些相联系的开关的状态如果原来为开就变为关，如果为关就变为开。 你的目标是经过若干次开关操作后使得最后N个开关达到一个特定的状态。 对于任意一个开关，最多只能进行一次开关操作。 你的任务是，计算有多少种可以达到指定状态的方法。（不计开关操作的顺序） 输入格式输入第一行有一个数K，表示以下有K组测试数据。 每组测试数据的格式如下： 第一行 一个数N（0 &lt; N &lt; 29）。 第二行 N个0或者1的数，表示开始时N个开关状态。 第三行 N个0或者1的数，表示操作结束后N个开关的状态。 接下来 每行两个数I J，表示如果操作第 I 个开关，第J个开关的状态也会变化。 每组数据以 0 0 结束。 输出格式如果有可行方法，输出总数，否则输出“Oh,it’s impossible~!!” 。 输入样例： 2 30 0 01 1 11 21 32 12 33 13 20 03 0 0 01 0 11 22 10 0 输出样例： 4 Oh,it’s impossible~!! 题解：1.设xi表示第i个开关的操作情况,那么xi = 1为按了这个开关,否则xi = 0表示这个开关并没有按下去, 2.我们接着统计ai,j表示第i个开关和第j个开关的联系情况,ai,j = 1表示按下j会影响i的状态, 否则就是不会影响,即ai,j = 0,特殊地一个点就是,ai,i = 1,因为我们本身肯定会影响本身. 3.设一个开关起始状态为srci, 最后一个状态为dsti,那么我们可到一个线性方程组 最后我们解方程组ai,1x1 xor ai,2x2 xor…xor ai,nxn = srci xor dsti(1 &lt;= i &lt;= n) 4.为了高效简便, 可以把曾广矩阵的每一行进行状态压缩, 用一个int类型的整数表示n + 1位二进制数, 其中第0 位为曾广矩阵最后一列的常数,第1 ~ n位分别表示为曾广矩阵1 ~ n位的系数 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;using namespace std;int a[50];int main()&#123; int t, n; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for(int i = 1, j; i &lt;= n; i++)&#123; cin &gt;&gt; j; a[i] ^= j; a[i] |= 1 &lt;&lt; i; // ai,i = 1 &#125; int x, y, ans = 1; while(cin &gt;&gt; x &gt;&gt; y &amp;&amp; x &amp;&amp; y)&#123; a[y] |= 1 &lt;&lt; x; //ay,x = 1 &#125; for(int i = 1; i &lt;= n; i++)&#123; //找到一个最大的a[i]， 即主元位数最高的a[i] for(int j = i + 1; j &lt;= n; j++) if(a[j] &gt; a[i])swap(a[i], a[j]); //如果最大的a[i]为0，说明消元完毕 //此时有i - 1个主元, n - i + 1个自由元 if(a[i] == 0)&#123;ans = 1 &lt;&lt; (n - i + 1); break;&#125; if(a[i] == 1)&#123;ans = 0; break;&#125; //如果0 = 1，无解 for(int k = n; k; k--)&#123; //枚举系数 if(a[i] &gt;&gt; k &amp;&amp; 1)&#123; //a[i]最高位的1作为主元, 消去其他方程该位的系数 for(int j = 1; j &lt;= n; j++)&#123; if(i != j &amp;&amp; a[j] &gt;&gt; k &amp; 1)a[j] ^= a[i]; &#125; break; &#125; &#125; &#125; if(ans == 0)puts(\"Oh,it's impossible~!!\"); else cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/09/01/数论/开关问题-高斯消元/","date":"09-01","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"高斯消元","slug":"高斯消元","permalink":"http://zhumenger.top/tags/高斯消元/"}]},{"title":"矩阵快速幂(斐波那契)","text":"题目描述在斐波那契数列中，Fib0 = 0,Fib1 = 1,Fibn = Fibn−1 + Fibn−2 (n &gt; 1)。 给定整数n，求Fibn mod 10000。 输入格式 输入包含多组测试用例。 每个测试用例占一行，包含一个整数n。 当输入用例n=-1时，表示输入终止，且该用例无需处理。 输出格式 每个测试用例输出一个整数表示结果。 每个结果占一行。 数据范围 0≤n≤2∗10 ^ 9 输入样例： 0 99999999991000000000-1 输出样例： 0 346266875 题解：1.直接递归: 时间复杂度为O(n),超时 2.设f(n)表示一个1 * 2的矩阵,F(n) = {b(n), b(n + 1)},我们可以用f(n - 1) = {b(n - 1), b(n)}来得到F(n),也就是说, 要把F(n - 1)第二列上的数作为F(n)的第一列上的数,并把F(n - 1)第1、2列上的数累加到F(n)的第二列上,因此,根 据矩阵乘法原理我们可以让矩阵a = [[0, 1], [1, 1]],那么F(n) = F(n - 1) * a, 设初始值F(0) = {0, 1},目标F(n) = F(0) * A ^ n 3.用快速幂来计算F(0) * A^n, 把快速幂算法中的乘法改成矩阵的乘法就可以了,时间复杂度为O(2^3 * log(n) 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;int n;void mul(int f[2], int a[2][2])&#123; int c[2]; memset(c, 0, sizeof c); for(int i = 0; i &lt; 2; i++) for(int j = 0; j &lt; 2; j++) c[i] = (c[i] + (ll)f[j] * a[j][i]) % 10000; memcpy(f, c, sizeof c);&#125;void mulself(int a[2][2])&#123; int c[2][2]; memset(c, 0, sizeof c); for(int i = 0; i &lt; 2; i++) for(int j = 0; j &lt; 2; j++) for(int k = 0; k &lt; 2; k++) c[i][j] = (c[i][j] + (ll)a[i][k] * a[k][j]) % 10000; memcpy(a, c, sizeof c);&#125;int main()&#123; while(cin &gt;&gt; n &amp;&amp; n != -1)&#123; int f[2] = &#123;0, 1&#125;; int a[2][2] = &#123;&#123;0, 1&#125;, &#123;1, 1&#125;&#125;; while(n)&#123; if(n &amp; 1)mul(f, a); n &gt;&gt;= 1; mulself(a); &#125; cout &lt;&lt; f[0] &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/09/01/数论/矩阵快速幂-斐波那契/","date":"09-01","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"http://zhumenger.top/tags/矩阵快速幂/"}]},{"title":"球形空间产生器(高斯消元)","text":"题目描述有一个球形空间产生器能够在n维空间中产生一个坚硬的球体。 现在，你被困在了这个n维球体中，你只知道球面上n+1个点的坐标，你需要以最快的速度确定这个n维球体的球心坐标，以便于摧毁这个球形空间产生器。 输入格式 第一行是一个整数n。 接下来的n+1行，每行有n个实数，表示球面上一点的n维坐标。 每一个实数精确到小数点后6位，且其绝对值都不超过20000。 输出格式 有且只有一行，依次给出球心的n维坐标（n个实数），两个实数之间用一个空格隔开。 每个实数精确到小数点后3位。 数据保证有解。 数据范围 1≤n≤10 输入样例： 2 0.0 0.0-1.0 1.01.0 0.0 输出样例： 0.500 1.500 题解：对于一个球体而言,所有点到球心的距离相等,所以只需要求出一个点(x1,x2,…,xn)使得满足 ∑(0 &lt;= j &lt;= n)(ai,j − xj)^2 = C 记住C是常数,i∈[1,n+1]那么这个方程组是由n+1个n元二次方程,然后我们同时消去C.得到： ∑(1 &lt;= j &lt;= n)((ai,j ^ 2) − (ai+1,j ^ 2) − 2xj(ai,j − ai+1,j)) = 0 (i = 1,2,3,…,n) 我们再把变量放左边,常数放右边. ∑(1 &lt;= j &lt;= n)2(ai,j − ai+1,j) * xj = ∑(1 &lt;= j &lt;= n)(ai,j ^ 2 − ai+1,j ^ 2)(i = 1,2,3,…,n) 然后我们就可以开始愉快地高斯消元了. 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;double a[20][20], b[20], c[20][20];int main()&#123; int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n + 1; i++) for(int j = 1; j &lt;= n; j++) scanf(\"%lf\", &amp;a[i][j]); //c: 系数矩阵, b: 常数, 二者一起构成增广矩阵 for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; c[i][j] = 2 * (a[i][j] - a[i + 1][j]);//得到系数矩阵 b[i] += a[i][j] * a[i][j] - a[i + 1][j] * a[i + 1][j]; //得到常数 &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; // 枚举每一个系数x[i] //找到x[i]的系数不为0的一个方程 for(int j = i; j &lt;= n; j++)&#123; //枚举第i列的每一行 if(fabs(c[j][i]) &gt; 1e-8)&#123; //将第j行与第i行交换 for(int k = i; k &lt;= n; k++)swap(c[i][k], c[j][k]); swap(b[i], b[j]); &#125; &#125; for(int j = 1; j &lt;= n; j++)&#123; //枚举行 if(i == j)continue; double rate = c[j][i] / c[i][i]; //将j行的首元素消除,第j行每一列都需要第i行的系数rate倍 for(int k = i; k &lt;= n; k++)c[j][k] -= c[i][k] * rate; b[j] -= b[i] * rate; &#125; &#125; for(int i = 1; i &lt; n; i++)printf(\"%.3f \", b[i] / c[i][i]); //输出答案 printf(\"%.3f\\n\", b[n] / c[n][n]); return 0;&#125;","path":"2019/09/01/数论/球形空间产生器-高斯消元/","date":"09-01","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"高斯消元","slug":"高斯消元","permalink":"http://zhumenger.top/tags/高斯消元/"}]},{"title":"约数之和","text":"题目描述假设现在有两个自然数A和B，S是ABAB的所有约数之和。 请你求出S mod 9901的值是多少。 输入格式 在一行中输入用空格隔开的两个整数A和B。 输出格式 输出一个整数，代表S mod 9901的值。 数据范围 0≤A,B≤5×10 ^ 7 输入样例： 2 3 输出样例： 15 注意: A和B不会同时为0 题解：1.约数之和公式:φ(N) = (1 + p1 + p1^2 + …+ p1^a1)(1 + p2 + p2^2 + … + p2^a2)…(1 + pn + pn^2 + … + pn^an). 2. 这道题求：φ(N) ^ b = (1 + p1 + p1^2 + …+ p1^(b * a1))(1 + p2 + p2^2 + … + p2^(b * a2))…(1 + pn + pn^2 + … + pn^(b * an)). 3.可以用等比数列求和公式来计算: (1 + p + p^2 + …+ p^(b * a1)) = (p^(b * a1 + 1) - 1) / (p - 1)使用快速幂来计算分子(p^(b*a1 + 1) - 1) % mod的值,和分母(p - 1) % mod的值 4.因为9931是质数,所以只要(p - 1)和mod互质,即不是mod的倍数便可以用乘法逆元来做,如果是mod的倍数,乘法逆元不存在,但p % mod = 1;所以1 + p + p^2 + …+ p^(b * a1) % mod = 1 + 1^2 + …1^b * a1 % mod = b * a1 + 1 % mod 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;const int mod = 9901;typedef long long ll;int a, b, p[20], c[20], cnt;void divide(int x) //分解质因数&#123; for(int i = 2; i * i &lt;= x; i++)&#123; if(x % i == 0)&#123; p[++cnt] = i, c[cnt] = 0; while(x % i == 0)&#123; c[cnt]++; x /= i; &#125; &#125; &#125; if(x &gt; 1) p[++cnt] = x, c[cnt]++;&#125;int qsm(int a, ll b) //快速幂&#123; int ans = 1; while(b != 0)&#123; if(b &amp; 1)ans = (ll)ans * a % mod; b &gt;&gt;= 1; a = (ll)a * a % mod; &#125; return ans;&#125;int main()&#123; int ans = 1; cin &gt;&gt; a &gt;&gt; b; divide(a); for(int i = 1; i &lt;= cnt; i++)&#123; if((p[i] - 1) % mod == 0)ans = (ll)(b * c[i] + 1) % mod * ans % mod; //如果是mod的倍数, 特判 else &#123; int x = qsm(p[i], (ll)b * c[i] + 1); x = (x - 1 + mod) % mod; //分母 % mod int y = (p[i] - 1) % mod; //分子 % mod y = qsm(y, mod - 2); //得到分子的乘法逆元 ans = (ll)ans * x % mod * y % mod; //累计答案 &#125; &#125; if(a)cout &lt;&lt; ans &lt;&lt; endl; else cout &lt;&lt; 0 &lt;&lt; endl;&#125;","path":"2019/08/28/数论/约数之和/","date":"08-28","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"约数","slug":"约数","permalink":"http://zhumenger.top/tags/约数/"}]},{"title":"同余方程","text":"题目描述求关于x的同余方程 ax ≡ 1(mod b) 的最小正整数解。 输入格式 输入只有一行，包含两个正整数a,b,用一个空格隔开。 输出格式 输出只有一行,包含一个正整数x，表示最小正整数解。 输入数据保证一定有解。 数据范围 2≤a,b≤2∗10^9 输入样例： 3 10 输出样例： 7 题解：扩展欧几里得算法： 对于任意整数a,b，存在一对整数x,y, 满足ax + by = gcd(a, b) 这道题求ax % b == 1, 即ax - 1是b的倍数,假设为-y倍, 则ax + by = 1, 利用扩展欧几里得算法即可求出一组特解(x0, y0)(x, y), 有多种解, 题目要求最小正整数解,还需要转化为1~b之间 代码如下： 123456789101112131415161718#include&lt;iostream&gt;using namespace std;typedef long long ll;ll x, y, a, b;ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y)//扩展欧几里得算法&#123; if(b == 0) &#123;x = 1, y = 0; return a;&#125; ll d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;int main()&#123; cin &gt;&gt; a &gt;&gt; b; exgcd(a, b, x, y); cout &lt;&lt; (x % b + b) % b &lt;&lt; endl; return 0;&#125;","path":"2019/08/27/数论/同余方程/","date":"08-27","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"同余","slug":"同余","permalink":"http://zhumenger.top/tags/同余/"}]},{"title":"最幸运的数字","text":"题目描述8是中国的幸运数字，如果一个数字的每一位都由8构成则该数字被称作是幸运数字。 现在给定一个正整数L，请问至少多少个8连在一起组成的正整数（即最小幸运数字）是L的倍数。 输入格式 输入包含多组测试用例。 每组测试用例占一行，包含一个整数L。 当输入用例L=0时，表示输入终止，该用例无需处理。 输出格式 每组测试用例输出结果占一行。 结果为“Case 1: ”+一个整数N，N代表满足条件的最小幸运数字的位数。 如果满足条件的幸运数字不存在，则N=0。 数据范围 1≤L≤2∗10^9 输入样例： 8 11160 输出样例： Case 1: 1Case 2: 2Case 3: 0 题解：欧拉定理：若a，b互质，则a^f(b) % b == 1.其中f(b)为欧拉函数 引理1:对于任何一个111，22…22，333…33,形如这样的数，我们都是可以用一个公式表示的。即:k * (10^x - 1) / 9; 所以目前的可以将问题转化为: 找到最小的x,使得满足(8 * (10^x - 1) / 9) % l == 0，将公式化简: 9L | (8 * (10^x - 1))。我们令d = gcd(L,8),然后同时两边除上d，可得9L/d | (8/d * (10^x - 1))。 9L/d 与 8/d 这两个数一定是互质的。故，我们可以得到9L/d 因是 (10^x - 1)的因子。可得：9L/d | (10^x - 1).可得：10^x % （9L/d） == 1.至此 这个函数跟欧拉定理，就是一样的形式了。 引理2: 如正整数a, n互质,则满足a^x % n == 1的最小正整数x0是f(n)的约数 证明：若10 与 (9L/d) 不是互质的，则二者有相同的因子b为2或者5。若b为2 则：9L/d 为偶数，那么10 % （9L/d）一定不能等于1.同理可证b为5的情况。 继续根据欧拉函数推测：f(9L/d)可以为x的取值。但是现在要找的是最小的x。我们知道a^b % n是有循环节r的。r应是f(9L/d)的约数。 综上所述,我们推出了公式10^x % p == 1(p = 9 * l / (gcd(8, l))), 并且x满足为f(p)的约数至此，我们目的明确了。求出（9L/d）的欧拉函数值，枚举他的所有约数，找到满足10^x % （9L/d） == 1.的x的最小值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;typedef long long ll;ll l;ll gcd(ll a, ll b) &#123; return b ? gcd(b, a % b) : a;&#125;ll get_ouler(ll p) //获得p的欧拉函数&#123; ll ans = p; for(int i = 2; i * i &lt;= p; i++)&#123; if(p % i == 0) ans = ans / i * (i - 1); while(p % i == 0) p /= i; &#125; if(p &gt; 1) ans = ans / p * (p - 1); return ans;&#125; ll qsm(ll a, ll b, ll mod) //快速幂取模&#123; ll ans = 1; while(b != 0)&#123; if(b &amp; 1)ans = ans * a % mod; b &gt;&gt;= 1; a = a * a % mod; &#125; return ans;&#125;int main()&#123; int t = 1; while(cin &gt;&gt; l &amp;&amp; l != 0)&#123; ll p = 9 * l / gcd(l, 8); //得到模数p ll ouler = get_ouler(p); //得到p的欧拉函数 ll ans = 1e18; for(ll i = 1; i * i &lt;= ouler; i++)&#123; //枚举ouler所有的的约数,找到最小的满足条件的x if(ouler % i == 0)&#123; if(qsm(10, i, p) == 1) ans = min(ans, i); //由推论可知,x满足10 ^ x % p == 1 if(qsm(10, ouler / i, p) == 1) ans = min(ans, ouler / i); &#125; &#125; printf(\"Case %d: \", t++); //输出答案 if(ans == 1e18)cout &lt;&lt; 0 &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/08/27/数论/最幸运的数字/","date":"08-27","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"同余","slug":"同余","permalink":"http://zhumenger.top/tags/同余/"}]},{"title":"可见的点","text":"题目描述在一个平面直角坐标系的第一象限内，如果一个点(x,y)与原点（0,0）的连线中没有通过其他任何点，则称该点在原点处是可见的。 例如，点(4,2)就是不可见的，因为它与原点的连线会通过点(2,1)。 部分可见点与原点的连线如下图所示： 编写一个程序，计算给定整数N的情况下，满足0≤x，y≤N0≤x，y≤N的可见点（x，y）的数量（可见点不包括原点）。 输入格式 第一行包含整数C，表示共有C组测试数据。 每组测试数据占一行，包含一个整数N。 输出格式 每组测试数据的输出占据一行。 应包括：测试数据的编号（从1开始），该组测试数据对应的N以及可见点的数量。 同行数据之间用空格隔开。 数据范围 1≤N,C≤1000 输入样例： 4 24 5231 输出样例： 1 2 52 4 133 5 214 231 32549 题解：1.除了(1, 0),(0, 1),(1, 1) 一个钉子被看到当且仅当gcd(x, y) == 1, 我们只需考虑一半的情况即可,对于每个y(2 &lt;= y &lt;= N), 求出有多个数x与y互质,最后的答案ans = 3 + 2 * f(i)(2 &lt;= i &lt;= N)2.对于f(i),我们可以用欧拉函数来求解 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;const int N = 1010;int phi[N];int t, n;void solve()&#123; for(int i = 2; i &lt;= n; i++)phi[i] = i; for(int i = 2; i &lt;= n; i++)&#123; //枚举每一个数i if(phi[i] == i)&#123; // 如果i为素数 for(int j = i; j &lt;= n; j += i) phi[j] = phi[j] / i * (i - 1); &#125; &#125;&#125;int main()&#123; int p = 1; cin &gt;&gt; t; while(t--)&#123; int ans = 0; cin &gt;&gt; n; solve(); for(int i = 2; i &lt;= n; i++) ans += 2 * phi[i]; printf(\"%d %d %d\\n\", p++, n, ans +3); //输出答案 &#125; return 0;&#125;","path":"2019/08/27/数论/可见的点/","date":"08-27","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"约数","slug":"约数","permalink":"http://zhumenger.top/tags/约数/"}]},{"title":"余数之和","text":"题目描述给出正整数n和k，计算j(n, k)=k mod 1 + k mod 2 + k mod 3 + … + k mod n的值。 例如j(5, 3)=3 mod 1 + 3 mod 2 + 3 mod 3 + 3 mod 4 + 3 mod 5=0+1+0+3+3=7。 输入格式 输入仅一行，包含两个整数n, k。 输出格式 输出仅一行，即j(n, k)。 数据范围1≤n,k≤10 ^ 9 输入样例： 5 3 输出样例： 7 题解：1.k % i = k - (k / i) * i, 所以我们要求的答案就是:n * k - (k / i) * i(1 &lt;= i &lt;= n) 2.令g(x) = k / (k / x),(1 &lt;= x &lt;= k)由夹逼准则可求得k / g(x) = k / x,所以对于 i 属于[x, k / (k / x)],k / i 的值都相同，等于k / x所以算式(k / i) * i = (k / x) * i,在区间[x, k / (k / x)]就是一个公差为(k / x)的等差数列，直接用等差数列求和公式计算即可 代码如下： 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;typedef long long ll;int main()&#123; ll n, k; cin &gt;&gt; n &gt;&gt; k; ll l, r, a1, an, q; ll ans = n * k; for(int l = 1; l &lt;= n; l = r + 1)&#123; //不断找寻下一区间,枚举左端点 r = k / l ? min(k / (k / l), n) : n; //得到又端点, q = k / l;//公差 a1 = l * q;//第一项 an = r * q;//第二项 ans -= (a1 + an) * (r - l + 1) / 2; //ans减去这段的区间和 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","path":"2019/08/26/数论/余数之和/","date":"08-26","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"约数","slug":"约数","permalink":"http://zhumenger.top/tags/约数/"}]},{"title":"反素数","text":"题目描述对于任何正整数x，其约数的个数记作g(x)，例如g(1)=1、g(6)=4。 如果某个正整数x满足：对于任意的小于x的正整数 i，都有g(x)&gt;g(i) ，则称x为反素数。 例如，整数1，2，4，6等都是反素数。 现在给定一个数N，请求出不超过N的最大的反素数。 输入格式 一个正整数N。 输出格式 一个整数，表示不超过N的最大反素数。 数据范围 1≤N≤2∗109 输入样例： 1000 输出样例： 840 题解：引理1: 1~N中任何数的质因子都不会超过10个,且所有的质因子的指数总和不会超过30, 因为最小1的10个质数的乘积2 * 3 * 5 * 7 * 9 * 11 * 13 * 17 * 19 * 23 &gt; 2 * 10 ^ 9 即使只包括最小的质数,任然有2 ^ 31 &gt; 2 * 10 ^ 9, 所以N &lt;= 2 * 10 ^ 9 的质因子指数总和不可能超过30 引理2: x为反质数的必要条件是, x分解质因数后可以写作2^c1 * 3^c2 * 5^c3 * 7^c4 * 11^c5 * 13^c6 * 17^c7 * 19^c8 * 23^c9 * 29^c10并且c1 &gt;= c2 &gt;= c3 &gt;= ..c10 &gt;= 0, 即x的质因子是连续的若干个最小的质数,并且指数单调递减因为如果不满足连续若干个最小的话,我们就可以使用交换质因子的方法,得到一个x使得x的质因子连续,约数个数相同,且x更小指数如果不是递减的话,也是一样的道理,我们总能找到一个约数相同且比原先更小的x使得x的指数递减综上所述,我们可以使用深度优先搜索(DFS),尝试确定前10个质数的指数,并满足指数单调递减,总乘积不超过N,同时记录约数的个数 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;typedef long long ll;int sum ,minx;int a[] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29&#125;;int n;void dfs(int u, int cnt, int p, int ans) //u表示当前质数, cnt表示指数,p表示约数乘积,ans表示约数个数&#123; if(ans &gt; sum || ans == sum &amp;&amp; p &lt; minx)&#123; minx = p; sum = ans; &#125; for(int i = 1; i &lt;= cnt; i++)&#123; if((ll)p * a[u] &gt; n)break; p *= a[u]; //确定当前质数的指数 dfs(u + 1, i, p, ans * (i + 1)); //搜索下一个质数的指数,并保证指数递减,更新约数乘积和约数个数 &#125;&#125;int main()&#123; cin &gt;&gt; n; dfs(0, 30, 1, 1); cout &lt;&lt; minx &lt;&lt; endl; return 0;&#125;","path":"2019/08/26/数论/反素数/","date":"08-26","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"约数","slug":"约数","permalink":"http://zhumenger.top/tags/约数/"}]},{"title":"阶乘分解","text":"题目描述给定整数 N ，试把阶乘 N! 分解质因数，按照算术基本定理的形式输出分解结果中的 pipi 和 cici 即可。 输入格式 一个整数N。 输出格式 N! 分解质因数后的结果，共若干行，每行一对pi,cipi,ci，表示含有pciipici项。按照pipi从小到大的顺序输出。 数据范围 1≤N≤106 输入样例： 5 输出样例： 2 33 15 1 样例解释5!=120=23∗3∗5 题解：*1.若把1~N中的每个数分别分解质因数,再把结果合并，时间复杂度过高为O(NlogN) * 2.N!的质因子不会超过N，所以我们可以先筛选出1~N的每个质数p,然后考虑N！中有多少个质因子p 3.N!中质因子p的个数等于1N每个数包含质因子p的个数之和。在1N中p的倍数显然有n / p个，而p^2的倍数，即至少含有2个质因子p的个数有n / p^2个,因为其中的一个质因子已经在N / p中统计过了，所以这里不需要 * 2** **4.一次类推，我们便可以得到N！中质因子p的个数为(N / P) + (N / P^2) + (N / P^3) + ….. + N / plogp(N) 代码如下: 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int prime[N], cnt;bool st[N];int main()&#123; memset(st, true, sizeof st); for(int i = 2; i &lt;= 1000000; i++)&#123; //线性筛法预处理出所有的质数 if(st[i])prime[cnt++] = i; for(int j = 0; j &lt; cnt &amp;&amp; i * prime[j] &lt;= 1000000; j++)&#123; st[i * prime[j]] = false; if(i % prime[j] == 0)break; &#125; &#125; int n; cin &gt;&gt; n; for(int i = 0; i &lt; cnt; i++)&#123; //枚举质数 if(prime[i] &gt; n)break; int ans = 0; for(int j = prime[i]; j &lt;= n; j *=prime[i])&#123; ans += n / j; if(j &gt; n / prime[i])break; //防止j * prime[i]溢出 &#125; cout &lt;&lt; prime[i] &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/08/24/数论/阶乘分解/","date":"08-24","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"素数","slug":"素数","permalink":"http://zhumenger.top/tags/素数/"}]},{"title":"质数距离","text":"题目描述给定两个整数L和U，你需要在闭区间[L,U]内找到距离最接近的两个相邻质数C1和C2（即C2-C1是最小的），如果存在相同距离的其他相邻质数对，则输出第一对。 同时，你还需要找到距离最远的两个相邻质数D1和D2（即D1-D2是最大的），如果存在相同距离的其他相邻质数对，则输出第一对。 输入格式 每行输入两个整数L和U，其中L和U的差值不会超过1000000。 输出格式 对于每个L和U ，输出一个结果，结果占一行。 结果包括距离最近的相邻质数对和距离最远的相邻质数对。（具体格式参照样例） 如果L和U之间不存在质数对，则输出“There are no adjacent primes.”。 数据范围 1≤L&lt;U≤2^31−1 输入样例： 2 1714 17 输出样例： 2,3 are closest, 7,11 are most distant.There are no adjacent primes. 题解：1.虽然给出的数据范围很大，用已知的算法无法在规定时间内生成[L,R]中的所有质数，但r - l的数据范围确很小，并且任何一个合数N,必定包含一个不超过sqrt(n)的质因子 2.我们可以先用线性筛法求出2~sqrt(n)内所有的的质数,对于每个质数p,把[L, R]中能被p整除的数去掉，剩下的数便都是质数了 3.最后对相邻的质数俩俩比较，找出答案 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;stdio.h&gt;using namespace std;typedef long long ll;const int N = 1e6 + 10;int prime[N], cnt;bool st[N];void init() //线性筛法预处理出所有的质数&#123; cnt = 0; memset(st, true, sizeof st); for(int i = 2; i &lt;= 50000; i++)&#123; if(st[i]) prime[cnt++] = i; for(int j = 0; j &lt; cnt &amp;&amp; i * prime[j] &lt;= 50000; j++)&#123; st[i * prime[j]] = false; if(i % prime[j] == 0)break; &#125; &#125;&#125;int main()&#123; ll l, r; while(cin &gt;&gt; l &gt;&gt; r)&#123; init(); memset(st, true, sizeof st); for(int i = 0; i &lt; cnt; i++)&#123; int p = prime[i]; //对于每个质数p,把[L, R]中能被p整除的数去掉 //找到[l, r]中第一个p的倍数,即(l / p)(向上取整) * p,因为在c++中没法做到直接向上取整 //所以一般的写法为(l + p - 1)(向下取整) / p * p for(ll j = max((l + p - 1) / p * p, 2ll * p); j &lt;= r; j += p)&#123; st[j - l] = false; //由于r - l数据范围很小，所以可以用偏移量来标记 &#125; &#125; int cnt = 0; for(int i = 0; i + l &lt;= r; i++) //记录[L, R]中所有的质数 if(st[i] &amp;&amp; i + l &gt; 1)prime[cnt++] = i + l; if(cnt &lt; 2)cout &lt;&lt; \"There are no adjacent primes.\" &lt;&lt; endl; else &#123; int Max = 0, Min = 1e6 + 10, a, b, c, d; for(int i = 1; i &lt; cnt; i++)&#123; int t = prime[i] - prime[i - 1]; if(t &gt; Max)&#123; Max = t; a = prime[i - 1], b = prime[i]; &#125; if(t &lt; Min)&#123; Min = t; c = prime[i - 1], d = prime[i]; &#125; &#125; printf(\"%d,%d are closest, %d,%d are most distant.\\n\", c, d, a, b); &#125; &#125; return 0;&#125;","path":"2019/08/24/数论/质数距离/","date":"08-24","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"素数","slug":"素数","permalink":"http://zhumenger.top/tags/素数/"}]},{"title":"导弹防御系统(dfs)","text":"题目描述为了对抗附近恶意国家的威胁，R国更新了他们的导弹防御系统。 一套防御系统的导弹拦截高度要么一直上升要么一直下降。 例如，一套系统先后拦截了高度为3和高度为4的两发导弹，那么接下来该系统就只能拦截高度大于4的导弹。 给定即将袭来的一系列导弹的高度，请你求出至少需要多少套防御系统，就可以将它们全部击落。 输入格式 输入包含多组测试用例。 对于每个测试用例，第一行包含整数n，表示来袭导弹数量。 第二行包含n个不同的整数，表示每个导弹的高度 当输入测试用例n=0时，表示输入终止，且该用例无需处理。 输出格式 对于每个测试用例，输出一个占据一行的整数，表示所需的防御系统数量。 数据范围 1≤n≤50 输入样例： 5 3 5 2 4 10 输出样例： 2 样例解释 对于给出样例，最少需要两套防御系统。 一套击落高度为3,4的导弹，另一套击落高度为5,2,1的导弹。 题解：导弹防御系统很自然的想到LIS算法，不过这里的条件是一套防御系统的导弹拦截高度要么一直上升要么一直下降，所以用LIS算法是不正确的 而LIS中，最核心的思想在于能否将一个元素加入到序列中，只与这个序列目前的最后一个元素有关这道题就用了这个关键的思想。用up[k]和down[k]记录第k套上升（下降）系统目前所拦截的最后一个导弹dfs(u,v,t)意味着已有u个上升，v个下降，正在处理第t个数 按理说，每拿到一个新的数字应该将它所有能放入的序列都放一遍的但扩展节点时却存在一个贪心策略，大大节省了时间。假设现在要把一个数放入一个上升序列，那么一定是所有能放入的上升序列中，最后一个元素最大的那一个。其实想想也是，既然每个数字都要放到一个序列中，对于上升序列，肯定是目前越小越有用，既然能放入大的里面，何必浪费一个小的呢注意到其实up[i]按这种策略已经是排好序的了，所以只用找最先碰到的一个就行了 代码如下： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;const int N = 55;int a[N], ans, up[N], down[N], n;void dfs(int u, int d, int t) //u表示上升的系统个数，d表示下降的系统个数,t表示第t个数&#123; if(u + d &gt;= ans) return ; if(t == n)&#123; if(u + d &lt; ans)ans = u + d; return ; &#125; int i; for(i = 1; i &lt;= u; i++) //找到第一个末尾数小于a[t]的导弹系统 if(up[i] &lt; a[t])break; int temp = up[i]; up[i] = a[t];//添加到该导弹系统中 dfs(max(u, i), d, t + 1); up[i] = temp; //恢复现场 for(i = 1; i &lt;= d; i++)//找到第一个末尾数大于a[t]的导弹系统 if(down[i] &gt; a[t])break; temp = down[i]; down[i] = a[t];//添加到该导弹系统中去 dfs(u, max(d, i), t + 1); down[i] = temp;//恢复现场&#125;int main()&#123; while(scanf(\"%d\", &amp;n) != EOF &amp;&amp; n != 0)&#123; ans = 100; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; dfs(0, 0, 0); printf(\"%d\\n\", ans); &#125; return 0;&#125;","path":"2019/08/20/搜索/导弹防御系统-dfs/","date":"08-20","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"靶形数独(数独1变形)","text":"题目描述小城和小华都是热爱数学的好学生，最近，他们不约而同地迷上了数独游戏，好胜的他们想用数独来一比高低。 但普通的数独对他们来说都过于简单了，于是他们向Z博士请教，Z博士拿出了他最近发明的“靶形数独”，作为这两个孩子比试的题目。 靶形数独的方格同普通数独一样，在9×9的大九宫格中有9个3×3的小九宫格（用粗黑色线隔开的）。 在这个大九宫格中，有一些数字是已知的，根据这些数字，利用逻辑推理，在其他的空格上填入1到9的数字。 每个数字在每个小九宫格内不能重复出现，每个数字在每行、每列也不能重复出现。 但靶形数独有一点和普通数独不同，即每一个方格都有一个分值，而且如同一个靶子一样，离中心越近则分值越高（如下图所示）。 上图具体的分值分布是：最里面一格（黄色区域）为10分，黄色区域外面的一圈（红色区域）每个格子为9分，再外面一圈（蓝色区域）每个格子为8分，蓝色区域外面一圈（棕色区域）每个格子为7分，最外面一圈（白色区域）每个格子为6 分，如上图所示。 比赛的要求是：每个人必须完成一个给定的数独（每个给定数独可能有不同的填法），而且要争取更高的总分数。 而这个总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和。 如图，在以下的这个已经填完数字的靶形数独游戏中，总分数为2829。 游戏规定，将以总分数的高低决出胜负。 由于求胜心切，小城找到了善于编程的你，让你帮他求出，对于给定的靶形数独，能够得到的最高分数。 输入格式 输入一共包含9行。 每行 9 个整数（每个数都在 0—9 的范围内），表示一个尚未填满的数独方格，未填的空格用“0”表示。 每两个数字之间用一个空格隔开。 输出格式 输出可以得到的靶形数独的最高分数。 如果这个数独无解，则输出整数-1。 数据范围 40%的数据，数独中非 0 数的个数不少于 30。 80%的数据，数独中非 0 数的个数不少于 26。 100%的数据，数独中非 0 数的个数不少于 24。 输入样例： 7 0 0 9 0 0 0 0 11 0 0 0 0 5 9 0 00 0 0 2 0 0 0 8 00 0 5 0 2 0 0 0 30 0 0 0 0 0 6 4 84 1 3 0 0 0 0 0 00 0 7 0 0 2 0 9 02 0 1 0 6 0 8 0 40 8 0 5 0 4 0 1 2 输出样例： 2829 题解：思路给我之前写的 数独题解 一模一样，这里多了一个get_source()函数用来获取填入数x时可以得到的分数,并用dfs(cnt, source)来记录每一个状态，当cnt减为0时，记录答案的最大值并返回，继续其他的分支 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;using namespace std;const int N = 9;int r[9], c[9], cell[3][3];//使用位运算来表示行，列和九宫格已经出现了的数int ones[1 &lt;&lt; N], map[1 &lt;&lt; N]; //ones表示i的二进制中有多少个1int g[10][10], ans = -1;int lowbit(int x) //lowbit运算，返回最低位的1以及后面的0&#123; return x &amp; (-x);&#125;int get(int x, int y)//获得x行y列还有哪些数可以选&#123; return r[x] &amp; c[y] &amp; cell[x / 3][y / 3];//位运算相与&#125;int get_source(int x, int y) //获得该坐标下的成绩&#123; return min(min(x, 8 - x), min(y, 8 - y)) + 6;&#125;void init()&#123; //map映射1左移i位对应的是哪个数可以填在九宫格里 for(int i = 0; i &lt; N; i++)map[1 &lt;&lt; i] = i; //枚举所有的状态，求出i的二进制中有多少个1 for(int i = 0; i &lt; 1 &lt;&lt; N; i++)&#123; int s = 0; for(int j = i; j != 0; j -= lowbit(j))s++; ones[i] = s; &#125; //预处理，将行，列，九宫格都初始化为二进制111111111，表示1~9都可以填 for(int i = 0; i &lt; 9; i++)r[i] = c[i] = (1 &lt;&lt; N) - 1; for(int i = 0; i &lt; 3; i++) for(int j = 0; j &lt; 3; j++) cell[i][j] = (1 &lt;&lt; N) - 1;&#125;bool dfs(int cnt, int source)&#123; if(cnt == 0)&#123; ans = max(ans, source); return false; //return false表示将所有的状态都搜索一遍 &#125; //找出可选方案数最少的格子 int minv = 10; int x, y; for(int i = 0; i &lt; 9; i++)&#123; for(int j = 0; j &lt; 9; j++)&#123; if(g[i][j] == 0)&#123; //t表示该格子有多少个可以填的数 int t = ones[get(i, j)]; if(t &lt; minv)&#123; minv = t; x = i, y = j; &#125; &#125; &#125; &#125; //枚举可以填入的数 for(int i = get(x, y); i != 0; i -= lowbit(i))&#123; int t = map[lowbit(i)]; r[x] -= 1 &lt;&lt; t; c[y] -= 1 &lt;&lt; t; cell[x / 3][y / 3] -= 1 &lt;&lt; t; g[x][y] = t + 1; dfs(cnt - 1, source + get_source(x, y) * (t + 1)); //恢复现场 r[x] += 1 &lt;&lt; t; c[y] += 1 &lt;&lt; t; cell[x / 3][y / 3] += 1 &lt;&lt; t; g[x][y] = 0; &#125; return false;&#125;int main()&#123; init(); int cnt = 0, source = 0;; for(int i = 0; i &lt; N; i++)&#123; for(int j = 0; j &lt; N; j++)&#123; int x; cin &gt;&gt; x; g[i][j] = x; //如果这个数已经填在了九宫格里，则需要在行，列和九空格中去掉该数 if(x != 0)&#123; r[i] -= 1 &lt;&lt; (x - 1);//(去掉x这个数，需要将1左移(x - 1)位) c[j] -= 1 &lt;&lt; (x - 1); cell[i / 3][j / 3] -= 1 &lt;&lt; (x - 1); source += get_source(i, j) * x;//统计分数 &#125; else cnt++; //统计有多少个空位需要填 &#125; &#125; dfs(cnt, source); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","path":"2019/08/20/搜索/靶形数独(数独1变形)/","date":"08-20","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"回转游戏(Astar + dfs)","text":"题目描述如下图所示，有一个“#”形的棋盘，上面有1,2,3三种数字各8个。 给定8种操作，分别为图中的A~H。 这些操作会按照图中字母和箭头所指明的方向，把一条长为8的序列循环移动1个单位。 例如下图最左边的“#”形棋盘执行操作A后，会变为下图中间的“#”形棋盘，再执行操作C后会变成下图最右边的“#”形棋盘。 给定一个初始状态，请使用最少的操作次数，使“#”形棋盘最中间的8个格子里的数字相同。 输入格式 输入包含多组测试用例。 每个测试用例占一行，包含24个数字，表示将初始棋盘中的每一个位置的数字，按整体从上到下，同行从左到右的顺序依次列出。 输入样例中的第一个测试用例，对应上图最左边棋盘的初始状态。 当输入只包含一个“0”的行时，表示输入终止。 输出格式 每个测试用例输出占两行。 第一行包含所有移动步骤，每步移动用大写字母“A~G”中的一个表示，字母之间没有空格，如果不需要移动则输出“No moves needed”。 第二行包含一个整数，表示移动完成后，中间8个格子里的数字。 如果有多种方案，则输出字典序最小的解决方案。 输入样例： 1 1 1 1 3 2 3 2 3 1 3 2 2 3 1 2 2 2 3 1 2 1 3 31 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 30 输出样例： AC2 DDHH2 题解： 1.确定dfs框架:dfs(depth, k)depth表示当前操作的步数,k表示步数限制 2.设计预估函数:首先计算出格子里出现最多次数的数字是k,剩下的数字有m个与k不同,那么把中间8个格子里的数字都变为k,至少需要m次操作因此我们可以m为估价即可 3.采用迭代加深的方法,可以先从深度为初始状态的预估值m开始从小到大依次限制操作次数，在每个dfs状态下，如果“当前深度步数 + 估价 &gt; 深度限制” 则直接回溯 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int a[10][10];char ans[100];int f() //估价函数&#123; int cnt[5] = &#123;0&#125;; for(int i = 3; i &lt;= 5; i++) for(int j = 3; j &lt;= 5; j++)&#123; if(i == 4 &amp;&amp; j == 4)continue; cnt[a[i][j]]++; &#125; return 8 - max(cnt[1], max(cnt[2], cnt[3]));&#125;bool dfs(int depth, int K)&#123; if(depth &gt;= K)&#123; for(int i = 3; i &lt;= 5; i++) for(int j = 3; j &lt;= 5; j++)&#123; if(i == 4 &amp;&amp; j == 4)continue; if(a[i][j] != a[3][3])return false; &#125; return true; &#125; if(depth + f() &gt; K)return false; //8个方向深搜，保证此次操作不会回到上一个状态 if(depth == 0 || (depth &gt; 0 &amp;&amp; ans[depth - 1] != 'F'))&#123; ans[depth] = 'A'; for(int i = 0; i &lt; 7; i++) a[i][3] = a[i + 1][3]; a[7][3] = a[0][3]; if(dfs(depth + 1, K))return true; for(int i = 8; i &gt;= 2; i--) a[i][3] = a[i - 1][3]; //恢复现场 a[1][3] = a[8][3]; &#125; if(depth == 0 || (depth &gt; 0 &amp;&amp; ans[depth - 1] != 'E'))&#123; ans[depth] = 'B'; for(int i = 0; i &lt; 7; i++) a[i][5] = a[i + 1][5]; a[7][5] = a[0][5]; if(dfs(depth + 1, K))return true; for(int i = 8; i &gt;= 2; i--) a[i][5] = a[i - 1][5]; a[1][5] = a[8][5]; &#125; if(depth == 0 || (depth &gt; 0 &amp;&amp; ans[depth - 1] != 'H'))&#123; ans[depth] = 'C'; for(int i = 8; i &gt;= 2; i--) a[3][i] = a[3][i - 1]; a[3][1] = a[3][8]; if(dfs(depth + 1, K))return true; for(int i = 0; i &lt; 7; i++) a[3][i] = a[3][i + 1]; a[3][7] = a[3][0]; &#125; if(depth == 0 || (depth &gt; 0 &amp;&amp; ans[depth - 1] != 'G'))&#123; ans[depth] = 'D'; for(int i = 8; i &gt;= 2; i--) a[5][i] = a[5][i - 1]; a[5][1] = a[5][8]; if(dfs(depth + 1, K))return true; for(int i = 0; i &lt; 7; i++) a[5][i] = a[5][i + 1]; a[5][7] = a[5][0]; &#125; if(depth == 0 || (depth &gt; 0 &amp;&amp; ans[depth - 1] != 'B'))&#123; ans[depth] = 'E'; for(int i = 8; i &gt;= 2; i--) a[i][5] = a[i - 1][5]; a[1][5] = a[8][5]; if(dfs(depth + 1, K))return true; for(int i = 0; i &lt; 7; i++) a[i][5] = a[i + 1][5]; a[7][5] = a[0][5]; &#125; if(depth == 0 || (depth &gt; 0 &amp;&amp; ans[depth - 1] != 'A'))&#123; ans[depth] = 'F'; for(int i = 8; i &gt;= 2; i--) a[i][3] = a[i - 1][3]; a[1][3] = a[8][3]; if(dfs(depth + 1, K))return true; for(int i = 0; i &lt; 7; i++) a[i][3] = a[i + 1][3]; a[7][3] = a[0][3]; &#125; if(depth == 0 || (depth &gt; 0 &amp;&amp; ans[depth - 1] != 'D'))&#123; ans[depth] = 'G'; for(int i = 0; i &lt; 7; i++) a[5][i] = a[5][i + 1]; a[5][7] = a[5][0]; if(dfs(depth + 1, K))return true; for(int i = 8; i &gt;= 2; i--) a[5][i] = a[5][i - 1]; a[5][1] = a[5][8]; &#125; if(depth == 0 || (depth &gt; 0 &amp;&amp; ans[depth - 1] != 'C'))&#123; ans[depth] = 'H'; for(int i = 0; i &lt; 7; i++) a[3][i] = a[3][i + 1]; a[3][7] = a[3][0]; if(dfs(depth + 1, K))return true; for(int i = 8; i &gt;= 2; i--) a[3][i] = a[3][i - 1]; a[3][1] = a[3][8]; &#125; return false;&#125;int main()&#123; scanf(\"%d\", &amp;a[1][3]); while(a[1][3])&#123; cin &gt;&gt; a[1][5] &gt;&gt; a[2][3] &gt;&gt; a[2][5]; for(int i = 1; i &lt;= 7; i++) cin &gt;&gt; a[3][i]; cin &gt;&gt; a[4][3] &gt;&gt; a[4][5]; for(int i = 1; i &lt;= 7; i++) cin &gt;&gt; a[5][i]; cin &gt;&gt; a[6][3] &gt;&gt; a[6][5] &gt;&gt; a[7][3] &gt;&gt; a[7][5]; for(int i = f(); ;i++)&#123; if(dfs(0, i))&#123; if(i == 0)&#123; cout &lt;&lt; \"No moves needed\" &lt;&lt; endl; cout &lt;&lt; a[3][3] &lt;&lt; endl; break; &#125; for(int j = 0; j &lt; i; j++)cout &lt;&lt; ans[j]; cout &lt;&lt; endl; cout &lt;&lt; a[3][3] &lt;&lt; endl; break; &#125; &#125; scanf(\"%d\", &amp;a[1][3]); &#125; return 0;&#125;","path":"2019/08/19/搜索/回转游戏-Astar-dfs/","date":"08-19","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"},{"name":"A*","slug":"A","permalink":"http://zhumenger.top/tags/A/"}]},{"title":"排书(A* + dfs)","text":"题目描述给定n本书，编号为1-n。 在初始状态下，书是任意排列的。 在每一次操作中，可以抽取其中连续的一段，再把这段插入到其他某个位置。 我们的目标状态是把书按照1-n的顺序依次排列。 求最少需要多少次操作。 输入格式 第一行包含整数T，表示共有T组测试数据。 每组数据包含两行，第一行为整数n，表示书的数量。 第二行为n个整数，表示1-n的一种任意排列。 同行数之间用空格隔开。 输出格式 每组数据输出一个最少操作次数。 如果最少操作次数大于或等于5次，则输出”5 or more”。 每个结果占一行。 数据范围 1≤n≤15 输入样例： 3 61 3 4 6 2 55 5 4 3 2 1106 8 5 3 4 7 2 9 1 10 输出样例： 2 35 or more 题解： 1.枚举长度i，当长度为i时有n - i + 1种不同的选择,有n - i种可以插入的位置，所以可以得到每个状态所有的分(n - i) * (n - i + 1)(1 &lt;= i &lt;= n - 1)的总和, 为560种 数量为(n - i) * (n - i + 1)(1 &lt;= i &lt;= n - 1)的总和, 为560种, 2.题目要求在4次操作内是否能实现目标, 4层搜索树的规模为560^4,时间复杂度过大,所以这里可以用到A*算法来做 3.首先我们需要得到预估函数值,在目标状态下,第i本书的后面应该是第i + 1本书,我们称i + 1 是 i 的正确后继, 在 任意状态我们可以算出错误后继的总个数tot,我们每进行一次操作,在最理想的情况下可以减少3个错误后继,消 除所有的错误后继,需要 tot / 3 (向上取整)个操作因此我们可以将预估函数设计为f(s) = tot / 3(向上取整), tot表 示在状态s下书的错误后继总数 4.采用迭代加深的方法，从起始状态dfs,每次将抽取的一段移动到它的后面某个位置，当进入状态s时，判断当 前深度 + 预估值f(s)是否超出了步数限制,直到找到正确答案。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 20;int a[N];int n;int ans;void dfs(int depth, int K)&#123; int tot = 0; for(int i = 0; i &lt; n - 1; i++) //找出书的错误后继 if(a[i] + 1 != a[i + 1]) tot++; if(tot == 0)&#123; //如果书摆放正确 ans = min(depth, ans);//更新答案 return ; &#125; if((depth + (tot + 2) / 3) &gt; K) return ; //判断判断当前深度depth + 预估值f(s)是否超出了步数限制K for(int i = 1; i &lt; n; i++)&#123; //枚举长度 for(int j = 0; j + i - 1 &lt; n; j ++)&#123; //枚举起点和终点 for(int k = j + 1; k + i - 1 &lt; n; k++)&#123; //枚举要插入的位置 int b[20]; for(int o = 0; o &lt; n; o++) b[o] = a[o]; for(int o = k; o &lt;= k + i - 1; o++)//移动 a[o] = b[o - k + j]; for(int o = i + j; o &lt;= k + i - 1; o ++) a[o - i] = b[o]; dfs(depth + 1, K); for(int o = 0; o &lt; n; o++)//恢复现场 a[o] = b[o]; &#125; &#125; &#125; return ;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; ans = 6; for(int k = 1; k &lt;= 4 &amp;&amp; ans == 6; k++) dfs(0, k); if(ans == 6) cout &lt;&lt; \"5 or more\" &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/08/19/搜索/排书-Astar + dfs/","date":"08-19","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"},{"name":"A*","slug":"A","permalink":"http://zhumenger.top/tags/A/"}]},{"title":"骑士(Astar + dfs)","text":"题目描述在一个5×5的棋盘上有12个白色的骑士和12个黑色的骑士， 且有一个空位。在任何时候一个骑士都能按照骑士的走法（它可以走到和它横坐标相差为1，纵坐标相差为2或者横坐标相差为2，纵坐标相差为1的格子）移动到空位上。 给定一个初始的棋盘，怎样才能经过移动变成如下目标棋盘： 为了体现出骑士精神，他们必须以最少的步数完成任务。 Input第一行有一个正整数T（T&lt;=10） 表示一共有T组数据 接下来有T个55的矩形。0表示白色骑士1表示黑色骑士，表示空位。(每组数据间有空行) Output 对每组数据都输出一行。如果能在15不以内（包括15）到达目标状态，则输出步数，否则输出“Bored!”没有引号。 Sample Input 2 1011001*11101110100100000 01011110*1011100101000100 Sample Output 7 Bored! 题解： 迭代加深的A*算法: 1.A*算法与dfs结合，这里的估价函数表示到达目的状态需要的最少的步数, 2.构建dfs(depth, x, y, k), depth表示到达(x, y)点时所需要的步数，k表示步数限制； 3.如果当前深度depth + 预估函数f &gt; k 则直接返回， 如果预估函数的值为0，说明已经到达目的状态，返回答案即可， 不断加大深度限制k，直到找到答案 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int dx[8] = &#123;-2, -2, -1, 1, 2, 2, -1, 1&#125;; //8个点遍历int dy[8] = &#123;-1, 1, 2, 2, -1, 1, -2, -2&#125;;char End[6][6] = &#123;\"11111\", \"01111\", \"00*11\", \"00001\", \"00000\"&#125;;//目的状态char g[6][6], f[6][6];int flag;int check() //预估函数,表示到达目的状态所需要的最少的步数&#123; int cnt = 0; for(int i = 0; i &lt; 5; i++) for(int j = 0; j &lt; 5; j++) if(f[i][j] != End[i][j]) cnt++; return cnt;&#125;void dfs(int death, int x, int y, int k)//深度限制为k时，到达(x, y)的当前步数为depth&#123; if(flag)return ; if(check() == 0)&#123; //如果到达目的状态 flag = 1; return ; &#125; if(death + check() - 1 &gt; k)return ; //当前步数 + 预估步数 &gt; 深度限制k for(int i = 0; i &lt; 8; i++)&#123; //8个方向遍历 int a = x + dx[i]; int b = y + dy[i]; if(a &gt;= 0 &amp;&amp; a &lt; 5 &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; 5)&#123; swap(f[a][b], f[x][y]); dfs(death + 1, a, b, k); swap(f[a][b], f[x][y]); &#125; &#125; return ;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; flag = 0; int x, y; for(int i = 0; i &lt; 5; i++)&#123; for(int j = 0; j &lt; 5; j++)&#123; cin &gt;&gt; g[i][j]; if(g[i][j] == '*') x = i, y = j; &#125; &#125; for(int i = 0; i &lt;= 15; i++)&#123; //增加深度限制 for(int i = 0; i &lt; 5; i ++) for(int j = 0; j &lt; 5; j++) f[i][j] = g[i][j]; dfs(0, x, y, i); if(flag)&#123; printf(\"%d\\n\", i); break; &#125; &#125; if(!flag)printf(\"Bored!\\n\"); &#125; return 0;&#125;","path":"2019/08/18/搜索/骑士-Astar-dfs/","date":"08-18","excerpt":"","tags":[{"name":"A*","slug":"A","permalink":"http://zhumenger.top/tags/A/"}]},{"title":"八数码(Astar + bfs)","text":"题目描述在一个3×3的网格中，1~8这8个数字和一个“X”恰好不重不漏地分布在这3×3的网格中。 例如： 1 2 3X 4 67 5 8 在游戏过程中，可以把“X”与其上、下、左、右四个方向之一的数字交换（如果存在）。 我们的目的是通过交换，使得网格变为如下排列（称为正确排列）： 1 2 34 5 67 8 X 例如，示例中图形就可以通过让“X”先后与右、下、右三个方向的数字交换成功得到正确排列。 交换过程如下： 1 2 3 1 2 3 1 2 3 1 2 3X 4 6 4 X 6 4 5 6 4 5 67 5 8 7 5 8 7 X 8 7 8 X 把“X”与上下左右方向数字交换的行动记录为“u”、“d”、“l”、“r”。 现在，给你一个初始网格，请你通过最少的移动次数，得到正确排列。 输入格式 输入占一行，将3×3的初始网格描绘出来。 例如，如果初始网格如下所示：1 2 3 x 4 6 7 5 8 则输入为：1 2 3 x 4 6 7 5 8 输出格式 输出占一行，包含一个字符串，表示得到正确排列的完整行动记录。 如果不存在解决方案，则输出”unsolvable”。 输入样例： 2 3 4 1 5 x 7 6 8 输出样例 ullddrurdllurdruldr 题解： 八数码问题无解: 当且仅当展开的逆序对数量是奇数1.使用A*算法搜索一种移动步数最少的方案, 预估函数可以是当前状态到目标状态的所有曼哈顿距离之和;2.建立二元组(dist + f(state), state) state表示当前状态， 建立二叉堆，从堆中不断的取出从初态到当前状态state已经移动过的步数f(state)最小的一个状态进行扩展，当终态第一次被取出时，就得到了答案;3.由于每一个状态都是用字符串来表示的,所以我们可以用hash来记录当前状态是否出现过,我们还需要俩个哈希变量prev和dist分别来记录移动的轨迹和距离 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;unordered_map&gt;using namespace std;int dx[] = &#123;0, 0, 1, -1&#125;;int dy[] = &#123;1, -1, 0, 0&#125;;char op[] = &#123;'r', 'l', 'd', 'u'&#125;;int f(string state) //得到当前状态到最终状态的预估值&#123; int res = 0; for(int i = 0; i &lt; state.size(); i++)&#123; if(state[i] != 'x')&#123; int t = state[i] - '1'; res += abs(i / 3 - t / 3) + abs(i % 3 - t % 3); &#125; &#125; return res;&#125;string bfs(string start)&#123; string end = \"12345678x\"; //终态 unordered_map&lt;string, int &gt; dist; //表示距离 unordered_map&lt;string, bool&gt; st; //记录当前状态是否出现过 unordered_map&lt;string, pair&lt;string, char&gt;&gt; prev; //当前状态的上一个状态是谁，并记录操作方法 priority_queue&lt;pair&lt;int, string&gt;, vector&lt;pair&lt;int, string&gt;&gt;, greater&lt;pair&lt;int, string&gt;&gt;&gt; q;//建立二叉堆 q.push(&#123;0, start&#125;); while(q.size())&#123; auto t = q.top(); q.pop(); string state = t.second; if(state == end)break; if(st[state])continue; st[state] = true; int step = dist[state]; int x, y; for(int i = 0; i &lt; state.size(); i++)&#123; //找到空格 if(state[i] == 'x')&#123; x = i / 3; y = i % 3; break; &#125; &#125; string source = state; for(int i = 0; i &lt; 4; i++)&#123; //4个方向便利 state = source; int a = x + dx[i]; int b = y + dy[i]; if(a &gt;= 0 &amp;&amp; a &lt; 3 &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; 3)&#123; //判断是否合法 swap(state[x * 3 + y], state[a * 3 + b]); //移动 if(!dist[state] || dist[state] &gt; step + 1)&#123; //如果当前状态没有出现过,或者距离更短 dist[state] = step + 1; //更新 prev[state] = &#123;source, op[i]&#125;; //记录 q.push(&#123;dist[state] + f(state),state&#125;); //入队 &#125; &#125; &#125; &#125; string res; while(end != start)&#123; //倒序得到答案 res += prev[end].second; end = prev[end].first; &#125; reverse(res.begin(), res.end()); //翻转 return res;&#125;int main()&#123; string g, c, seq; while(cin &gt;&gt; c)&#123; g += c; if(c != \"x\") seq += c; &#125; int t = 0; for(int i = 0; i &lt; seq.size(); i++) //求逆序对 for(int j = i + 1; j &lt; seq.size(); j++) if(seq[j] &lt; seq[i])t++; if(t % 2 == 1)puts(\"unsolvable\");//如果为奇数,无解 else cout &lt;&lt; bfs(g) &lt;&lt; endl; return 0;&#125;","path":"2019/08/18/搜索/八数码-(Astar + bfs)/","date":"08-18","excerpt":"","tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"},{"name":"A*","slug":"A","permalink":"http://zhumenger.top/tags/A/"}]},{"title":"第k短路(Astar + bfs算法)","text":"题目描述给定一张N个点（编号1,2…N），M条边的有向图，求从起点S到终点T的第K短路的长度，路径允许重复经过点或边。 注意： 每条最短路中至少要包含一条边。 输入格式 第一行包含两个整数N和M。 接下来M行，每行包含三个整数A,B和L，表示点A与点B之间存在有向边，且边长为L。 最后一行包含三个整数S,T和K，分别表示起点S，终点T和第K短路。 输出格式 输出占一行，包含一个整数，表示第K短路的长度，如果第K短路不存在，则输出“-1”。 数据范围 1≤S,T≤N≤10000≤M≤1051≤K≤10001≤L≤100 输入样例： 2 21 2 52 1 41 2 2 输出样例： 14 题解： a_star(A *)算法 1.求出预估函数:预处理出各个节点到终点T的最短路的长度—反向求单源最短路得到预估数组f(x),2.建立二叉堆,存储(dist + f(x),(dist, x)), x为节点的编号, dist表示从S到节点x走过的距离,起初堆里只有(0 + f(S), (S, 0));3.每次从二叉堆中取出最小的dist + f(x), 然后沿着从x出发的每条边(x, y)进行扩展, 如果节点y被取出的次数未达到k，则将(dist + length(x, y) + f[y], (y, dist + length(x, y)))入队.4.重复2、3步，直到终点T第K次被取出,这时dist便是我们的答案. 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010, M = 200010;typedef pair&lt;int, int &gt; p;int h[N], rh[N], e[M], ne[M], w[M], idx;int dist[N], f[N], st[N];int S, T, K;int n, m;void add(int *h, int a, int b, int c)&#123; e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;&#125;void dijkstra()//迪杰斯特拉求单源最短路得到预估数组&#123; priority_queue&lt;p, vector&lt;p&gt;, greater&lt;p&gt; &gt; q; memset(dist, 0x3f, sizeof dist); dist[T] = 0; q.push(&#123;0, T&#125;); while(q.size())&#123; p t = q.top(); q.pop(); if(st[t.second])continue; st[t.second] = 1; for(int i = rh[t.second]; i != -1; i = ne[i])&#123; int j = e[i]; if(dist[j] &gt; dist[t.second] + w[i])&#123; dist[j] = dist[t.second] + w[i]; q.push(&#123;dist[j], j&#125;); &#125; &#125; &#125; memcpy(f, dist, sizeof dist);&#125;int a_star()//A*算法,每次取出对重当前花费+预估花费最小的那个&#123; priority_queue&lt;pair&lt;int, p&gt;, vector&lt;pair&lt;int, p&gt;&gt;, greater&lt;pair&lt;int, p&gt;&gt; &gt; q; q.push(&#123;f[S], &#123;0, S&#125;&#125;); memset(st, 0, sizeof st); while(q.size())&#123; auto t = q.top(); q.pop(); int ver = t.second.second; int d = t.second.first; if(st[ver] &gt;= K)continue; st[ver]++; if(ver == T &amp;&amp; st[ver] == K)return d; for(int i = h[ver]; i != -1; i = ne[i])&#123; int j = e[i]; if(st[j] &lt; K)&#123; q.push(&#123;d + w[i] + f[j], &#123;d + w[i], j&#125;&#125;); &#125; &#125; &#125; return -1;&#125;int main()&#123; memset(h, -1, sizeof h); memset(rh, -1, sizeof rh); cin &gt;&gt; n &gt;&gt; m; while(m--)&#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(h, a, b, c); add(rh, b, a, c);//建立反向图 &#125; cin &gt;&gt; S &gt;&gt; T &gt;&gt; K; if(S == T)K++;//题目要求每条最短路至少有一条边,如果起点和终点重合,那么求得便是第k + 1 条路, dijkstra(); printf(\"%d\\n\", a_star()); return 0;&#125;","path":"2019/08/18/搜索/第k短路-(Astar + bfs)算法/","date":"08-18","excerpt":"","tags":[{"name":"A*","slug":"A","permalink":"http://zhumenger.top/tags/A/"}]},{"title":"噩梦(双向BFS)","text":"题目描述给定一张N*M的地图，地图中有1个男孩，1个女孩和2个鬼。 字符“.”表示道路，字符“X”表示墙，字符“M”表示男孩的位置，字符“G”表示女孩的位置，字符“Z”表示鬼的位置。 男孩每秒可以移动3个单位距离，女孩每秒可以移动1个单位距离，男孩和女孩只能朝上下左右四个方向移动。 每个鬼占据的区域每秒可以向四周扩张2个单位距离，并且无视墙的阻挡，也就是在第k秒后所有与鬼的曼哈顿距离不超过2k的位置都会被鬼占领。 注意： 每一秒鬼会先扩展，扩展完毕后男孩和女孩才可以移动。 求在不进入鬼的占领区的前提下，男孩和女孩能否会合，若能会合，求出最短会合时间。 输入格式 第一行包含整数T，表示共有T组测试用例。 每组测试用例第一行包含两个整数N和M，表示地图的尺寸。 接下来N行每行M个字符，用来描绘整张地图的状况。（注意：地图中一定有且仅有1个男孩，1个女孩和2个鬼） 输出格式 每个测试用例输出一个整数S，表示最短会合时间 如果无法会合则输出-1。 每个结果占一行。 数据范围 1&lt;n,m&lt;800 输入样例： 3 5 6XXXXXXXZ..ZXXXXXXXM.G………5 6XXXXXXXZZ..XXXXXXXM…....G…10 10………...X……...M.X…X.X……….X..X.X.X.………X..XX….X.X….G…X…ZX.X……Z..X..X 输出样例： 1 1-1 题解： 双向bfs问题:1.用俩个队列分别从男孩的起始位置和女孩的起始位置开始进行bfs;2.每一轮中，男孩bfs3次,女孩bfs1次;3.使用数组d来记录男孩和女孩的可达性;4.在bfs时,计算新状态与鬼之间的曼哈顿距离是否合法;5.最后便可以得到我们想要的答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int N = 810;typedef pair&lt;int, int&gt; p;int n, m;char g[N][N];int st[N][N];//记录三种状态st = 0表示没有人经过该点,st = 1表示男孩经过该点,st = 2表示女孩经过改点int dx[] = &#123;0, 0, 1, -1&#125;;int dy[] = &#123;1, -1, 0, 0&#125;;p boy, girl, ghost[2];//记录男孩、女孩和鬼的位置bool check(int x, int y, int step)//判断该点是否合格&#123; if(x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || g[x][y] == 'X')return false; for(int i = 0;i &lt; 2; i++)&#123; if(abs(x - ghost[i].first) + abs(y - ghost[i].second) &lt;= 2 *step)return false; &#125; return true;&#125;int bfs()&#123; int cnt = 0; memset(st, 0, sizeof st); for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++)&#123; if(g[i][j] == 'M')boy = &#123;i, j&#125;; if(g[i][j] == 'G')girl = &#123;i, j&#125;; if(g[i][j] == 'Z')ghost[cnt++] = &#123;i, j&#125;; &#125; int step = 0; queue&lt;p&gt; qb, qg; qb.push(boy), qg.push(girl); while(qb.size() || qg.size())&#123; step++;//时间 for(int i = 0; i &lt; 3; i++)&#123; //每一秒男孩走3次 for(int j = 0, len = qb.size(); j &lt; len; j++)&#123; p t = qb.front(); qb.pop(); int x = t.first, y = t.second; if(!check(x, y, step))continue;//如果不合格 for(int k = 0; k &lt; 4; k++)&#123; int a = x + dx[k]; int b = y + dy[k]; if(check(a, b, step))&#123; if(st[a][b] == 2)return step; //如果女孩在该点 if(!st[a][b])&#123; st[a][b] = 1; qb.push(&#123;a, b&#125;); &#125; &#125; &#125; &#125; &#125; for(int i = 0; i &lt; 1; i++)&#123; //女孩走一次 for(int j = 0, len = qg.size(); j &lt; len; j++)&#123; p t = qg.front(); qg.pop(); int x = t.first, y = t.second; if(!check(x, y, step))continue; for(int k = 0; k &lt; 4; k++)&#123; int a = x + dx[k]; int b = y + dy[k]; if(check(a, b, step))&#123; if(st[a][b] == 1)return step; //如果男孩在该点 if(!st[a][b])&#123; st[a][b] = 2; qg.push(&#123;a, b&#125;); &#125; &#125; &#125; &#125; &#125; &#125; return -1;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) scanf(\"%s\", g[i]); printf(\"%d\\n\", bfs()); &#125; return 0;&#125;","path":"2019/08/18/搜索/噩梦-双向BFS/","date":"08-18","excerpt":"","tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"矩阵(二维数组哈希)","text":"题目描述 给定一个M行N列的01矩阵（只包含数字0或1的矩阵），再执行Q次询问，每次询问给出一个A行B列的01矩阵，求该矩阵是否在原矩阵中出现过。 输入格式 第一行四个整数M,N,A,B。 接下来一个M行N列的01矩阵，数字之间没有空格。 接下来一个整数Q。 接下来Q个A行B列的01矩阵，数字之间没有空格。 输出格式 对于每个询问，输出1表示出现过，0表示没有出现过。 数据范围 A≤100，M,N,B≤1000，Q≤1000 输入样例： 3 3 2 21110001113 110011110011 输出样例： 1 01 题解： 二维数组哈希 1.先预处理出每一行的哈希值，这样可以在O(1)的时间内获得任意子段的哈希值 2.二维数组哈希的进制位数从子矩阵的右下角开始，比如长和宽都为2子矩阵的哈希值为:h = a[0] [0] * p^3 + a[0] [1] * p^2 + a[1] [0] * p^1 + a[1] [1] * p^0 3.假设要求一个a行b列的子矩阵是否出现过，用S来表示子矩阵的哈希值；先枚举每一列，维护一个长度为b的矩阵，再枚举每一行，获得每一行长度为b的哈希值，那么原先子矩阵的所有位数都要扩大P^b, 那么此时的子矩阵的哈希值S = S * p ^ b + hash(i, l, r) 4.如果矩阵的行数大于a行，还需要减去最上面的那一行，此时子矩阵的哈希值S = S - hash(i - a + 1, l, r) * p ^ (a*b) 5.获得每个子矩阵的hash值后，用哈希表来存储即可 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;unordered_map&gt;using namespace std;typedef unsigned long long ULL;const int N = 1010, base = 131;int n, m, a, b;ULL h[N][N], p[N * N];char s[N];ULL get(ULL f[], int l, int r)&#123; return f[r] - f[l - 1] * p[r - l + 1];&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b; p[0] = 1; for(int i = 1; i &lt;= n * m; i++) p[i] =p[i - 1] * base; for(int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; (s + 1); //预处理每一行的哈希值 for(int j = 1; j &lt;= m; j++)h[i][j] = h[i][j - 1] * base + s[j] - '0'; &#125; unordered_map&lt;ULL, int&gt; S; for(int i = b; i &lt;= m; i++)&#123; ULL ans = 0; int l = i - b + 1, r = i; for(int j = 1; j &lt;= n; j++)&#123; //每处理一行，前面的数的位数都要提升b位,再加上本行的哈希值 //便是这个矩阵的哈希值 ans = ans * p[b] + get(h[j], l, r); //如果j &gt; a, 还需要减去之前的一行，保证这个矩阵是a * b的 //也就是减去之前一行的哈希值乘以它的位数，即h[j - a]这一行 //在l到r这个区间的a * b位 if(j &gt; a)ans -= get(h[j - a], l, r) * p[a * b]; if(j &gt;= a)S[ans]++; &#125; &#125; int k; cin &gt;&gt; k; while(k--)&#123; ULL ans = 0; for(int i = 0; i &lt; a; i++)&#123; cin &gt;&gt; s; for(int j = 0; j &lt; b; j++)ans = ans * base + s[j] - '0'; &#125; if(S[ans])puts(\"1\"); else puts(\"0\"); &#125; return 0;&#125;","path":"2019/08/02/数据结构基础/矩阵-二维数组哈希/","date":"08-02","excerpt":"","tags":[{"name":"哈希","slug":"哈希","permalink":"http://zhumenger.top/tags/哈希/"}]},{"title":"装满的油箱(bfs)","text":"题目描述有N个城市（编号0、1…N-1）和M条道路，构成一张无向图。 在每个城市里边都有一个加油站，不同的加油站的单位油价不一样。 现在你需要回答不超过100个问题，在每个问题中，请计算出一架油箱容量为C的车子，从起点城市S开到终点城市E至少要花多少油钱？ 输入格式 第一行包含两个整数N和M。 第二行包含N个整数，代表N个城市的单位油价，第i个数即为第i个城市的油价pi。 接下来M行，每行包括三个整数u,v,d，表示城市u与城市v之间存在道路，且车子从u到v需要消耗的油量为d。接下来一行包含一个整数q，代表问题数量。 接下来q行，每行包含三个整数C、S、E，分别表示车子油箱容量、起点城市S、终点城市E。 输出格式 对于每个问题，输出一个整数，表示所需的最少油钱。 如果无法从起点城市开到终点城市，则输出”impossible”。 每个结果占一行。 数据范围 1≤N≤10001≤M≤100001≤pi≤1001≤d≤1001≤C≤100 输入样例： 5 510 10 20 12 130 1 90 2 81 2 11 3 112 3 72 10 0 320 1 4 输出样例： 170impossible 题解： 广搜+dp:使用二元组(city, fuel)来表示每个状态,city为城市编号,fuel为油箱中剩余的汽油量,并使用数组d[city] [fuel]储存最少花费起始状态为(S, 0),对于每个状态:1.如果fuel &lt; C,可以加1升油,扩展到新状态(city, fuel + 1), 花费在城市city增加1升油的钱,用数组d[city] [fuel + 1]维护花费的较小值;2.对于每条从city出发的边(city, next),若边权大小w不超过fuel,可以开往城市next,用数组d[next] [fuel - w]维护花费的较小值;我们不断取出队列中花费最少的状态,并用该状态不断的去更新其他的状态,利用BFS()的性质,只要到达终点的某一状态第一次被取出,即可停止BFS,输出答案,时间复杂度为O(NClogN) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N = 1010, M = 10010, INF = 0x3f3f3f3f;struct p&#123; int city; //城市 int fuel; //油量 int cost; //花费&#125;;int h[N], e[2 * M], ne[2 * M], w[2 * M], idx;//邻接表int d[N][110], a[N];bool vis[N][110];int n, m, c, st, ed; void add(int a, int b, int c)//建图&#123; e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;&#125;bool operator &lt; (const p &amp;a, const p &amp;b)//按照花费从小到大排序 &#123; //优先队列中的是从大到小排序的,重载的时候也从大到小排排序,这样便反了过来 return a.cost &gt; b.cost;&#125;int bfs()&#123; p now, next; priority_queue&lt;p&gt; q; memset(d, INF, sizeof d); memset(vis, false, sizeof vis); d[st][0] = 0; q.push(&#123;st, 0, 0&#125;);//st表示起点的城市 while(q.size())&#123; now = q.top(); q.pop(); int city = now.city; int fuel = now.fuel; int cost = now.cost; vis[city][fuel] = true;//该状态已经出现过了 if(city == ed) return cost;//如果到达终点,直接返回 //如果剩余的fuel油量小于C, 且下一个状态没有出现过,花费更少 if(fuel &lt; c &amp;&amp; !vis[city][fuel + 1] &amp;&amp; d[city][fuel + 1] &gt; d[city][fuel] + a[city])&#123; d[city][fuel + 1] = d[city][fuel] + a[city];//更新花费,加一升油的钱 //下一状态 next.city = city; next.fuel = fuel + 1; next.cost = d[city][fuel + 1]; q.push(next);//添加到队列中去 &#125; for(int i = h[city]; i != -1; i = ne[i])&#123;//遍历可以到达的所有边 int j = e[i]; //如果fuel &lt; 边权w, 且该状态没有被遍历过, 花费更少 if(fuel &gt;= w[i] &amp;&amp; !vis[j][fuel - w[i]] &amp;&amp; d[j][fuel - w[i]] &gt; d[city][fuel])&#123; d[j][fuel - w[i]] = d[city][fuel];//更新花费,并开往下一个城市 next.city = j;//下一个状态 next.fuel = fuel - w[i]; next.cost = d[j][fuel - w[i]]; q.push(next);//添加到队列中去 &#125; &#125; &#125; return -1;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof h); for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; while(m--)&#123; int a, b ,c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); add(b, a, c); &#125; int q; cin &gt;&gt; q; while(q--)&#123; cin &gt;&gt; c &gt;&gt; st &gt;&gt; ed; int ans = bfs(); if(ans == -1)cout &lt;&lt; \"impossible\" &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/08/02/搜索/装满的油箱/","date":"08-02","excerpt":"","tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"电路维修(双端队列)","text":"题目描述达达是来自异世界的魔女，她在漫无目的地四处漂流的时候，遇到了善良的少女翰翰，从而被收留在地球上。 翰翰的家里有一辆飞行车。 有一天飞行车的电路板突然出现了故障，导致无法启动。 电路板的整体结构是一个R行C列的网格（R,C≤500），如下图所示。 每个格点都是电线的接点，每个格子都包含一个电子元件。 电子元件的主要部分是一个可旋转的、连接一条对角线上的两个接点的短电缆。 在旋转之后，它就可以连接另一条对角线的两个接点。 电路板左上角的接点接入直流电源，右下角的接点接入飞行车的发动装置。 达达发现因为某些元件的方向不小心发生了改变，电路板可能处于断路的状态。 她准备通过计算，旋转最少数量的元件，使电源与发动装置通过若干条短缆相连。 不过，电路的规模实在是太大了，达达并不擅长编程，希望你能够帮她解决这个问题。 输入格式 输入文件包含多组测试数据。 第一行包含一个整数T，表示测试数据的数目。 对于每组测试数据，第一行包含正整数R和C，表示电路板的行数和列数。 之后R行，每行C个字符，字符是&quot;/&quot;和&quot;\\&quot;中的一个，表示标准件的方向。 输出格式 对于每组测试数据，在单独的一行输出一个正整数，表示所需的缩小旋转次数。 如果无论怎样都不能使得电源和发动机之间连通，输出NO SOLUTION。 数据范围 1≤R,C≤500,1≤T≤5 输入样例： 1 3 5\\/\\\\////\\\\ 输出样例： 1 题解： 广搜+双端队列运用最短路的做法,把每个坐标看成无向图中的一个节点, 若当前位于(x, y)这个节点,枚举这个节点可以到达的4个对角的坐标,连成对角线,如果该对角线和给出的标准件的线段重合,则边权值为0,如果垂直,则需要转动一次,边权值为1. 可以通过双端队列来从小到大储存权值,如果权值为0,则添加到队头,如果权值为1,则添加到队尾,每次弹出队头,运用广搜的性质,就可以求出我们想要的答案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;deque&gt;#include&lt;cstring&gt;using namespace std;const int N = 510, INF = 0x3f3f3f3f;struct p&#123; int x; int y;&#125;;char s[N][N];int d[N][N];int n, m;//节点坐标向4个方向连线的对角线的坐标int dx[] = &#123;-1, -1, 1, 1&#125;;int dy[] = &#123;-1, 1, 1, -1&#125;;//给出的标准件,所对应的的下标int ix[] = &#123;-1, -1, 0, 0&#125;;int iy[] = &#123;-1, 0, 0, -1&#125;;//与4个方向相连的对角线,\"\\\\\"表示转义字符char cs[] = \"\\\\/\\\\/\";int bfs()&#123; memset(d, INF, sizeof d); deque&lt;p&gt; q; q.push_back(&#123;0, 0&#125;); d[0][0] = 0; while(q.size())&#123; p t = q.front(); q.pop_front(); for(int i = 0; i &lt; 4; i++)&#123;//4个方向遍历 int x1 = t.x + dx[i]; int y1 = t.y + dy[i]; int x2 = t.x + ix[i]; int y2 = t.y + iy[i]; char str = cs[i]; int w = 0; if(x1 &gt;= 0 &amp;&amp; x1 &lt;= n &amp;&amp; y1 &gt;= 0 &amp;&amp; y1 &lt;= m)&#123; if(str != s[x2][y2])w = 1;//如果不重合,边权值为1 if(d[x1][y1] &gt; d[t.x][t.y] + w)&#123; //更新最小值 d[x1][y1] = d[t.x][t.y] + w; if(w)q.push_back(&#123;x1, y1&#125;);//添加到队尾 else q.push_front(&#123;x1, y1&#125;);//添加到队头 &#125; &#125; &#125; &#125; if(d[n][m] == INF) return -1; else return d[n][m];&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) cin &gt;&gt; s[i]; int t = bfs(); if(t == -1)cout &lt;&lt; \"NO SOLUTION\" &lt;&lt; endl; else cout &lt;&lt; t &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/08/02/搜索/电路维修-双端队列/","date":"08-02","excerpt":"","tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"矩阵距离(曼哈顿距离)","text":"给定一个N行M列的01矩阵A，A[i] [j] 与 A[k] [l] 之间的曼哈顿距离定义为： dist(A[i] [j],A[k] [l])=|i−k|+|j−l| 输出一个N行M列的整数矩阵B，其中： B[i] [j]=min(1 ≤ x ≤ N,1 ≤ y ≤ M, A[x] [y] = 1)dist(A[i] [j], A[x] [y]) 输入格式 第一行两个整数n,m。 接下来一个N行M列的01矩阵，数字之间没有空格。 输出格式 一个N行M列的矩阵B，相邻两个整数之间用一个空格隔开。 数据范围 1≤N,M≤1000 输入样例： 3 4000100110110 输出样例： 3 2 1 02 1 0 01 0 0 1 题解： 求最短距离, 利用广搜的性质，将所有为1的点放入到队列中去，不断更新到其他点的距离即可 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int N = 1010, INF = 0x3f3f3f3f;struct p&#123; int x, y;&#125;;char a[N][N];int d[N][N];int dx[] = &#123;0, 1, 0, -1&#125;;int dy[] = &#123;1, 0, -1, 0&#125;;int n, m;queue&lt;p&gt; q;void bfs()&#123; while(q.size())&#123; p t = q.front(); q.pop(); for(int i = 0; i &lt; 4; i++)&#123; int x = t.x + dx[i]; int y = t.y + dy[i]; if(x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; d[x][y] == INF)&#123; d[x][y] = d[t.x][t.y] + 1; q.push(&#123;x, y&#125;); &#125; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; memset(d, INF, sizeof d); for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt;m; j++)&#123; cin &gt;&gt; a[i][j]; if(a[i][j] == '1')&#123; q.push(&#123;i, j&#125;); d[i][j] = 0; &#125; &#125; bfs(); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++) cout &lt;&lt; d[i][j] &lt;&lt; ' '; cout &lt;&lt; endl; &#125; return 0; &#125;","path":"2019/07/31/搜索/矩阵距离-曼哈顿距离/","date":"07-31","excerpt":"","tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"立体推箱子(复杂迷宫问题)","text":"题目描述立体推箱子是一个风靡世界的小游戏。 游戏地图是一个N行M列的矩阵，每个位置可能是硬地（用”.”表示）、易碎地面（用”E”表示）、禁地（用”#”表示）、起点（用”X”表示）或终点（用”O”表示）。 你的任务是操作一个1×1×2的长方体。 这个长方体在地面上有两种放置形式，“立”在地面上（1×1的面接触地面）或者“躺”在地面上（1×2的面接触地面）。 在每一步操作中，可以按上下左右四个键之一。 按下按键之后，长方体向对应的方向沿着棱滚动90度。 任意时刻，长方体不能有任何部位接触禁地，并且不能立在易碎地面上。 字符”X”标识长方体的起始位置，地图上可能有一个”X”或者两个相邻的”X”。 地图上唯一的一个字符”O”标识目标位置。 求把长方体移动到目标位置（即立在”O”上）所需要的最少步数。 在移动过程中，”X”和”O”标识的位置都可以看作是硬地被利用。 输入格式 输入包含多组测试用例。 对于每个测试用例，第一行包括两个整数N和M。 接下来N行用来描述地图，每行包括M个字符，每个字符表示一块地面的具体状态。 当输入用例N=0，M=0时，表示输入终止，且该用例无需考虑。 输出格式 每个用例输出一个整数表示所需的最少步数，如果无解则输出”Impossible”。 每个结果占一行。 数据范围 3≤N,M≤500 输入样例： 7 7 ####### #..X### #..##O# #….E# #….E# #…..# #######0 0 输出样例： 10 题解： 广度优先搜索：迷宫问题的变形版,处理情况比较复杂,变化的量有长方体的坐标以及状态,我们可以用一个三元组(x, y, lie)代表一个状态： 1.lie = 0表示长方体立在(x, y)处； 2.lie = 1表示长方体横着躺着,左半部分位置在(x, y); 3.lie = 2, 表示长方体纵着躺着,上半部分位置在(x, y)。 并用d[x] [y] [lie]记录从起始状态到达每一个状态的最小步数,然后广搜就行 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;const int N = 510;struct p&#123; //状态 int x; int y; int lie;&#125;;p st, ed;//记录起点和终点的状态char a[N][N]; //地图int n, m, d[N][N][3];//记录最小步数的数组//4个方向遍历int dx[] = &#123;0, 0, 1, -1&#125;;int dy[] = &#123;1, -1, 0, 0&#125;;//状态为lie(0, 1, 2),向4个方向(左右上下)转动时,x, y坐标的变化以及lie状态的变化int next_x[3][4] = &#123;&#123;0, 0, -2, 1&#125;, &#123;0, 0, -1, 1&#125;, &#123;0, 0, -1, 2&#125;&#125;;int next_y[3][4] = &#123;&#123;-2, 1, 0, 0&#125;, &#123;-1, 2, 0, 0&#125;, &#123;-1, 1, 0, 0&#125;&#125;;int next_lie[3][4] =&#123;&#123;1, 1, 2, 2&#125;, &#123;0, 0, 1, 1&#125;, &#123;2, 2, 0, 0&#125;&#125;;//判断坐标是否合法bool hefa(int x, int y)&#123; return (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m);&#125;//处理起点和终点void parse_st_ed()&#123; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; if(a[i][j] == 'O')&#123; //记录终点的坐标 ed.x = i; ed.y = j; ed.lie = 0; a[i][j] = '.'; &#125; if(a[i][j] == 'X')&#123;//找到起点的坐标 for(int k = 0; k &lt; 4; k++)&#123; //4个方向遍历,判断长方体的状态 int x = i + dx[k]; int y = j + dy[k]; if(hefa(x, y) &amp;&amp; a[x][y] == 'X')&#123; st.x = min(i, x), st.y = min(j, y); st.lie = k &lt; 2 ? 1 : 2; a[i][j] = a[x][y] = '.'; break; &#125; &#125; if(a[i][j] == 'X')st.x = i, st.y = j, st.lie = 0;//如果周围没有'X',说明长方体是立着的,记录当前的起点坐标, &#125; &#125; &#125;&#125;//判断滚动时的状态是否合法bool hefa_2(p next)&#123; if(!hefa(next.x, next.y))return false;//坐标合法 if(a[next.x][next.y] == '#')return false;//判断是否能走 //判断长方体3个状态时是否合法 if(next.lie == 0 &amp;&amp; a[next.x][next.y] != '.')return false; if(next.lie == 1 &amp;&amp; a[next.x][next.y + 1] == '#')return false; if(next.lie == 2 &amp;&amp; a[next.x + 1][next.y] == '#')return false; return true;&#125;int bfs()//广搜&#123; queue&lt;p &gt; q; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) for(int k = 0; k &lt; 3; k++) d[i][j][k] = -1; //初始化 d[st.x][st.y][st.lie] = 0; q.push(st); while(q.size())&#123; p t = q.front(); q.pop(); if(t.x == ed.x &amp;&amp; t.y == ed.y &amp;&amp; t.lie == ed.lie)&#123;//判断是否走到了终点 return d[t.x][t.y][t.lie]; break; &#125; for(int i = 0; i &lt; 4; i++)&#123;//4个方向翻滚 p next; next.x = t.x + next_x[t.lie][i]; next.y = t.y + next_y[t.lie][i]; next.lie = next_lie[t.lie][i]; if(!hefa_2(next))continue; if(d[next.x][next.y][next.lie] == -1)&#123;//如果没有访问过 d[next.x][next.y][next.lie] = d[t.x][t.y][t.lie] + 1; q.push(next); &#125; &#125; &#125; return -1;&#125;int main()&#123; while(cin &gt;&gt; n &gt;&gt; m)&#123; if(n == 0 &amp;&amp; m == 0)break; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) cin &gt;&gt; a[i][j]; parse_st_ed(); int ans = bfs(); if(ans == -1)cout &lt;&lt; \"Impossible\" &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/07/31/搜索/立体推箱子-复杂迷宫问题/","date":"07-31","excerpt":"","tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"送礼物(双向搜索)","text":"题目描述达达帮翰翰给女生送礼物，翰翰一共准备了N个礼物，其中第i个礼物的重量是G[i]。 达达的力气很大，他一次可以搬动重量之和不超过W的任意多个物品。 达达希望一次搬掉尽量重的一些物品，请你告诉达达在他的力气范围内一次性能搬动的最大重量是多少。 输入格式 第一行两个整数，分别代表W和N。 以后N行，每行一个正整数表示G[i]。 输出格式 仅一个整数，表示达达在他的力气范围内一次性能搬动的最大重量。 数据范围 1≤N≤45,1≤W,G[i]≤2^31−1 输入样例： 20 57 54 181 输出样例： 19 题解: 双向搜索:如果直接进行指数型搜索的话,复杂度是O(2 ^ N),对于这道题2^45复杂度过大,这时我们就可以利用双向搜索的思想,把礼物分半 首先,我们从前一半礼物选出若干个,可能达到的0~w的之间的所有重量值，存放到一个数组里,排序并去重然后,我们进行第二次搜索,尝试从后一半礼物中选择一些,对于每一个选出的重量t,在第一部分得到的数组中进行二分查找 &lt;= w - t的数值最大的的那个,用俩者的和更新答案即可如何优化：1.优化搜索顺序:把礼物按照从大到小的顺序排序后在分半,搜索2.选取恰当的这班划分点:一般取k = n / 2 + 2的位置进行二分的效率会高一些 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N = 50;typedef long long ll;bool vis[N];int n, m, a[N], k;int w[1 &lt;&lt; 24], cnt;int ans;//u表示前u种礼物的选取,s表示前u种礼物选取的总重量void dfs_1(int u, int s)&#123; if(u == k)&#123; w[cnt ++ ] = s; return ; &#125; if((ll)s + a[u] &lt;= m)dfs_1(u + 1, s + a[u]); dfs_1(u + 1, s);&#125;void dfs_2(int u, int s)&#123; if(u == n)&#123; //二分查找,一下俩种方法都行 //int l = 0, r = cnt - 1; //while(l &lt; r)&#123; // int mid = l + r + 1 &gt;&gt; 1; // if((ll)s + w[mid] &lt;= m)l = mid; /// else r = mid - 1; // &#125; int r = upper_bound(w, w + cnt, m - s) - w; if((ll)w[r - 1] + s &lt;= m)ans = max(ans, w[r - 1] + s);//更新答案 return ; &#125; if((ll)s + a[u] &lt;= m)dfs_2(u + 1, s + a[u]); dfs_2(u + 1, s);&#125;int main()&#123; cin &gt;&gt; m &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; sort(a, a + n); reverse(a, a + n); k = n / 2 + 2; dfs_1(0, 0); sort(w, w + cnt); cnt = unique(w, w + cnt) - w;//返回去重之后元素的个数 dfs_2(k, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","path":"2019/07/31/搜索/送礼物-双向搜索/","date":"07-31","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"加成序列(迭代加深)","text":"题目描述满足如下条件的序列X（序列中元素被标号为1、2、3…m）被称为“加成序列”： 1、X[1]=1 2、X[m]=n 3、X[1]&lt;X[2]&lt;…&lt;X[m-1]&lt;X[m] 4、对于每个 kk（2≤k≤m2≤k≤m）都存在两个整数 ii 和 jj （1≤i,j≤k−11≤i,j≤k−1，ii 和 jj 可相等），使得X[k]=X[i]+X[j]。 你的任务是：给定一个整数n，找出符合上述条件的长度m最小的“加成序列”。 如果有多个满足要求的答案，只需要找出任意一个可行解。 输入格式输入包含多组测试用例。 每组测试用例占据一行，包含一个整数n。 当输入为单行的0时，表示输入结束。 输出格式对于每个测试用例，输出一个满足需求的整数序列，数字之间用空格隔开。 每个输出占一行。 数据范围1≤n≤100 输入样例： 5 71215770 输出样例： 1 2 4 51 2 4 6 71 2 4 8 121 2 4 5 10 151 2 4 8 9 17 34 68 77 迭代加深搜索:如果我们想要的答案在一个比较浅的节点上,而树的深度比较深，那么我们进行深度优先搜索的时候便会浪费大量的时间此时，我们可以限制搜索的深度,如果在当前深度找不到答案,就把深度的限制增加,重新搜索，直到找到答案为止,这道题便是这样的一个思路 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 110;int a[N];bool vis[N];int n, k;bool dfs(int u, int k)&#123; if(u == k)return a[u - 1] == n; //暴力枚举 for(int i = u - 1; i &gt;= 0; i--)&#123; for(int j = i; j &gt;= 0; j--)&#123; int s = a[i] + a[j]; if(vis[s] || s &gt; n || s &lt;= a[u - 1])continue; a[u] = s; if(dfs(u + 1, k))return true; &#125; &#125; return false;&#125;int main()&#123; a[0] = 1; while(cin &gt;&gt; n &amp;&amp; n)&#123; int k = 1; //如果不成功，增加搜索深度的限制 while(!dfs(1, k))&#123; memset(vis, false, sizeof vis); k++; &#125; for(int i = 0; i &lt; k; i++)cout &lt;&lt; a[i] &lt;&lt; ' '; cout &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/07/30/搜索/加成序列/","date":"07-30","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"木棒(学会剪枝)","text":"题目描述乔治拿来一组等长的木棒，将它们随机地砍断，使得每一节木棍的长度都不超过50个长度单位。 然后他又想把这些木棍恢复到为裁截前的状态，但忘记了初始时有多少木棒以及木棒的初始长度。 请你设计一个程序，帮助乔治计算木棒的可能最小长度。 每一节木棍的长度都用大于零的整数表示。 注意: 数据中可能包含长度大于50的木棒，请在处理时忽略这些木棒。 输入格式输入包含多组数据，每组数据包括两行。 第一行是一个不超过64的整数，表示砍断之后共有多少节木棍。 第二行是截断以后，所得到的各节木棍的长度。 在最后一组数据之后，是一个零。 输出格式为每组数据，分别输出原始木棒的可能最小长度，每组数据占一行。 输入样例： 9 5 2 1 5 2 1 5 2 14 1 2 3 40 输出样例： 6 5 题解： 从小到大枚举len, len应该是木棍长度总和sum的约数,并且原始木棍的根数ans = sum / len 搜索的3个状态dfs(int stick, int cnt, int last),stick表示当前正在拼接的原始木棍(前stick - 1个原始木棍已经拼接完成),cnt 表示当前正在拼接的原始木棍的长度,last表示已经拼接到当前原始木棍中的上一个小木棍,暴力枚举就行 如何剪枝，优化时间:一.优化搜索顺序把木棍的长度从大到小排序，优先尝试较长的木棍,减少尝试的次数二.排除等效冗余的情况(1).保证加入到原始木棍中的小木棍的长度是递减的，也就是深搜的时候从当前木棍的下一个木棍开始(2).对于当前的原始木棍，记录当前尝试拼接的小木棍，如果搜索失败,回溯时不再搜索跟其长度相等的木棍(必定也会失败)(3).如果第一次尝试拼入木棍就失败的话,那么这个分治必然也是失败的,因为在拼入这些木棍前,面对的原始木棍都是还没有拼接的,他们都是等效的. 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;const int N = 100;bool vis[N];int n, a[N], len, ans;bool dfs(int stick, int cnt, int last)&#123; if(stick &gt; ans)return true;//全部拼接完毕 if(cnt == len) return dfs(stick + 1, 0, 0);////第stick个原始木棍拼接完毕，拼接下一个 int fail = 0;//用来记录最近一次拼接并且搜索失败的木棍 for(int i = last; i &lt; n; i++)&#123; //没有被访问过，并且可以加上当前小木棍，并且长度和上一次失败的长度不一样 if(!vis[i] &amp;&amp; cnt + a[i] &lt;= len &amp;&amp; fail != a[i])&#123; vis[i] = true;//被访问过 if(dfs(stick, cnt + a[i], i + 1))return true;//如果搜索成功 //搜索失败 vis[i] = 0;//不选这个点 fail = a[i];//记录失败的木棍的长度 ////如果cnt为0,或者相加正好是len,但是失败了,那么一定是失败了 if(cnt == 0 || cnt + a[i] == len)return false; &#125; &#125; return false;&#125;int main()&#123; while(cin &gt;&gt; n &amp;&amp; n)&#123; int sum = 0, val = 0; int k = 0, x; for(int i = 0; i &lt; n; i++)&#123; scanf(\"%d\", &amp;x); if(x &lt;= 50)&#123; a[k++] = x; sum += x;//记录总长度 val = max(val, x); &#125; &#125; n = k; //从大到小排序 sort(a, a + n); reverse(a, a + n); for(len = val; len &lt;= sum; len++)&#123; if(sum % len == 0)&#123; ans = sum / len; memset(vis, false, sizeof vis); if(dfs(1, 0, 0))break; &#125; &#125; printf(\"%d\\n\", len); &#125; return 0;&#125;","path":"2019/07/30/搜索/木棒/","date":"07-30","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"数独(dfs)","text":"题目描述数独是一种传统益智游戏，你需要把一个9 × 9的数独补充完整，使得图中每行、每列、每个3 × 3的九宫格内数字1~9均恰好出现一次。 请编写一个程序填写数独。 输入格式输入包含多组测试用例。 每个测试用例占一行，包含81个字符，代表数独的81个格内数据（顺序总体由上到下，同行由左到右）。 每个字符都是一个数字（1-9）或一个”.”（表示尚未填充）。 您可以假设输入中的每个谜题都只有一个解决方案。 文件结尾处为包含单词“end”的单行，表示输入结束。 输出格式每个测试用例，输出一行数据，代表填充完全后的数独。 输入样例： .2738..1..1…6735…….293.5692.8………..6.1745.364…….9518…7..8..6534.……52..8.4……3…9…5.1…6..2..7……..3…..6…1……….7.4…….3.end 输出样例： 527389416819426735436751829375692184194538267268174593643217958951843672782965341416837529982465371735129468571298643293746185864351297647913852359682714128574936 *题解: * 1.使用二进制初始化行、列和九宫格中能够填入的数有哪些；使用一个数组记录每个数的二进制下都多少个1；2.再使用一个数组记录二进制下1表示的是选的哪个数，使用lowbit运算可以返回能够填入九宫格中的数是哪个3.初始化完毕后，读入字符串，并使用位运算处理出行、列和九宫格中已经填入的数有哪些4.考虑时间的优化，我们每次从九宫格中可以填入的数最少的那个开始，这样我们的选择填入的数就会比较少，减少了时间的复杂度 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;using namespace std;const int N = 9;int r[N], c[N], cell[3][3];//使用位运算来表示行，列和九宫格已经出现了的数char str[100];int ones[1 &lt;&lt; N], map[1 &lt;&lt; N];//ones表示i的二进制中有多少个1inline int lowbit(int x)//lowbit运算，返回最低位的1以及后面的0&#123; return x &amp; (~x + 1);&#125;inline int get(int x, int y)//获得x行y列还有哪些数可以选&#123; return r[x] &amp; c[y] &amp; cell[x / 3][y / 3];//位运算相与&#125;void init()&#123; //预处理，将行，列，九宫格都初始化为二进制111111111，表示1~9都可以填 for(int i = 0; i &lt; 9; i++)r[i] = c[i] = (1 &lt;&lt; N) - 1; for(int i = 0; i &lt; 3; i ++) for(int j = 0; j &lt; 3; j++) cell[i][j] = (1 &lt;&lt; N ) -1; &#125;bool dfs(int cnt)&#123; if(cnt == 0)return true; //找出可选方案数最少的格子 int minv = 10; int x, y; for(int i = 0; i &lt; N; i++)&#123; for(int j = 0; j &lt; N; j++)&#123; if(str[i * 9 + j] == '.')&#123; int t = ones[get(i, j)]; if(t &lt; minv)&#123; minv = t; x = i, y = j; &#125; &#125; &#125; &#125; for(int i = get(x, y); i; i -= lowbit(i))&#123; int t = map[lowbit(i)]; r[x] -= 1 &lt;&lt; t; c[y] -= 1 &lt;&lt; t; cell[x / 3][y / 3] -= 1 &lt;&lt; t; str[x * 9 + y] = '1' + t; if(dfs(cnt - 1))return true; r[x] += 1 &lt;&lt; t; c[y] += 1 &lt;&lt; t; cell[x / 3][y / 3] += 1 &lt;&lt; t; str[x * 9 + y] = '.'; &#125; return false;&#125;int main()&#123; for(int i = 0; i &lt; N; i++)map[1 &lt;&lt; i] = i;//map映射1左移i位对应的是哪个数可以填在九宫格里 //枚举所有的状态，求出i的二进制中有多少个1 for(int i = 0; i &lt; 1 &lt;&lt; N ; i++)&#123; int s = 0; for(int j = i; j != 0; j -=lowbit(j))s++; ones[i] = s;//求出i的二进制中有多少个1 &#125; while(cin &gt;&gt; str &amp;&amp; str[0] != 'e')&#123; init();//初始化 int cnt = 0; for(int i = 0, k = 0; i &lt; 9; i++)&#123; for(int j = 0; j &lt; 9; j++, k++)&#123; if(str[k] != '.')&#123;//如果这个数已经填在了九宫格里，则需要在行，列和九空格中去掉该数 int t = str[k] - '1'; //让该位的二进制为0即可 r[i] -= 1 &lt;&lt; t; c[j] -= 1 &lt;&lt; t; cell[i / 3][j / 3] -= 1 &lt;&lt; t; &#125; else cnt++; &#125; &#125; dfs(cnt); cout &lt;&lt; str &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/07/29/搜索/数独/","date":"07-29","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"},{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/tags/搜索/"}]},{"title":"可达性统计","text":"题目描述 给定一张N个点M条边的有向无环图，分别统计从每个点出发能够到达的点的数量。 输入格式 第一行两个整数N,M，接下来M行每行两个整数x,y，表示从x到y的一条有向边。 输出格式 输出共N行，表示每个点能够到达的点的数量。 数据范围 1≤N,M≤30000 输入样例： 10 103 82 32 55 95 92 33 94 82 104 9 输出样例： 1 63 32 11 11 1 题解： x点能到的点的个数等于该点加上它的所有子节点可以达到的点个数，我们可以先拓扑排序，然后从后往前遍历,用位运算求出所有点能够达到的点的数量，位运算我们使用bitset来做： C++ bitset 用法1.C++的 bitset 在 bitset 头文件中，它是一种类似数组的结构，它的每一个元素只能是０或１，每个元素仅用１bit空间。可以用下标的形式对其进行访问 1234567891011bitset&lt;8&gt; foo (&quot;10011011&quot;);cout &lt;&lt; foo.count() &lt;&lt; endl; //5 （count函数用来求bitset中1的位数，foo中共有５个１cout &lt;&lt; foo.size() &lt;&lt; endl; //8 （size函数用来求bitset的大小，一共有８位cout &lt;&lt; foo.test(0) &lt;&lt; endl; //true （test函数用来查下标处的元素是０还是１，并返回false或true，此处foo[0]为１，返回truecout &lt;&lt; foo.test(2) &lt;&lt; endl; //false （同理，foo[2]为０，返回falsecout &lt;&lt; foo.any() &lt;&lt; endl; //true （any函数检查bitset中是否有１cout &lt;&lt; foo.none() &lt;&lt; endl; //false （none函数检查bitset中是否没有１cout &lt;&lt; foo.all() &lt;&lt; endl; //false （all函数检查bitset中是全部为１ 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;bitset&gt;#include&lt;queue&gt;using namespace std;const int N = 3e4 + 10;int n, m;int h[N], e[N], ne[N], idx;int d[N], seq[N];bitset&lt;N&gt; f[N];//bitsetvoid add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;void topsort()&#123; queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i++) if(!d[i])q.push(i); int k = 0; while(q.size())&#123; int t = q.front(); q.pop(); seq[k++] = t; for(int i = h[t]; i != -1; i = ne[i])&#123; int u = e[i]; d[u]--; if(!d[u])q.push(u); &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof h); for(int i = 0; i &lt; m; i++)&#123; int a, b; cin &gt;&gt;a &gt;&gt; b; add(a, b); d[b]++; &#125; topsort(); for(int i = n - 1; i &gt;= 0; i--)&#123; int u = seq[i]; f[u][u] = 1; for(int j = h[u]; j != -1; j = ne[j])&#123; f[u] |= f[e[j]]; &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; cout &lt;&lt; f[i].count() &lt;&lt; endl;//求f[i]中1的个数 &#125;&#125;","path":"2019/07/28/搜索/可达性统计/","date":"07-28","excerpt":"","tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"生日礼物","text":"生日礼物题目描述 翰翰18岁生日的时候，达达给她看了一个神奇的序列 A1,A2,…,ANA1,A2,…,AN。 她被允许从中选择不超过 M 个连续的部分作为自己的生日礼物。 翰翰想要知道选择元素之和的最大值。 你能帮助她吗？ 输入格式 第一行包含两个整数N,M。 第二行包含N个整数A1A1~ANAN。 输出格式 输出一个整数，表示答案。 数据范围 1≤N,M≤105|Ai|≤104 输入样例： 5 22 -3 2 -1 2 输出样例： 5 题解： 1.将整个序列分为正负交替的序: 如果数x与前面的符号相同，就加起来，否则新开一个空间存储当前的数x2.统计正数的个数cnt，如果cnt &lt;= m,把所有正数加起来，输出便是我们的答案3.如果cnt &gt; m, 必须减少正数的个数，有俩种做法 1.直接删去最小的正数,2.将俩个正数合并为1个连续子序列，中间必有一个负数，还需要加上负数的值 4.删去正数,或者加上负数，都可以看成减去他们的绝对值，可以用堆来存储他们 的绝对值，以及他们的下标5.如果删除的是正数，正数的俩边都是负数，需要将俩边的负数合并，重新放到堆中。 并删除左右节点，6.如果删除的是负数，负数的俩边都是正数，需要将俩边的正数合并，重新放到堆中。 并删除左右节点， 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#include&lt;queue&gt;#include&lt;vector&gt;const int N = 1e5 + 10;int n, m;int a[N], l[N], r[N];bool vis[N];typedef pair&lt;int, int&gt; p;void remove(int x)&#123; l[r[x]] = l[x]; r[l[x]] = r[x]; vis[x] = true;&#125;int main()&#123; int k = 0; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)&#123; int x; cin &gt;&gt; x; if(x == 0)continue; if(a[k] * x &gt; 0)a[k] += x; else a[++k] = x; &#125; int cnt = 0, res = 0; priority_queue&lt;p, vector&lt;p&gt;, greater&lt;p&gt; &gt; q; for(int i = 1; i &lt;= k; i++)&#123; if(a[i] &gt; 0)&#123; cnt++; res += a[i]; &#125; l[i] = i - 1; r[i] = i + 1; q.push(&#123;abs(a[i]), i&#125;); &#125; while(cnt &gt; m)&#123; while(vis[q.top().second])q.pop(); p t = q.top(); q.pop(); int v = t.first, point = t.second; if(l[point] != 0 &amp;&amp; r[point] != k + 1 || a[point] &gt; 0)&#123; res -= v; cnt--; int left = l[point], right = r[point]; a[point] += a[left] + a[right]; q.push(&#123;abs(a[point]), point&#125;); remove(left); remove(right); &#125; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;","path":"2019/07/27/数据结构基础/生日礼物/","date":"07-27","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"二叉堆","slug":"二叉堆","permalink":"http://zhumenger.top/tags/二叉堆/"},{"name":"链表","slug":"链表","permalink":"http://zhumenger.top/tags/链表/"}]},{"title":"黑盒子(堆)","text":"题目描述 黑盒子代表一个原始的数据库。 它可以用来储存整数数组，并且它拥有一个特殊变量i。 在最开始，黑盒子是空的，并且i=0。 现在对黑盒子进行一系列的操作处理，操作包括以下两种： 1、ADD(x)：表示将x加入到黑盒子中。2、GET：使i增加1，输出黑盒子中第i小的数值（即将所有数按升序排序后的第i个数）。 1、A(1),A(2),…,A(M)：这个序列由加入到黑盒子内的所有元素按加入顺序排列后得到， 2、u(1),u(2),…,u(N): 这个序列的第i项表示的是第i次GET操作时，盒子内元素的数量。 现在请你根据给出的序列A和u求出操作过程中输出的所有数值。 输入格式 输入包括三行。 第一行包含两个整数M和N，表示A序列和u序列的长度。 第二行包含M个整数，表示A序列的每一个元素。 第三行包含N个整数，表示u序列的每一个元素。 同行每个数之间用空格隔开。 输出格式 输出操作过程中所有GET操作输出的数值。 每个数值占一行。 数据范围 |A(i)|&lt;=2∗1091≤N≤M≤30000,对于所有p（1≤p≤N）, p≤u(p)≤M成立 输入样例： 7 43 1 -4 2 8 -1000 21 2 6 6 输出样例： 3 31 2 题解： 输出序列中第i小的数，我们可以用堆来做： 1.首先定义俩个堆，一个大根堆，一个小根堆，大根堆用来存储前x - 1小的数，小根堆用来存剩下的数 2.俩个堆满足：大根堆中的最大值一定是小于小根堆中的最小值的，这样我们输出第x小的数时，直接输出小根堆的堆顶即可 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int N = 30010;int a[N];int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; priority_queue&lt;int&gt; q1;//大根堆,维护前x - 1个最小值， priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q2;//小根堆，堆顶是第x个最小值 int k = 1; for(int i = 1; i &lt;= m; i++)&#123; int x; cin &gt;&gt; x; while(k &lt;= x)&#123; //如果盒子内的元素个数小于get时的元素个数时 q2.push(a[k]); //大根堆的最大值一定是小于小根堆中的最小值，如果不是，则交换 //这样可以用大根堆维护前x - 1个最小值 if(!q1.empty() &amp;&amp; q1.top() &gt; q2.top())&#123; int u = q1.top(); q1.pop(); q2.push(u); int t = q2.top(); q2.pop(); q1.push(t); &#125; k++; &#125; cout &lt;&lt; q2.top() &lt;&lt; endl; q1.push(q2.top()); q2.pop(); &#125; return 0;&#125;","path":"2019/07/27/数据结构基础/黑盒子-堆/","date":"07-27","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"堆","slug":"堆","permalink":"http://zhumenger.top/tags/堆/"}]},{"title":"奶牛矩阵（二维KMP）","text":"题目描述 每天早上，农夫约翰的奶牛们被挤奶的时候，都会站成一个R行C列的方阵。 现在在每个奶牛的身上标注表示其品种的大写字母，则所有奶牛共同构成了一个R行C列的字符矩阵。 现在给定由所有奶牛构成的矩阵，求它的最小覆盖子矩阵的面积是多少。 如果一个子矩阵无限复制扩张之后得到的矩阵能包含原来的矩阵，则称该子矩阵为覆盖子矩阵。 输入格式 第1行：输入两个用空格隔开的整数，R和C。 第2..R+1行：描绘由奶牛构成的R行C列的矩阵，每行C个字符，字符之间没有空格。 输出格式 输出最小覆盖子矩阵的面积。（每个字符的面积为1） 数据范围 1≤R≤10000,1≤C≤75 输入样例： 2 5ABABAABABA 输出样例： 2 提示 样例中给出的矩阵的最小覆盖子矩阵为AB，面积为2。 题解：KMP中Next数组的应用，如果n是n - Next[n]的倍数，那么n - Next[n]便是该字符串的循环节 1.可以把每一行看成一个字符，求出行的Next数组,并求出循环节 2.把每一列看做一个字符，求出列的Next数组，并求出循环节 3.俩个循环节的乘积便是该矩阵循环节的面积的大小 代码如下： 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 10010, M = 80;int Next[N];char s1[N][M], s2[M][N];int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; s1[i]; for(int i = 1; i &lt;= n; i++) for(int j = 0; j &lt; m; j++) s2[j + 1][i - 1] = s1[i][j];//将数组翻转，用来求列的Next数组 for(int i = 2, j = 0; i &lt;= n; i++)&#123;//求出行的Next数组 while(j &amp;&amp; strcmp(s1[i], s1[j + 1]))j = Next[j]; if(!strcmp(s1[i], s1[j + 1]))j++; Next[i] = j; &#125; int a = n - Next[n]; Next[1] = 0; for(int i = 2, j = 0; i &lt;= m; i++)&#123;//求出列的Next数组 while(j &amp;&amp; strcmp(s2[i], s2[j + 1]))j = Next[j]; if(!strcmp(s2[i], s2[j + 1]))j++; Next[i] = j; &#125; int b = m - Next[m]; cout &lt;&lt; a * b &lt;&lt; endl; return 0;&#125;","path":"2019/07/27/数据结构基础/奶牛矩阵（二维KMP）/","date":"07-27","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"kmp","slug":"kmp","permalink":"http://zhumenger.top/tags/kmp/"}]},{"title":"树的最小表示","text":"树的最小表示题目描述 给你两个字符串，字符串由01组成，0表示向远离起点并且没有走过的一条路走去，1表示原路返回 请你求出这俩个字符串是否是一个线路图 输入格式 第一行输入一个正整数n，代表测试用例数量。 每个测试用例由两行组成，每行输入一个由字符“0”和“1”构成的字符串，长度最多为3000， 两个字符串都描述了一种线路图的探索路线。 输出格式 对于每个测试用例，如果两个字符串描述的线路图可以视为同一个线路图，则输出same。 否则，输出different。 每行输出一个结果。 输入样例： 2 0010011101001011010001101100101101001011001001110011000111010101 输出样例： samedifferent 题解： 树的最小表示，将所有子节点的dfs序从小到大排序，并连接起来，比较他们的最小表示是否相同即可 代码如下： 123456789101112131415161718192021222324252627282930313233// 树的最小表示可以递归实现，求出所有子树的dfs序，然后从小到大排序拼接起来#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;string dfs(string seq, int &amp;u)//防止内存超限&#123; vector&lt;string &gt; seqs; u++; while(seq[u] == '0')seqs.push_back(dfs(seq, u)); u++; sort(seqs.begin(), seqs.end()); string s= \"0\"; for( auto res : seqs)s += res; s += \"1\"; return s;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; string a, b; cin &gt;&gt; a &gt;&gt; b; a = '0' + a + '1'; b = '0' + b + '1'; int ua = 0, ub = 0; if(dfs(a, ua) == dfs(b, ub))puts(\"same\"); else puts(\"different\"); &#125; return 0;&#125;","path":"2019/07/27/数据结构基础/树的最小表示/","date":"07-27","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"树的最小表示","slug":"树的最小表示","permalink":"http://zhumenger.top/tags/树的最小表示/"}]},{"title":"城市游戏","text":"题目描述 有一天，小猫rainbow和freda来到了湘西张家界的天门山玉蟾宫，玉蟾宫宫主蓝兔盛情地款待了它们，并赐予它们一片土地。 这片土地被分成N*M个格子，每个格子里写着’R’或者’F’，R代表这块土地被赐予了rainbow，F代表这块土地被赐予了freda。 现在freda要在这里卖萌。。。它要找一块矩形土地，要求这片土地都标着’F’并且面积最大。 但是rainbow和freda的OI水平都弱爆了，找不出这块土地，而蓝兔也想看freda卖萌（她显然是不会编程的……），所以它们决定，如果你找到的土地面积为S，它们将给你3*S两银子。 输入格式 第一行包括两个整数N,M，表示矩形土地有N行M列。 接下来N行，每行M个用空格隔开的字符’F’或’R’，描述了矩形土地。 每行末尾没有多余空格。 输出格式 输出一个整数，表示你能得到多少银子，即(3*最大’F’矩形土地面积)的值。 数据范围 1≤N,M≤1000 输入样例： 5 6R F F F F FF F F F F FR R R F F FF F F F F FF F F F F F 输出样例： 45 题解： 二维数组单调栈问题，这个可以参考Acwing131.直方图中最大的矩形，俩个题的解题思路大致一样，只不过这里需要转化为Acwing131题的形式： 1.首先预处理出每一列连续的F的个数 2.枚举每一行，表示以该行为底，以H(i, j)为高的矩阵可以求得的面积最大值 时间复杂度为O(n * m) 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int h[N][N], l[N], r[N], q[N], t;char a[N][N];int n, m;void get(int h[], int l[])&#123; int t = 0; for(int i = 1; i &lt;= m; i++)&#123; while(t &gt; 0 &amp;&amp; h[q[t]] &gt;= h[i])t--; l[i] = q[t] + 1; q[++t] = i; &#125;&#125;int work(int h[])&#123; get(h, l); reverse(h + 1, h + 1 + m); get(h, r); reverse(h + 1, h + 1 + m); int res = 0; for(int i = 1; i &lt;= m; i++)&#123; res = max(res, h[i] * (m + 1 - r[m + 1 - i] - l[i] + 1)); &#125; return res;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; cin &gt;&gt; a[i][j]; if(a[i][j] == 'F') h[i][j] = 1 + h[i - 1][j]; &#125; &#125; int ans = 0; for(int i = 1; i &lt;= n; i++) ans = max(ans, work(h[i])); cout &lt;&lt; ans * 3 &lt;&lt; endl;&#125;","path":"2019/07/27/数据结构基础/城市游戏(二维单调栈)/","date":"07-27","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"栈","slug":"栈","permalink":"http://zhumenger.top/tags/栈/"}]},{"title":"括号配对问题","text":"一.括号配对问题问题描述 现在，有一行括号序列，请你检查这行括号是否配对。 输入格式 第一行输入一个数N（0&lt;N&lt;=100）,表示有N组测试数据。后面的N行输入多组输入数据 每组输入数据都是一个字符串S(S的长度小于10000，且S不是空串）， 测试数据组数少于5组。数据保证S中只含有”[“, “]”, “(“, “)” 四种字符 输出格式 每组输入数据的输出占一行，如果该字符串中所含的括号是配对的，则输出Yes,如果不配对则输出No 输入样例 3 [(])(])([[] ()]) 输出样例 NoNoYes 题解： 栈的应用，如果栈顶与当前的元素匹配，则弹出栈，否则就入栈，最后看看栈中的元素是否为空即可 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e5 + 10;char st[N];int t;string s;int main()&#123; int n; cin &gt;&gt; n; while(n--)&#123; t = 0; cin &gt;&gt; s; int len = s.size(); for(int i = 0; i &lt; len; i++)&#123; if(t &gt; 0 &amp;&amp; s[i] == ')' &amp;&amp; st[t] == '(')t--; else if(t &gt; 0 &amp;&amp; s[i] == '&#125;' &amp;&amp; st[t] == '&#123;')t--; else if(t &gt; 0 &amp;&amp; s[i] == ']' &amp;&amp; st[t] == '[')t--; else st[++t] = s[i]; &#125; if(t &gt; 0)cout &lt;&lt; \"No\" &lt;&lt; endl; else cout &lt;&lt; \"Yes\" &lt;&lt; endl; &#125; return 0;&#125; 二.括号最长匹配长度题目描述 达达是一名漫画家，她有一个奇特的爱好，就是在纸上画括号。 这一天，刚刚起床的达达画了一排括号序列，其中包含小括号( )、中括号[ ]和大括号{ }，总长度为N。 这排随意绘制的括号序列显得杂乱无章，于是达达定义了什么样的括号序列是美观的： (1) 空的括号序列是美观的； (2) 若括号序列A是美观的，则括号序列 (A)、[A]、{A} 也是美观的； (3) 若括号序列A、B都是美观的，则括号序列AB也是美观的。 例如 [(){}]() 是美观的括号序列，而)({)[}]( 则不是。 现在达达想在她绘制的括号序列中，找出其中连续的一段，满足这段子序列是美观的，并且长度尽量大。 你能帮帮她吗？ 输入格式 输入一行由括号组成的字符串。 输出格式 输出一个整数，表示最长的美观的子段的长度。 数据范围 字符串长度不超过100000。 输入样例：1(&#123;(&#123;((&#123;()&#125;&#125;)&#125;&#123;())&#125;)&#125;)[)&#123;&#123;&#123;([)()((()]]&#125;])[&#123;)]&#125;&#123;[&#125;&#123;) 输出样例： 4 题解： 栈的应用：如果栈顶的与当前的元素能匹配，则出栈，并记录当前能匹配的最长长度，如果不能匹配，则出栈，重新记录长度，找到最大值即可 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e5 + 10;char s[N];stack&lt;int&gt; st;int main()&#123; cin &gt;&gt; s; int ans = 0; int len =strlen(s); for(int i = 0; i &lt; len; i++)&#123; if(s[i] == ')' &amp;&amp; st.size() &amp;&amp; s[st.top()] == '(')st.pop(); else if(s[i] == ']' &amp;&amp; st.size() &amp;&amp; s[st.top()] == '[')st.pop(); else if(s[i] == '&#125;' &amp;&amp; st.size() &amp;&amp; s[st.top()] == '&#123;')st.pop(); else st.push(i); if(st.size())ans = max(ans, i - st.top()); else ans = max(ans, i + 1); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125;","path":"2019/07/27/数据结构基础/括号配对问题/","date":"07-27","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"栈","slug":"栈","permalink":"http://zhumenger.top/tags/栈/"}]},{"title":"表达式计算","text":"表达式计算题目描述 给出一个表达式,其中运算符仅包含+,-,*,/,^（加 减 乘 整除 乘方）要求求出表达式的最终值。 数据可能会出现括号情况，还有可能出现多余括号情况。 数据保证不会出现大于或等于231231的答案。 数据可能会出现负数情况。 输入格式 输入仅一行，即为表达式。 输出格式 输出仅一行，既为表达式算出的结果。 输入样例： (2+2)^(1+1) 输出样例： 16 题解： 栈的应用：用俩个栈分别存数字和运算符 1.因为有多余括号的情况，所以所限要在字符串前加上字符串长度大小的‘（’进行预处理 2.如果当前字符为数字，则直接存进nums栈中 3.如果当前字符为加或减，首先判断减是否为负号，如果不是，其他运算符的优先级都是大于等于加或减的，所以就可以把括号中所有的元素进行一次操作，直到遇到’(‘为止 4.如果当前字符为乘或除，加、减的优先级都是低于乘除的，所以不能进运算，能进行运算的是乘除和乘方 5.当前运算符为乘方，只有栈顶为乘方才能进行运算 6.如果当前字符为‘(’,直接添加到栈中 7.如果当前元素为’)’，则将括号中所有的元素进行运算，并弹出’(‘ 8.最后输出栈顶元素即可 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;stack&lt;int&gt; nums;stack&lt;char&gt; ops;int qmi(int a, int k)&#123; int res = 1; while (k -- ) res *= a; return res;&#125;void cal()&#123; int a = nums.top(); nums.pop(); int b = nums.top(); nums.pop(); char c = ops.top(); ops.pop(); int d; if (c == '+') d = b + a; else if (c == '-') d = b - a; else if (c == '*') d = b * a; else if (c == '/') d = b / a; else d = qmi(b, a); nums.push(d);&#125;int main()&#123; string str; cin &gt;&gt; str; string left; for (int i = 0; i &lt; str.size(); i ++ ) left += '('; str = left + str + ')'; for (int i = 0; i &lt; str.size(); i ++ ) &#123; if (str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9')//如果是数字 &#123; int j = i, t = 0; while (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')//可能有多位 &#123; t = t * 10 + str[j] - '0'; j ++ ; &#125; nums.push(t); i = j - 1; &#125; else//如果是运算符 &#123; char c = str[i]; if (c == '(') ops.push(c); else if (c == '+' || c == '-') &#123; if (c == '-' &amp;&amp; i &amp;&amp; !(str[i - 1] &gt;= '0' &amp;&amp; str[i - 1] &lt;= '9') &amp;&amp; str[i - 1] != ')')//如果是负号的话 &#123; int j = i + 1, t = 0; while (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')//可能有多位 &#123; t = t * 10 + str[j] - '0'; j ++ ; &#125; nums.push(-t);//添加-t i = j - 1; &#125; else &#123; while (ops.top() != '(') cal(); ops.push(c); &#125; &#125; else if (c == '*' || c == '/') &#123; while (ops.top() == '*' || ops.top() == '/' || ops.top() == '^') cal(); ops.push(c); &#125; else if (c == '^') &#123; while (ops.top() == '^') cal(); ops.push(c); &#125; else if (c == ')') &#123; while (ops.top() != '(') cal(); ops.pop(); &#125; else cout &lt;&lt; \"invalid operator!\" &lt;&lt; endl; &#125; &#125; cout &lt;&lt; nums.top() &lt;&lt; endl; return 0;&#125;","path":"2019/07/23/数据结构基础/表达式计算/","date":"07-23","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"栈","slug":"栈","permalink":"http://zhumenger.top/tags/栈/"}]},{"title":"没有上司的舞会","text":"题目描述 Ural大学有N名职员，编号为1~N。 他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。 每个职员有一个快乐指数，用整数 HiHi 给出，其中 1≤i≤N。 现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。 在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。 输入格式 第一行一个整数N。 接下来N行，第 i 行表示 i 号职员的快乐指数Hi。 接下来N-1行，每行输入一对整数L, K,表示K是L的直接上司。 最后一行输入0,0。 输出格式输出最大的快乐指数。 数据范围1≤N≤6000−128≤Hi≤127 输入样例： 7 11 11 11 11 32 36 47 44 53 50 0 输出样例： 5 *树形DP: * 就是在树或图上的一种DP，一般是某个父节点或子节点有特殊要求的时候用的一种DP 首先是建图，在图上遍历的时候进行DP操作，对于这道题来说我们用F(i, j)来表示i这个节点，状态为 j (用0来表示不选，用1来表示选)值的最大值，对于每个节点我们有俩种操作： 1.选当前这个节点，j 状态为1，它的子节点只能不选，所以f(i, 1) = f(i, 1) + f(u, 0)(u表示 i 的子节点) 2.不选当前这个节点，j 的状态为0，它的子节点可以选，也可以不选，取俩者的最大值 所以f(i, 0) = f(i, 0) + max(f(u, 1), f(u, 0))(u表示 i 的子节点) 3.从任意一个跟节点开始搜索，所以还需要一个数组来储存哪些节点有父节点 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 6010;int n;int happy[N];int h[N], e[N], ne[N], idx;//邻接表建图int f[N][2];bool vis[N];void add(int a, int b)//添加边&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;void dfs(int cur)//搜索，树形DP&#123; f[cur][1] = happy[cur]; for(int i = h[cur]; i != -1; i = ne[i])&#123;//遍历子节点 int j = e[i]; dfs(j); f[cur][0] += max(f[j][0], f[j][1]); f[cur][1] += f[j][0]; &#125;&#125;int main()&#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++)cin &gt;&gt; happy[i];//输入 memset(h, -1, sizeof h); for(int i = 0; i &lt; n - 1; i++)&#123; int a, b; cin &gt;&gt; a &gt;&gt; b; vis[a] = true; //表示a有父节点 add(b, a); &#125; int root = 1; while(vis[root])root++;///找到一个根节点 dfs(root); cout &lt;&lt; max(f[root][0], f[root][1]); return 0;&#125;","path":"2019/07/22/动态规划/树形DP/没有上司的舞会(树形DP)/","date":"07-22","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"树形DP","slug":"树形DP","permalink":"http://zhumenger.top/tags/树形DP/"}]},{"title":"滑雪","text":"滑雪题目描述 给定一个R行C列的矩阵，表示一个矩形网格滑雪场。 矩阵中第 i 行第 j 列的点表示滑雪场的第 i 行第 j 列区域的高度。 一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。 当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。 下面给出一个矩阵作为例子： 1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9 在给定矩阵中，一条可行的滑行轨迹为24-17-2-1。 在给定矩阵中，最长的滑行轨迹为25-24-23-…-3-2-1，沿途共经过25个区域。 现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。 输入格式 第一行包含两个整数R和C。 接下来R行，每行包含C个整数，表示完整的二维矩阵。 输出格式 输出一个整数，表示可完成的最长滑雪长度。 数据范围 1≤R,C≤3000≤矩阵中整数≤10000 输入样例： 5 51 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9 输出样例： 25 题解： 所谓记忆化搜索是指在搜索过程中，用一个数组来储存已经得到的结果，当我们再次经过这一状态时，直接返回该结果即可，不必再次深度搜索，大大的节省了时间 *代码如下： * 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 310, INF = 0x3f3f3f3f;int a[N][N], f[N][N];int n, m;int dx[]= &#123;0, 1, 0, -1&#125;;int dy[] = &#123;1, 0, -1, 0&#125;;int dfs(int x, int y)&#123; if(f[x][y])return f[x][y]; f[x][y] = 1; //最小是1 for(int k = 0; k &lt; 4; k++)&#123; int i = x + dx[k]; int j = y + dy[k]; if(a[i][j] &lt; a[x][y] &amp;&amp; i &gt;= 1 &amp;&amp; j &gt;= 1 &amp;&amp; i &lt;= n &amp;&amp; j &lt;= m) f[x][y] = max(f[x][y], dfs(i, j) + 1); &#125; return f[x][y];&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; memset(a, INF, sizeof a); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) cin &gt;&gt; a[i][j]; int ans = 0; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) ans = max(ans, dfs(i, j)); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","path":"2019/07/22/搜索/滑雪/","date":"07-22","excerpt":"","tags":[{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"http://zhumenger.top/tags/记忆化搜索/"}]},{"title":"动态规划之子序列问题","text":"一.最长递增子序列I题目描述 给定一个长度为N的数列，求数值严格单调递增的子序列的长度最长是多少。 输入格式 第一行包含整数N。 第二行包含N个整数，表示完整序列。 输出格式 输出一个整数，表示最大长度。 数据范围 1≤N≤1000，−109≤数列中的数≤109 输入样例： 7 3 1 2 1 8 5 6 输出样例： 4 思路： 采用动态规划的思想，用dp[ i ]来表示序列中第i个元素结尾的最长上升子序列的长度那么状态转移方程为： if (a[i] &gt; a[j]) dp[i] = MAX (dp[i], dp[j] + 1); 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;const int N = 1010;int d[N], a[N];int main()&#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; int ans = 0; for(int i = 0; i &lt; n; i++)&#123; d[i] = 1; for(int j = 0; j &lt; i; j++)&#123; if(a[i] &gt; a[j]) d[i] = max(d[i], d[j] + 1); &#125; ans = max(ans, d[i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 二. 最长递增子序列II给定一个长度为N的数列，求数值严格单调递增的子序列的长度最长是多少。 输入格式第一行包含整数N。 第二行包含N个整数，表示完整序列。 输出格式输出一个整数，表示最大长度。 数据范围1≤N≤100000 −109≤数列中的数≤109 输入样例： 7 3 1 2 1 8 5 6 输出样例： 4 题解： 这里的数据范围很大,不能再用上面的那个方法来做这道题 nlgn做法 定义：a[1..n]为原始序列，d[k]表示长度为k的不下降子序列末尾元素的最小值，len表示当前已知的最长子序列的长度 考虑两个数a[x]和a[y]，x&lt;y且a[x]&lt;a[y],且dp[x]=dp[y]，当a[t]要选择时，到底取哪一个构成最优的呢？显然选取a[x]更有潜力，因为可能存在a[x]&lt;a[z]&lt;a[y]，这样a[t]可以获得更优的值。在这里给我们一个启示，当dp[t]一样时，尽量选择更小的a[x]. ​ 按dp[t]=k来分类，只需保留dp[t]=k的所有a[t]中的最小值，设d[k]记录这个值，d[k]=min{a[t],dp[t]=k}。 ​ 这时注意到d的两个特点（重要）： *1. d[k]在计算过程中单调不升； * 2. d数组是有序的，d[1]&lt;d[2]&lt;..d[n]。 ** 利用这两个性质，可以很方便的求解：** 1.设当前已求出的最长上升子序列的长度为len（初始时为1），每次读入一个新元素x： 2.若x&gt;d[len]，则直接加入到d的末尾，且len++；（利用性质2） 3.否则，在d中二分查找，找到第一个比x小的数d[k]，并d[k+1]=x，在这里x&lt;=d[k+1]一定成立（性质1,2）。 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;const int N = 1e5 +10;int a[N], q[N];int main()&#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt;n; i++) cin &gt;&gt; a[i]; int len = 0; for(int i = 0; i &lt; n; i++)&#123; int l = 0, r = len; while(l &lt; r)&#123; int mid = l + r + 1 &gt;&gt; 1; if(q[mid] &lt; a[i])l = mid; //找到小于a[i]的第一个数 else r = mid - 1; &#125; //r + 1 表示大于等于a[i]的的第一个数,并将该数替换掉 len = max(len, r + 1); q[r + 1] = a[i]; &#125; cout &lt;&lt; len &lt;&lt; endl; &#125; 二.数字和最大的递增子序列 题目描述：给定你一个数字序列，找出数字和最大的递增子序列 思路：跟前一个思路一样采用dp的思想，现在dp【i】的含义表示为序列中第i个元素结尾的数字和的最大值 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;#define maxn 100000int max(int a,int b)&#123; if(a&gt;b)return a; else return b;&#125;int a[maxn+5];int dp[maxn+5];int main()&#123; int n,Max=0; scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;a[i]); dp[i]=a[i]; &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;i;j++)&#123; if(a[i]&gt;a[j])dp[i] = max(dp[j]+a[i], dp[i]);//dp【i】表示以第i个元素结尾的数字和的最大值 &#125; Max=max(Max,dp[i]); //记录最大的数字和 &#125; printf(\"%d\\n\",Max); return 0;&#125; 三.连续子数组最大和例题：杭电OJ 1003 问题描述：给你一个数字序列，里面有正数，也有负数，求出这个序列中连续某一段的和的最大值，并求出是从什么地方开始到什么地方结束 思路：dp的思想，dp【i】依然表示的是序列中以第i个元素结尾的连续数组的最大值，从第二项依次遍历，如果前一项&lt;0,则不加，若大于0就加上. 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#define maxn 100000int a[maxn+5];int main()&#123; int t,n,p=1; scanf(\"%d\",&amp;t); while(t--)&#123; a[0]=0; int start=1,end=0,fstart=1,fend=1,Max=-1e9; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++)scanf(\"%d\",&amp;a[i]); for(int i=1;i&lt;=n;i++)&#123; if(a[i-1]&lt;0)&#123; start=i; end=i; &#125; else &#123; a[i]+=a[i-1]; end=i; &#125; if(a[i]&gt;Max)&#123; //Max，fstart，fend分别表示和的最大值以及对应的起始位置 Max=a[i]; fstart=start; fend=end; &#125; &#125; printf(\"Case %d:\\n\",p); printf(\"%d %d %d\\n\",Max,fstart,fend); p++; if(t!=0)printf(\"\\n\"); &#125;&#125;","path":"2019/07/22/动态规划/基础DP/动态规划之子序列问题/","date":"07-22","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"子序列","slug":"子序列","permalink":"http://zhumenger.top/tags/子序列/"}]},{"title":"Java基础之类的构造方法和this简介","text":"一.构造方法构造方法的本质是将类中的变量通过参数的形式进行赋值 要点： 1.通过new关键字调用 2.构造器有返回值，但是不能定义返回值，不能再构造器中使用return返回某个值 3.如果没有定义构造器，则编译器会自动顶一个无参的构造函数 4.构造器的方法名必须和类名一致 123456789101112131415161718192021222324252627282930public class Main &#123; public static void main(String[] args) &#123; Point p1 = new Point(1, 2); Point p2 = new Point(3, 4); //如果自己添加了构造器，创建对象的时候， //形式一定要和构造器的形式一样，否则会报错 //Point p3 = new Point();报错 System.out.println(p1.sum(p2)); System.out.println(p2.sum(p1)); &#125; &#125;class Point&#123; int x, y; //构造方法的名称必须和类的名称一致 //构造方法的本质是将类中的变量通过参数的形式进行赋值 public Point(int a, int b) &#123; x = a; y = b; &#125; public int sum(Point p) &#123; return p.x + p.y; &#125;&#125; 二.this简介1.this表示“创建好的对象的地址”，在构造方法中也可以使用this代表当前的对象 2.this不能用于static方法中 12345678910111213141516171819202122public class Main &#123; int a, b, c; Main(int a, int b)&#123; //this表示此类 //this.a表示此类中a这个成员变量 this.a = a; this.b = b; &#125; Main(int a, int b, int c)&#123; //调用构造器 //构造器的调用必须放在第一句 this(a, b); this.c = c; &#125; public static void main(String[] args) &#123; &#125; &#125;","path":"2019/07/20/Java/Java基础之类的构造方法和this简介/","date":"07-20","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/tags/Java/"}]},{"title":"Java基础之对象和内存分析","text":"一.Java基础之对象1.什么是对象：是某种类的声明，可以通过该对象调用与之对应的类的属性和属性值，被访问的属性属于成员变量，在类中，又在方法之外的变量 2.对象的创建 通过new运算符来创建一个类的对象，，语法为：类名 变量 = new 类名()； 123456789101112131415161718192021public class Main &#123; int a; int b; //表示一个方法 void play() &#123; System.out.println(\"~~~~~^_^~~~~~\"); &#125; //构造方法，用于创建这个类的对象。无参的构造方法可以 //由系统自动生成，方法名必须和类名一致 //这里可以不写 //Main()&#123; //&#125; public static void main(String[] args) &#123; Main d = new Main();//创建一个对象 d.play();//表示调用d对象中的play函数，输出//~~~~~^_^~~~~~ d.a = 1; d.b = 123; System.out.println(d.a);//输出1 System.out.println(d.b);//输出123 &#125;&#125; 也可以在一个类中，声明另个一个类的对象，并且可以对其进行访问 1234567891011121314public class Main &#123; Computer come = new Computer();//声明一个Computer类的对象 public static void main(String[] args) &#123; Main arr = new Main();//声明一个Main类的对象 arr.come.name = \"孙悟空\"; System.out.println(arr.come.name);//输出\"孙悟空\" &#125; &#125;//另一个类class Computer&#123; String name;&#125; 二.Java基础之内存分析栈1.方法被调用的时候，都会在栈中开辟一块内存，用来存储方法中的东西 2.对象在栈中储存的是该对象在堆中的地址，对象的值并不会直接储存在栈中，而是储存在了堆中 3.局部变量也是储存在了栈内存当中 堆1.是一个不连续的内存空间，用来储存创建好的对象 2.成员变量，即对象中的属性和属性值都是在堆中储存 方法区 用来存放程序中不变或唯一的内容，实际上也是一个特殊的堆， 1234567891011121314151617181920212223public class Main &#123; //以下变量都属于成员变量， //对象又被称为实例，实例变量即对象变量 //不创建对象，成员变量的内存空间是不存在的，只有创建了 //对象，成员变量的内存空间才会被创建 int name; int age; public static void main(String[] args) &#123; //arr表示一个引用,引用即一个变量，储存的是一个Java对象的内存地址 //Java中，不能直接操作堆内存，Java中没有指针 //Java中，只能用过\"引用\"去访问堆内存的成员变量 //读取数据: 引用.变量名 Main arr = new Main(); &#125; &#125;//成员变量没有手动赋值的话，系统赋默认值//byte、short int long:0;// float double: 0.0;// boolean:false","path":"2019/07/20/Java/Java基础之对象和内存分析/","date":"07-20","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/tags/Java/"}]},{"title":"Java基础之方法","text":"java中的方法类似于其他语言中的函数，是完成特定功能的代码片段 12345678910public class Main &#123; public static void main(String[] args) &#123; int a = 2, b = 3; int c = sum(a, b); System.out.println(c); &#125; public static int sum(int a, int b)&#123; return a +b; &#125;&#125; 方法的重载： Java语言中的方法的名称可以相同 构成重载的条件： 1.方法名相同，参数个数不同，构成重载 123456789101112131415public class Main &#123; public static void main(String[] args) &#123; int a = 2, b = 3, d = 4; int c = sum(a, b); int f = sum(a, b, d); System.out.println(c);//输出5 System.out.println(f);//输出9 &#125; public static int sum(int a, int b)&#123; return a +b; &#125; public static int sum(int a, int b, int c)&#123; return a + b + c; &#125;&#125; 2.方法名相同，参数类型不同，构成重载 12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; int a = 2, b = 3; double d = 2.0; int c = sum(a, b); double f = sum(d, b); System.out.println(c);//输出5 System.out.println(f);//5.0 &#125; public static int sum(double a, int b)&#123; return a +b; &#125; public static double sum(int a, double b)&#123; return a + b; &#125;&#125; 方法名相同，参数顺序不同，构成重载 12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; double a = 2.0; int b = 3; double c = sum(a, b); double d = sum(b, a); System.out.println(c);//5.0 System.out.println(d);//5.0 &#125; public static double sum(double a, int b)&#123; return a +b; &#125; public static double sum(int a, double b)&#123; return a + b; &#125;&#125;","path":"2019/07/19/Java/Java基础之方法/","date":"07-19","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/tags/Java/"}]},{"title":"整数划分","text":"题目描述 一个正整数n可以表示成若干个正整数之和，形如：n=n1+n2+…+nk，其中n1≥n2≥…≥nk,k≥1。 我们将这样的一种表示称为正整数n的一种划分。 现在给定一个正整数n，请你求出n共有多少种不同的划分方法。 输入格式 共一行，包含一个整数n。 输出格式 共一行，包含一个整数，表示总划分数量。 由于答案可能很大，输出结果请对109+7取模。 数据范围 1≤n≤1000 输入样例: 5 输出样例： 7 题解： 类似于完全背包问题，可以把n看成体积，有 n - 1种不能体积的物品，问将这些物品装入背包，容量恰好为n的方法有多少种 状态表示：f(i, j) 表示前 i 个物品恰好能装进容量为 j 的方法总数 如何求f(i, j)？对于每个物品我们可以选择装，也可以选择不装: 1.第 i 个物品不装进背包中，说明前i - 1个物品装进背包的容量恰好为j，所以f(i, j) = f(i - 1, j) 1.第 i 个物品装进背包中，将第 i 个物品装进背包后，背包容量恰好为 j ，则状态转移方程为： *f(i, j) = f(i, j - i) * 所以总的状态转移方程为：f(i, j) = f(i - 1, j ) + f(i, j - 1) 代码如下： 123456789101112131415#include&lt;iostream&gt;using namespace std;const int N = 1010, mod = 1e9 + 7;int f[N];int main()&#123; int n; cin &gt;&gt; n; f[0] = 1; for(int i = 1; i &lt;= n; i++) // 枚举物品 for(int j = i; j &lt;= n; j++)//从小到大枚举体积 f[j] = (f[j] + f[j - i]) % mod; cout &lt;&lt; f[n] &lt;&lt; endl; return 0;&#125;","path":"2019/07/19/动态规划/基础DP/整数划分/","date":"07-19","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"计数DP","slug":"计数DP","permalink":"http://zhumenger.top/tags/计数DP/"}]},{"title":"石子合并","text":"题目描述 设有N堆石子排成一排，其编号为1，2，3，…，N。 每堆石子有一定的质量，可以用一个整数来描述，现在要将这N堆石子合并成为一堆。 每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。 例如有4堆石子分别为 1 3 5 2， 我们可以先合并1、2堆，代价为4，得到4 5 2， 又合并 1，2堆，代价为9，得到9 2 ，再合并得到11，总代价为4+9+11=24； 如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11=22。 问题是：找出一种合理的方法，使总的代价最小，输出最小代价。 输入格式 第一行一个数N表示石子的堆数N。 第二行N个数，表示每堆石子的质量(均不超过1000)。 输出格式 输出一个整数，表示最小代价。 数据范围 1≤N≤300 输入样例： 4 1 3 5 2 输出样例： 22 题解： 区间DP问题，用动态规划来做： 状态表示：f(i, j) 表示将第 i 堆石子到第 j 堆石子合并成一堆石子的代价的最小值 如何求f(i, j)呢？ 1.假设k为 i ~ j 堆石子的一个分界线，从 i 堆到 k 堆的最小代价已经求出，从 k + 1 堆到 j 堆的最小代价也已经求出，我们要求 i 堆到 j 堆的最小代价，只需要将左右俩堆的最小代价加起来，再加上这次合并的代价，就可以得到我们的f(i, j)了。 2.这次的合并代价为 i ~ j 堆所有石子的重量之和，我们可以用前缀和的方法来得到任意区间的总和 3.状态转移方程为：f(i, j) = min(f(i, j), f(i, k) + f(k + 1, j) + s[j] - s[i - 1]) 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;const int N = 310;int f[N][N], a[N], s[N];int main()&#123; int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= n; i++) s[i] = a[i] + s[i - 1]; for(int i = 2; i &lt;= n; i++)&#123;//枚举长度 for(int j = 1; j + i - 1 &lt;= n; j++)&#123;//枚举这个长度下的起点和终点 int l = j, r = j + i - 1; f[l][r] = 1e9; for(int k = l; k &lt; r; k++)//枚举分界线 f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]); &#125; &#125; cout &lt;&lt; f[1][n] &lt;&lt;endl; return 0;&#125;","path":"2019/07/19/动态规划/区间DP/石子合并(区间DP)/","date":"07-19","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"区间DP","slug":"区间DP","permalink":"http://zhumenger.top/tags/区间DP/"}]},{"title":"最短编辑距离","text":"题目描述 给定两个字符串A和B，现在要将A经过若干操作变为B，可进行的操作有： 删除–将字符串A中的某个字符删除。 插入–在字符串A的某个位置插入某个字符。 替换–将字符串A中的某个字符替换为另一个字符。 现在请你求出，将A变为B至少需要进行多少次操作。 输入格式 第一行包含整数n，表示字符串A的长度。 第二行包含一个长度为n的字符串A。 第三行包含整数m，表示字符串B的长度。 第四行包含一个长度为m的字符串B。 字符串中均只包含小写字母。 输出格式 输出一个整数，表示最少操作次数。 数据范围 1≤n,m≤1000 输入样例： 10AGTCTGACGC11AGTAAGTAGGC 输出样例： 4 题解： 将一个字符串通过删除、插入、替换变为另一个字符串的最短距离,可以用动态规划来做，用f(i, j)来表示长度为i的字符串变为长度为j的字符串最小的操作次数，那么如何来求f(i, j)呢？对每个字符我们有3种操作: 1.删除：假设删除a[i]后，a[1 ~ i] 与 b[1 ~ j] 匹配，那么说明a[1 ~ i - 1]已经与b[1 ~ j]相等了，那么多出来的a[i]直接删掉即可，状态转移方程为：f(i, j) = f(i - 1, j) + 1 2.插入： 假设插入一个a[i],使a[i] == b[j]后，a[1 ~ i] 与 b[1 ~ j] 匹配,那么说明a[1 ~ i]已经与b[i ~ j - 1]相等了，要使a[1 ~ i]与b[i ~ j]相等,只需再a[1 ~ i]的后面添加一个b[j]即可 状态转移方程为：f(i, j) = f(i, j - 1) + 1 3.替换：假设将a[i]替换成b[j],使得a[1 ~ i] 与 b[1 ~ j] 匹配,那么说明a[1 ~ i - 1]已经与b[i ~ j - 1]相等了，要使a[1 ~ i]与b[i ~ j]相等,只需将a[i]替换为b[j]即可。 如果a[i] = b[j]，则无需替换，状态转移方程为：f(i, j) = f(i - 1, j - 1) 如果a[i] != b[j]，则需要替换，状态转移方程为：f(i, j) = f(i - 1, j - 1) + 1 所以我们得出来总的状态转移方程式为就是上述方程式的最小值 代码如下： 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;const int N = 1010;char s1[N], s2[N];int f[N][N];int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; s1 + 1; cin &gt;&gt; m &gt;&gt; s2 + 1; for(int i = 0; i &lt;= n; i++) //a[i ~ i]变为0，只能删除， 操作数为i f[i][0] = i; for(int i = 0; i &lt;= m; i++)//a[0]变为b[1 ~ i]，只能添加，操作数为i f[0][i] = i; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; //f[i - 1][j] + 1 表示进行删除操作 //f[i][j - 1] + 1 表示进行添加操作 f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1); //下面的表示进行替换操作 if(s1[i] == s2[j])f[i][j] = min(f[i][j], f[i - 1][j - 1]); else f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1); &#125; &#125; cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;&#125;","path":"2019/07/19/动态规划/基础DP/字符串最短编辑距离/","date":"07-19","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"}]},{"title":"Java基础之运算符","text":"1.二元运算符整数运算 1.如果俩个操作数有一个为long，则结果为long 2.如果没有long时，结果为int，即使操作符全为float或byte，也必须用int类型的变量来保存 浮点运算 3.如果俩个操作符中有一个为double，则结果为double 4.只有当俩个操作符全为float时，结果才为float 取模运算 余数的符号与左边操作符相同，如 7%3 = 1， -7 % 3 = -1， 7 % -3 = 1； 2.自增与自减12345678910public class Main &#123; public static void main(String[] args) &#123; int a = 3; int b = a++;//先赋值在运算,b为3,a为4 int c = ++a;//先运算再赋值,a = 5, c = 5 b = a--;//先赋值在运算,b为5,a为4 b = --a;//先赋值在运算,a = 3,b = 3 System.out.println(); &#125;&#125; 3.字符串运算符1.string型与int型相加,先将int类型转化为字符串类型，在进行拼接 2.运算顺序从左到右，俩个整形相加还是整形，直到与字符串相加才变成字符串类型 12345678910public class Main &#123; public static void main(String[] args) &#123; String a = \"3\"; int b = 4; int c = 5; System.out.println(a + b);//输出34 System.out.println(a + b + c);//345 System.out.println(b + c + a);//93 &#125;&#125; 4.强制类型转换语法：type var = (type)value 12345678910public class Main &#123; public static void main(String[] args) &#123; double x = 3.14; int a = (int)x; char a = 'a'; int d = c + 1; System.out.println(a);//输出3 Syetem.out.println((char)d);//输出'b' &#125;&#125;","path":"2019/07/18/Java/Java基础之运算符/","date":"07-18","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/tags/Java/"}]},{"title":"Java基础之基本类型","text":"1.常量定义：指固定的值，不能随意改变，如：1， 2， “hello world”等 在java语言中，利用final关键字来定义一个常量，常量一旦被初始化后便不能再更改其值 声明格式: 1final type varname = value; 例： 123456public class Main&#123; public static void main(String[] args)&#123; final double PI = 3.14; System.out.println(PI); &#125;&#125; 2.基本数据类型数值型： byte(1个字节)、short(2个字节)、int(4个字节)、long(8个字节)、float(4个字节)、double(8个字节) 字符型： char(2个字节) 布尔型： boolean(1个字节) 整形的4种表示方式 1.十进制：如，99 2.八进制：以0开头 如：015 3.十六进制：以0x 或0X开头，如： 0xab 0x15 4.二进制： 以0b 或 0B开头 如：0b011010 1234567891011public class Main&#123; public static void main(String[] args)&#123; byte a = 5;//a的范围不能超过一个字节，否则会报错 int b = 015//8进制 int c = 0x15//16进制 int d = 0b1001//2进制 long e = 12345; long f = 10000000L;(后面+L表示这是一个long类型的变量) System.out.println(PI); &#125;&#125; 浮点型 1.表示形式 十进制数形式：3.14、0.1 科学计数法表示：3e5 表示300000.0 300000e-5 表示3.0 float类型数值有一个后缀 F 或 f ,没有后缀F/f的浮点数默认为double类型，也可以在数值后面添加D/d来声明它是一个double类型 浮点型的值不精确： 1234567public class Main&#123; public static void main(String[] args)&#123; float a = 0.1f; double b = 1.0 / 10; System.out.println(a == b);//false &#125;&#125; 字符型字符型占2个字节，用单引号’ ‘ 来表示一个字符，用双引号” “ 来表示一个字符串，Java采用的是Unicode编码，可以处理各种语言的文字 12345678910public class Main&#123; public static void main(String[] args)&#123; char str1 = '1'; char str2 = 'a'; char str3 = '哈'; //也可以用转义字符\\u + 4位16进制的数拉表示一个字符 char a = '\\u0061';// 表示'a' System.out.println(a == b);//false &#125;&#125; boolean类型有俩个常量：true和false","path":"2019/07/18/Java/Java基础之基本类型/","date":"07-18","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/tags/Java/"}]},{"title":"Java基础之-注释、标识符、变量","text":"一.注释单行注释： //内容…. 多行注释： /* 内容…*/ 文档注释： /** 内容 */ 1234567891011121314151617/** * 这里是文档注释 * @author Administrator * */public class Main &#123; //这里是单行注释 public static void main(String[] args) &#123; // TODO Auto-generated method stub System.out.println(\"安装eclipse完成!\"); &#125; /* * 这 * 里 * 是 * 多行注释 */&#125; 二.标识符1.命名规则: 标识符必须以字母、下划线、或者$开头，不能以数字开头 标识符其他部分可以是字母、下划线、$ 和数字的任意组合 Java标识符区分大小写 标识符不可以是Java的关键字 标识符的第一个单词的字母要小写，从第二个单词开始，首字母大写，我们称之为“驼峰原则”如get， getMin Java语言采用的不是ASCII字符集，而是Unicode国际编码，所以字符串中的内容可以是中文 三.变量当你把一个值赋值给一个名字时，它会储存在内存中，把这块内存称为变量, 本质上就是一个可以操作的储存空间 声明变量： 1234double a; //8个字节long b; //8个字节int c; //4个字节int a, b, c;//一行中声明对个变量 局部变量 在代码块内部定义的变量，生命周期从声明位置开始，带方法或代码块执行完毕为止 12345public class Main &#123; public void text&#123; int j = i + 5; &#125;&#125; 成员变量方法外部、类的内部定义的变量, 书与对象，生命周期伴随对象始终，如果不自动初始化，它会自动初始化为默认值(整型为0，浮点型为0.0) 静态变量 使用static定义，从属于类，生命周期始终伴随类，类在，该变量就在","path":"2019/07/17/Java/Java基础之-注释、标识符、变量/","date":"07-17","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/tags/Java/"}]},{"title":"Java基础之-程序详细解析","text":"1.Java区分大小写，大小写拼写错误，程序无法运行 2.关键词class是类的意思。Java所有的代码都要写在类中 3.一个源文件中只能声明一个public的类，其他类的个数不限 4.编写类的时候有俩种方式： (A). public class定义类 ： 1.如果一个类声明的时候使用了public class进行了声明，则类名称必须与文件名称完全一致。 2.被public修饰的类可以被其他包访问 (B). class定义类 1.如果一个类声明的时候使用了class进行了声明，则作为启动类的名称可以与文件名称不一致，但是执行的时候肯定执行的是生成后的名称。 2.没有public修饰的类，该类就拥有了包访问权限，即该类只可以用于该包之中。该类不能被其他包访问 5.Java中每个语句以分号结束 6.main方法是java应用程序的入口方法，它有固定的书写格式：public static void main(String[] args) 1234567891011121314151617//public 表示公开的， 表示其他的类都可以访问这个方法//class表示定义一个类//Main 表示一个类名//下面一句表示定义了一个公开的类，起名为Main,必须和文件名一致public class Main&#123; /* public表示公开的 static表示静态的 void表示空 main是Java程序进入的方法 String[] args： String 类型的数组，名为args，这个名字是可以变化的，但是一般使用args。 */ //下面一句表示定义了 public static void main(String[] args)&#123; System.out.println(\"安装eclipse完成!\"); &#125;&#125;","path":"2019/07/17/Java/Java基础之-程序详细解析/","date":"07-17","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/tags/Java/"}]},{"title":"素数","text":"一.试除法判定质数即暴力枚举它之前的数，如果能整除，说明该数不是素数 1234567891011121314151617181920212223//时间复杂度O(sqrt(n))#include&lt;iostream&gt;using namespace std;int n;bool prime(int n)&#123; if(n &lt; 2)return false; for(int i = 2; i &lt; n / i; i++)//i * i 有溢出风险，所以要把i除过去 if(n % i == 0) return false; return true;&#125;int main()&#123; long long int a; cin &gt;&gt; n; while(n--)&#123; cin &gt;&gt; a; if(prime(a))cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; return 0;&#125; 二.分解质因数 给定n个正整数ai，将每个数分解质因数，并按照质因数从小到大的顺序输出每个质因数的底数和指数。 输入格式 第一行包含整数n。 接下来n行，每行包含一个正整数ai。 输出格式 对于每个正整数ai,按照从小到大的顺序输出其分解质因数后，每个质因数的底数和指数，每个底数和指数占一行。 每个正整数的质因数全部输出完毕后，输出一个空行。 数据范围 1≤n≤1001≤ai≤2∗109 输入样例： 2 68 输出样例： 2 13 1 2 3 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;typedef long long ll;void divide(ll n)&#123; for(ll i = 2; i &lt;= n / i; i++)&#123; //枚举到sqrt(n)，时间复杂度最大为O(sqrt(n)) if(n % i== 0)&#123; int ans = 0; while(n % i == 0)&#123; n /=i; ans++; &#125; printf(\"%d %d\\n\", i, ans); &#125; &#125; if(n &gt; 1)printf(\"%d %d\\n\", n, 1);//大于sqrt(n)的质因子&#125;int main()&#123; int n; ll x; cin &gt;&gt; n; while(n--)&#123; scanf(\"%lld\", &amp;x); divide(x); printf(\"\\n\"); &#125; return 0;&#125; 三.筛质数题目描述 给定一个正整数n，请你求出1~n中质数的个数。 输入格式 共一行，包含整数n。 输出格式 共一行，包含一个整数，表示1~n中质数的个数。 数据范围 1≤n≤106 输入样例： 8 输出样例： 4 埃氏筛法原理 素数的定义：素数就是除了1和本身之外没有其他的约数，所以有约数的都不是素数。 埃氏筛法的思想就是：先去掉2的倍数，再去掉3的倍数，再去掉4的倍数，……依此类推，直到最大数小于最后一个标出的素数的平方，那么剩下的序列中所有的数都是素数。 时间复杂度：O(nloglogn)代码如下： 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;#define maxn 10000000#define INF 0x3f3f3f3fusing namespace std;bool a[maxn+5];int main()&#123; int n,m; scanf(\"%d%d\",&amp;n,&amp;m); memset(a,true,sizeof(a)); for(int i=2;i&lt;=n;i++)&#123; if(a[i])&#123; for(int j=2;i*j&lt;=n;j++) a[i*j]=false; &#125; &#125; a[1]=false; int t; while(m--) &#123; scanf(\"%d\",&amp;t); if(a[t])printf(\"Yes\\n\"); else printf(\"No\\n\"); &#125; return 0;&#125; 欧拉筛法 在埃式筛法中，存在有些数存在重复筛的情况，如：385这个数，385= 5 * 7* 11，会被5的倍数时标记一次，7的倍数时标记一次，11的倍数时标记一次，造成效率达不到最优。而线性筛法基于改进这个不足的基础上，在线性时间内，也就是O(n)，用筛选的方法把素数找出来。 核心原理：对于每个合数，都只由它最小的质因子筛掉。 比如：（假定：ans[]数组中存放着已经确定的素数）合数 i = p（最小素因子）* a; 若 i%ans[j] ==0; 则 i * ans[j+1] = p * a * ans[j+1] 可以被后面的 a * ans[j+1] 再乘以素数 p 筛选出来，(显而p&lt;ans[j+1]） 所以i%ans[j] == 0 时要停止。 代码如下： 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define maxn 10000000#define INF 0x3f3f3f3fusing namespace std;bool a[maxn+5];int b[maxn+5];//存储质数int main()&#123; int n,m; scanf(\"%d%d\",&amp;n,&amp;m); memset(a,true,sizeof(a)); a[1]=false; int k=1; for(int i=2;i&lt;=n;i++)&#123; if(a[i]) //如果i为质数 b[k++]=i;//存上 for(int j=1;j&lt;=k&amp;&amp;i*b[j]&lt;=n;j++)&#123; a[i*b[j]]=false; if(i%b[j]==0)break; &#125; &#125; int t; while(m--)&#123; scanf(\"%d\",&amp;t); if(a[t])printf(\"Yes\\n\"); else printf(\"No\\n\"); &#125; return 0;&#125;","path":"2019/07/17/数论/素数/","date":"07-17","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"素数","slug":"素数","permalink":"http://zhumenger.top/tags/素数/"}]},{"title":"雪花雪花雪花","text":"雪花雪花雪花 有N片雪花，每片雪花由六个角组成，每个角都有长度。 第i片雪花六个角的长度从某个角开始顺时针依次记为ai1,ai2,…,ai6。 因为雪花的形状是封闭的环形，所以从任何一个角开始顺时针或逆时针往后记录长度，得到的六元组都代表形状相同的雪花。 例如ai1,ai2,…,ai6和ai2,ai3,…,ai6，ai1就是形状相同的雪花。 ai1,ai2,…,ai6和ai6,ai5,…,ai1也是形状相同的雪花。 我们称两片雪花形状相同，当且仅当它们各自从某一角开始顺时针或逆时针记录长度，能得到两个相同的六元组。 求这N片雪花中是否存在两片形状相同的雪花。 输入格式 第一行输入一个整数N，代表雪花的数量。 接下来N行，每行描述一片雪花. 每行包含6个整数，分别代表雪花的六个角的长度（这六个数即为从雪花的随机一个角顺时针或逆时针记录长度得到）。 同行数值之间，用空格隔开。 输出格式 如果不存在两片形状相同的雪花，则输出： No two snowflakes are alike. 如果存在两片形状相同的雪花，则输出： Twin snowflakes found. 数据范围 1≤n≤1000000≤ai,j&lt;10000000 输入样例： 2 1 2 3 4 5 64 3 2 1 6 5 输出样例： Twin snowflakes found. 题解： 字符串的最小表示法：每一个字符串都有一个字典序最小的表示，比较这俩个字符串的最小表示是否相等即可 1.用俩个数组分别存取该字符串的正序和逆序表示 2.用最小表示法获得俩种表示方法中字典序最小的那个，并将该结果用数组储存起来 3.我们需要对储存的结果进行排序，这样只需要比较相邻的俩个数是否相等即可，但并不能直接对二维数组进行排序，这里我们需要一个一维数组，来储存每个字符串的下标，该数组通过二维数组字符串的关系对下标进行排序,通过遍历该下标访问二维数组即可 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e5 + 10;int n;int snows[N][6], idx[N];void get_min(int a[])//获得字符串的最小表示法&#123; int b[12]; for(int i = 0; i &lt; 12; i++)b[i] = a[i % 6]; int i = 0, j = 1, k; while(i &lt;= 6 &amp;&amp; j &lt;= 6)&#123; k = 0; while(k &lt; 6 &amp;&amp; b[i + k] == b[j + k])k++; if(k == 6)break; if(b[i + k] &lt; b[j + k])&#123; j += k + 1; if(j == i)j++; &#125; else&#123; i += k + 1; if(i == j)i++; &#125; &#125; k = min(i, j); for(int i = 0; i &lt; 6; i++)&#123; a[i] = b[i + k]; &#125;&#125;bool cmp_array(int a[], int b[])//比较a是否小于b&#123; for(int i = 0; i &lt; 6; i++)&#123; if(a[i] &gt; b[i]) return false; else if(a[i] &lt; b[i]) return true; &#125; return false;&#125;bool cmp(int a, int b)//对二维数组排序&#123; return cmp_array(snows[a], snows[b]);//返回俩个字符串的关系&#125;int main()&#123; cin &gt;&gt; n; int snow[6], isnow[6]; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; 6; j++)&#123; cin &gt;&gt;snow[j]; isnow[5 - j] = snow[j]; &#125; get_min(snow);//获得最小表示 get_min(isnow); if(cmp_array(snow, isnow))memcpy(snows[i], snow, sizeof snow); else memcpy(snows[i], isnow, sizeof isnow); idx[i] = i; &#125; sort(idx, idx + n, cmp);//对下标进行排序 bool flag = false; for(int i = 1; i &lt; n; i++)&#123;//比较相邻的俩个数是否相同 if(!cmp(idx[i - 1], idx[i]) &amp;&amp; !cmp(idx[i], idx[i - 1]))&#123; flag = true; break; &#125; &#125; if(flag)puts(\"Twin snowflakes found.\"); else puts(\"No two snowflakes are alike.\"); return 0;&#125;","path":"2019/07/16/数据结构基础/雪花雪花雪花(最小表示法)/","date":"07-16","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"字符串","slug":"字符串","permalink":"http://zhumenger.top/tags/字符串/"}]},{"title":"邻值查找","text":"题目描述 给定一个长度为 n 的序列 A，A 中的数各不相同。对于 A 中的每一个数 Ai，求： min1≤j&lt;i|Ai−Aj| 以及令上式取到最小值的 j（记为 Pi）。若最小值点不唯一，则选择使 Aj 较小的那个。 输入格式 第一行输入整数n，代表序列长度。 第二行输入n个整数A1…An,代表序列的具体数值，数值之间用空格隔开。 输出格式 输出共n-1行，每行输出两个整数，数值之间用空格隔开。 分别表示当i取2~n时，对应的min1≤j&lt;i|Ai−Aj|和Pi的值。 数据范围 0&lt;n≤10^5,|Ai|≤10^9 输入样例： 3 1 5 3 输出样例： 4 12 1 题解： 1.由题意可知，这道题让我们求的是a[i]之前与a[i]最接近的数,如果我们进行排序，拍完序后与a[i]相邻的俩个肯定有一个是与a[i]最接近的, 2.首先用结构体将a[i]及其对应的下标存起来，从小到大排序 3.将排完序之后的结果用链表存起来,存起来后，我们从a[n]开始倒着遍历查找答案，在链表中它的前驱和后继的下标一定都是小于n的，取俩者与a[n]最接近的数，便是我们的答案 4.找到i的答案后，去掉该节点即可，保证从后往前遍历的时候，与a(i - 1)相邻的节点的下标都是小于i - 1的 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e5 + 10;int e[N], l[N], r[N];typedef pair&lt;int, int&gt; p;p a[N], ans[N];int main()&#123; int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i].first, a[i].second = i; sort(a + 1, a + 1 + n); a[0].first = 1e9, a[n + 1].first = -1e9; for(int i = 1; i &lt;= n; i++)&#123; l[i] = i - 1, r[i] = i + 1; e[a[i].second] = i; &#125; for(int i = n; i &gt; 1; i--)&#123;//从后往前遍历，则a[i]排完序后的前驱和后继的下标都是小于i的, int j = e[i], left = l[j], right = r[j]; int lv = abs(a[j].first - a[left].first); int rv = abs(a[j].first - a[right].first); if(lv &lt;= rv) ans[i] = &#123;lv, a[left].second&#125;; else if(lv &gt; rv) ans[i] = &#123;rv, a[right].second&#125;; r[left] = right, l[right] = left; //找到i的答案后，去掉该节点即可，这样从后往前遍历的 //时，保证了与a(i - 1)相邻的节点的下标都是小于i - 1的 &#125; for(int i = 2; i &lt;= n; i++) cout &lt;&lt; ans[i].first &lt;&lt; ' ' &lt;&lt; ans[i].second &lt;&lt; endl; return 0;&#125;","path":"2019/07/16/数据结构基础/邻值查找(邻接表)/","date":"07-16","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"链表","slug":"链表","permalink":"http://zhumenger.top/tags/链表/"}]},{"title":"背包九讲","text":"Acwing背包题库一.01背包问题问题描述 有 N 件物品和一个容量是 VV 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。 输入格式 第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。 接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。 输出格式 输出一个整数，表示最大价值。 数据范围 0&lt;N,V≤10000&lt;vi,wi≤1000 输入样例 4 51 22 43 44 5 输出样例： 8 题解： 首先DP问题分为俩个步骤： 1.状态表示：首先考虑用几维的状态表示，然后考虑集合的含义，以及其属性(求Max, Min,数量等) 2.状态计算：DP问题一般都可以将大问题划分为小问题，从小问题下手，从而得到一般的状态转移方程 对于这道题，我们考虑： 1.首先声明一个数组F(i, j)表示选前 i 件物品，且背包容量为 j 时所能获得的最大价值 。 2.对于每个物品我们有拿或者不拿俩种选择： (1).j &lt; w[i] 的情况，这时候背包容量不足以放下第 i 件物品，只能选择不拿 (2).j &gt;= w[i] 的情况，这时背包容量可以放下第 i 件物品，我们就要考虑拿这件物品是否能获取更大的价值。 如果拿取，则F(i, j) = f(i - 1, j - v[i]) + w[i],即 F(i, j) 表示在上一状态中选了第i件物品， 如果不拿，则F(i, j) = f(i - 1, j) 拿或者不拿，就要看哪种方法得到的价值最大，即 F(i, j) = max(f(i - 1, j), f(i - 1, j - v[i]) + w[i]) 代码如下： 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;#define maxn 1000using namespace std;int v[maxn + 5], w[maxn + 5];int dp[maxn + 5][maxn + 5];int main()&#123; int n,W; scanf(\"%d%d\",&amp;n,&amp;W); for(int i = 0; i &lt; n; i++) scanf(\"%d%d\",&amp;v[i],&amp;w[i]); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt;= W; j++)&#123; if(v[i] &gt; j)dp[i + 1][j] = dp[i][j]; else dp[i + 1][j] = max(dp[i][j], dp[i][j - v[i]] +w[i]); &#125; &#125; printf(\"%d\\n\",dp[n][W]); return 0;&#125; 01背包问题一维数组实现状态转移方程如果是由上一层的状态得来的话，枚举体积的时候从大到小枚举，这样我们计算体积的时候，可以保证本层所用到的体积还没有被计算过 如果用的是本层的状态，枚举体积的时候就要从小到大枚举，这样我们计算体积的时候，可以保证所用到的体积是本层之前计算好的体积 1234567891011121314151617#include&lt;iostream&gt;using namespace std;const int N = 1010;int d[N];int main()&#123; int n, V; cin &gt;&gt; n &gt;&gt; V; for(int i = 0; i &lt; n; i++)&#123; int v, w; cin &gt;&gt; v &gt;&gt; w; for(int j = V; j &gt;= v; j--) d[j] = max(d[j], d[j - v] + w); &#125; cout &lt;&lt; d[V] &lt;&lt; endl; return 0;&#125; 二.01背包问题2问题描述 有n个重量和价值分别为wi，vi的物品。从这些物品中挑选总重量不超过W的物品，求所有挑选方案中价值总和最大的方案 输入样例 4 52 1 3 23 2 4 2 输出样例 7 取值范围 1&lt;=n&lt;=1001&lt;=wi&lt;=10^71&lt;=vi&lt;=1001&lt;=W&lt;=10 ^9 分析： 这里与背包问题1不同的地方是修改了限制的条件，求解这一问题的复杂度是O（NW），对于这一问题的规模来讲就不够用了，相比较重量来说，价值的范围较小一些，所以可以改变DP的对象，背包问题1用DP来表示不同体积下的最大价值，这次我们不妨用DP来表示不同价值下的最小体积。定义：F(i, j)表示前i个物品挑选出价值总和为j时的最小重量,(不存在是就是一个充分大的数INF)由于前0个物品都挑选不了 所以F(0, 0)=0, F(0, j)=INF 状态转移式为：F(i, j) = min(f(i - 1, j), F(i - 1,j - w[i]) + v[i]) 代码如下： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#define INF 1000000000#define max_n 100#define max_v 100using namespace std;int n,W;int dp[max_n+5][max_n*max_v+5];int w[max_n+5],v[max_n+5];void solve()&#123; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;=max_n*max_v+5;j++)&#123; if(j&lt;v[i])dp[i+1][j]=dp[i][j]; else dp[i+1][j]=min(dp[i][j],dp[i][j-v[i]]+w[i]); &#125; &#125;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;W); for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;w[i]); for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;v[i]); fill(dp[0],dp[0]+max_n*max_v+5,INF); //初始化 dp[0][0]=0; solve(); int res=0; for(int i=0;i&lt;=max_n*max_v;i++)&#123; if(dp[n][i]&lt;=W)res=i; &#125; printf(\"%d\\n\",res); return 0;&#125; 三.完全背包问题 有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。 第 i 种物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。 输入格式 第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。 接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 种物品的体积和价值。 输出格式 输出一个整数，表示最大价值。 数据范围 0&lt;N,V≤10000&lt;vi,wi≤1000 输入样例 4 51 22 43 44 5 输出样例： 10 题解： 完全背包问题，物品有无限个，这里我们来考虑第i个物品选多少个 1.对于每种物品，我们有选和不选俩种选择， 如果不选，F(i + 1 ,j) = F(i , j) 如果选了，我们还要考虑选多少个，即F(i + 1, j) = max(F(i + 1, j - v[i]) + w[i], F(i + 1, j)) 取俩种情况的最大值，变得到了状态转移方程： F(i + 1, j) = max(F(i , j), F(i + 1, j - v[i]) + w[i]) 代码如下： 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;#define maxn 1000using namespace std;int v[maxn + 5], w[maxn + 5];int dp[maxn + 5][maxn + 5];int main()&#123; int n,V; scanf(\"%d%d\",&amp;n,&amp;V); for(int i = 0; i &lt; n; i++) scanf(\"%d%d\",&amp;v[i],&amp;w[i]); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt;= V; j++)&#123; if(v[i] &gt; j)dp[i + 1][j] = dp[i][j]; else dp[i + 1][j] = max(dp[i][j], dp[i + 1][j - v[i]] + w[i]); &#125; &#125; printf(\"%d\\n\",dp[n][V]); return 0;&#125; 一维数组实现 上面我们说到：如果用的是本层的状态，枚举体积的时候就要从小到大枚举即可，这样我们计算体积的时候，可以保证所用到的体积是本层之前计算好的体积 代码如下： 1234567891011121314151617#include&lt;iostream&gt;using namespace std;const int N = 1010;int d[N];int main()&#123; int n,V; cin &gt;&gt; n &gt;&gt; V; for(int i = 0; i &lt; n; i++)&#123; int v, w; cin &gt;&gt; v &gt;&gt; w; for(int j = v; j &lt;= V; j++) d[j] = max(d[j], d[j - v] + w); &#125; cout &lt;&lt; d[V] &lt;&lt; endl; return 0;&#125; 四.多重背包问题 I题目描述 有 N 种物品和一个容量是 V 的背包。 第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。 输入格式 第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。 接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。 输出格式 输出一个整数，表示最大价值。 数据范围 0&lt;N,V≤1000&lt;vi,wi,si≤100 输入样例 4 51 2 32 4 13 4 34 5 2 输出样例： 10 题解： 当成01背包问题来做即可，在枚举体积的时候在枚举一下该物品个数 状态转移方程：F(i, j) = max(F(i - 1, j), F(i - 1, j - k * v[i]) + k * w[i]) 一维数组实现，由于该状态转移用的是上一层的状态，所以枚举体积的时候，我们从大到小枚举，代码如下： 123456789101112131415161718#include&lt;iostream&gt;using namespace std;const int N = 110;int d[N];int main()&#123; int n, V; cin &gt;&gt; n &gt;&gt; V; for(int i = 0; i &lt; n; i++)&#123; int v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; for(int j = V; j &gt;= v; j--) for(int k = 1; k &lt;= s &amp;&amp; k * v &lt;= j; k++) d[j] = max(d[j], d[j - k * v] + k * w); &#125; cout &lt;&lt; d[V] &lt;&lt; endl; return 0;&#125; 五.多重背包问题II题目描述 有 N 种物品和一个容量是 V 的背包 第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。 输入格式 第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。 接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。 输出格式 输出一个整数，表示最大价值。 数据范围 0&lt;N≤10000&lt;V≤20000&lt;vi,wi,si≤2000 提示：本题考查多重背包的二进制优化方法。 输入样例 4 51 2 32 4 13 4 34 5 2 输出样例： 10 题解： 由于这题的数据范围有点大，直接暴力枚举会超时，那么我们就要想一个可以优化的方法，这里主要是对物品的个数进行拆分，将其变为01背包问题 二进制拆分法： 我们知道，从2^0, 2^1, 2^2…2^(k - 1)这k个数中选出任意个相加可以表示出0~2^k之间任何整数，所以我们可以对每一种物品就行二进制拆分，将其转化为01背包问题 代码如下： 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 9;int a[N], b[N], d[N];int main()&#123; int k = 0; int n, V; cin &gt;&gt; n &gt;&gt; V; for(int i = 0; i &lt; n; i++)&#123; int v, w, s; scanf(\"%d%d%d\", &amp;v, &amp;w, &amp;s); for(int j = 1; j &lt;= s; j &lt;&lt;= 1)&#123;//二进制拆分 a[k] = j * v; //用a数组来存体积 b[k++] = j * w; //b数组来存价值 s -= j; &#125; if(s &gt; 0)&#123; a[k] = s * v; b[k++] = s * w; &#125; &#125; for(int i = 0; i &lt; k; i++)//01背包 for(int j = V; j &gt;= a[i]; j--) d[j] = max(d[j], d[j - a[i]] + b[i]); cout &lt;&lt; d[V] &lt;&lt; endl; return 0;&#125; ## 六.分组背包问题题目描述 有 N 组物品和一个容量是 V 的背包。 每组物品有若干个，同一组内的物品最多只能选一个。每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。 求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。 输出最大价值。 输入格式 第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。 接下来有 N 组数据： 每组数据第一行有一个整数 Si，表示第 i 个物品组的物品数量； 每组数据接下来有 Si 行，每行有两个整数 vij,wij，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值； 输出格式 输出一个整数，表示最大价值。 数据范围 0&lt;N,V≤1000&lt;Si≤1000&lt;vij,wij≤100 输入样例 3 52 1 22 41 3 41 4 5 输出样例 8 题解： 跟完全背包问题类似 用F(i, j)来表示选前i组物品且体积为j时的价值最大值，我们先枚举每一组，由于F(i, j)的状态用的是上一层的状态，所以我们枚举体积的时候从大到小来枚举，再依次枚举每一组里的物品，找到体积为j时，选取i组中哪个物品的价值最大 代码如下： 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;const int N = 110;int v[N][N], w[N][N];int d[N], s[N];int main()&#123; int n, V; cin &gt;&gt; n &gt;&gt; V; for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; s[i]; for(int j = 0; j &lt; s[i]; j++)&#123; cin &gt;&gt; v[i][j] &gt;&gt; w[i][j]; &#125; &#125; for(int i = 0; i &lt; n; i++) //枚举每一组 for(int j = V; j &gt;= 0; j--) //枚举体积 for(int k = 0; k &lt; s[i]; k++)//枚举第i组体积为j时，选取哪个物品价值最大 if(v[i][k] &lt;= j) d[j] = max(d[j], d[j - v[i][k]] + w[i][k]); cout &lt;&lt; d[V] &lt;&lt; endl; return 0;&#125; 七.背包问题求方案数有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出 最优选法的方案数。注意答案可能很大，请输出答案模 109+7 的结果。 输入格式第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。 接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。 输出格式输出一个整数，表示 方案数 模 109+7 的结果。 数据范围0&lt;N,V≤10000&lt;vi,wi≤1000 输入样例 4 51 22 43 44 6 输出样例： 2 题解：在01背包问题的基础上，添加一个num数组用来记录方案数即可 代码如下： 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3 + 10, mod = 1000000007;int w[N], v[N], dp[N], num[N];int main()&#123; int n, V; scanf(\"%d%d\", &amp;n, &amp;V); for(int i = 0; i &lt; n; i++)&#123; scanf(\"%d%d\", &amp;v[i], &amp;w[i]); num[i] = 1; &#125; for(int i = 0; i &lt; n; i++)&#123; for(int j = V; j &gt;= v[i]; j--)&#123; if(dp[j] &lt; dp[j - v[i]] + w[i])&#123;//更新最大价值 dp[j] = dp[j - v[i]] + w[i]; num[j] = num[j - v[i]] % mod;//num数组记录更新方案数 &#125; else if(dp[j] == dp[j - v[i]] + w[i])&#123;//如果相等 num[j] = (num[j] + num[j - v[i]]) % mod;//方案数相加 &#125; &#125; &#125; cout &lt;&lt; num[V] &lt;&lt; endl; return 0;&#125; 八. 背包问题求具体方案有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出 字典序最小的方案。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 1…N。 输入格式第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。 接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。 输出格式输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。 物品编号范围是 1…N。 数据范围 0&lt;N,V≤10000&lt;vi,wi≤1000 输入样例 4 51 22 43 44 6 输出样例： 1 4 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;const int N = 1010;int v[N], w[N], d[N][N], ans[N];int n, m;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i]; for(int i = n; i &gt;= 1; i--)&#123; for(int j = 0; j &lt;= m; j++)&#123; d[i][j] = d[i + 1][j]; if(j &gt;= v[i]) d[i][j] = max(d[i][j], d[i + 1][j - v[i]] + w[i]); &#125; &#125; int j = m; for(int i = 1; i &lt;= n; i++)&#123; if(j &gt;= v[i] &amp;&amp; d[i][j] == d[i + 1][j - v[i]] + w[i])&#123; cout &lt;&lt; i &lt;&lt; ' '; j -= v[i]; &#125; &#125; return 0;&#125;","path":"2019/07/15/动态规划/基础DP/背包九讲/","date":"07-15","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"背包问题","slug":"背包问题","permalink":"http://zhumenger.top/tags/背包问题/"}]},{"title":"博弈论","text":"博弈论一.NIM博弈给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。 我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。NIM博弈不存在平局，只有先手必胜和先手必败两种情况。 定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An != 0 代码如下： 123456789101112131415#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int a[N];int main()&#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++)cin &gt;&gt; a[i]; int ans = 0; for(int i = 0; i &lt; n; i++)ans ^= a[i]; if(ans != 0)cout &lt;&lt; \"Yes\" &lt;&lt; endl; else puts(\"No\"); return 0;&#125; 二.SG函数Mex运算： 设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：mex(S) = min{x}, x属于自然数，且x不属于S SG函数 在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达子节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即：SG(x) = mex({SG(y1), SG(y2), …, SG(yk)}) 特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。 有向图游戏的和 设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即： SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm) 定理有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。 例题：集合-Nim游戏 给定n堆石子以及一个由k个不同正整数构成的数字集合S。 现在有两位玩家轮流操作，每次操作可以从任意一堆石子中拿取石子，每次拿取的石子数量必须包含于集合S，最后无法进行操作的人视为失败。 问如果两人都采用最优策略，先手是否必胜。 输入格式 第一行包含整数k，表示数字集合S中数字的个数。 第二行包含k个整数，其中第i个整数表示数字集合S中的第i个数si。 第三行包含整数n。 第四行包含n个整数，其中第ii个整数表示第i堆石子的数量hi。 输出格式 如果先手方必胜，则输出“Yes”。 否则，输出“No”。 数据范围1≤n,k≤1001≤si,hi≤10000 输入样例： 2 2 53 2 4 7 输出样例： Yes 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 110, M = 10010;int n, m;int f[N], SG[M], s[M];void getSG(int n)//SG函数模板&#123; memset(SG, 0, sizeof SG); for(int i = 1; i &lt;= n; i++)&#123; memset(s, 0, sizeof s); for(int j = 0; f[j] &lt;= i &amp;&amp; j &lt; m; j++)&#123; s[SG[i - f[j]]] = 1;//记录i的子节点的SG函数 &#125; for(int j = 0;; j++)&#123; if(!s[j])&#123; SG[i] = j; break; &#125; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; m; for(int i = 0; i &lt; m; i++)cin &gt;&gt; f[i]; sort(f, f + m); getSG(10000); cin &gt;&gt; n; int ans = 0; for(int i = 0; i &lt; n; i++)&#123; int x; cin &gt;&gt; x; ans ^= SG[x]; &#125; if(ans)puts(\"Yes\"); else puts(\"No\"); return 0;&#125;","path":"2019/07/11/数论/博弈论/","date":"07-11","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"博弈论","slug":"博弈论","permalink":"http://zhumenger.top/tags/博弈论/"}]},{"title":"容斥原理","text":"容斥原理什么是容斥原理 在计数时，必须注意没有重复，没有遗漏。为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。 1.假设有俩个圆相交，要你求它的面积，便可得到 两个集合的容斥关系：S1∪S2 =|S1∪S2| = |S1|+|S2| - |S1∩S2 | *2.假设有3个圆相交，要你求它的面积: * 那么三个集合的容斥关系S = s1 + s2 + s3 - (s1 ∩ s2) - (s1 ∩ s3) - (s2 ∩ s3) + (s1 ∩ s2 ∩ s3) 在这个基础上加以推广便可得到我们的容斥原理公式： 题目描述给定一个整数n和m个不同的质数p1,p2,…,pm。 请你求出1~n中能被p1,p2,…,pm中的至少一个数整除的整数有多少个。 输入格式第一行包含整数n和m。 第二行包含m个质数。 输出格式输出一个整数，表示满足条件的整数的个数。 数据范围1≤m≤161≤n,pi≤109 输入样例： 10 22 3 输出样例： 7 代码如下： 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;const int N = 20;typedef long long int ll;int a[N];int main()&#123; int n,m; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i++) cin &gt;&gt; a[i]; int ans = 0; for(int i = 1; i &lt; 1 &lt;&lt; m; i++)&#123;//用位运算来表示哪些数被选过 int t = 1, cnt = 0; //t表示所有被选的数的乘积，cnt表示选中数的个数 for(int j = 0; j &lt; m; j++)&#123; if(i &gt;&gt; j &amp; 1)&#123; cnt++; if((ll)t * a[j] &gt; n)&#123; //如果乘积大于n, 则这种方法不行 t = -1; break; &#125; t *= a[j]; &#125; &#125; if(t != -1)&#123; //奇+ 偶- if(cnt % 2)ans += n / t; //n里面有多少个t else ans -= n / t; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","path":"2019/07/11/数论/容斥原理/","date":"07-11","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"容斥原理","slug":"容斥原理","permalink":"http://zhumenger.top/tags/容斥原理/"}]},{"title":"JS基础之强制类型转换","text":"强制类型转换将一个数据类型转化为另一个数据类型，如：String Number Boolean 1.转化为String类型123456789101112131415161718192021222324252627282930313233343536373839&lt;script type=\"text/javascript\"&gt; /* *方式一： * -调用被转换数据类型的toString()的方法 * -该方法不会影响到原变量，它会将转换的结果返回 * -注意：null和undefined这俩个值没有toString()方法 * 如果调用他们，会报错 */ var a = 123; var b = a.toString(); console.log(typeof a);//输出number console.log(typeof b)//输出string //给自己赋值 a = a.toString(); a = null; //a = a.toString();//报错 a = undefined; //a = a.toString();//报错 /*方式二： * -调用String()函数，并将被转换的数据作为参数传递给函数 * -调用String()函数做强制类型转换时， * 对于Number和boolean实际上就是调用的toString()方法 * 对于null和undefined不会调用toString()方法 * 它会直接转化为字符串 */ a = 123; a = String(a); a = null; a = String(a);//输出字符串\"null\" a = undefined; a = String(a);//输出字符串\"undefined\" &lt;/script&gt; 2.转化为number类型1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;script type=\"text/javascript\"&gt; /* *方式一: * -使用Number()函数 * -字符 --&gt; 数字 * 1.如果是纯数字的字符串，直接转化为相应的数字 * 2.如果字符串中有只要有非数字的内容，则转换为NaN * 3.如果字符串为空串或者全是空格，则转化为0 * -布尔 --&gt; 数字 * true 转为1 * false 转为0 * -Null --&gt; 数字 0 * -undefined --&gt; 数字 NaN */ var a = \"123\"; a = Number(a); a = true; a = Number(a);//值为1 a = false; a = Number(a);//值为0 a = null; a = Number(a);//值为0 a = undefined; a = Number();//值为NaN /* *转化方式二： * -专门用来对付字符串的 * -parseInt();//把字符串转化为一个整数 * -parseFloat();//把一个字符串转化为浮点数 * -可以将字符串中有效的数字转化为Number * -只要遇到非数字内容，后面的即使有整数也不再读取 * -如果对非String使用parseInt() * 它会先将其转化为String,然后在操作 */ a = \"123px\"; a = parseInt(a);//输出123 a = true; a = parseInt(a);//输出NaN&lt;/script&gt;","path":"2019/07/10/JavaScirpt/JS基础之强制类型转换/","date":"07-10","excerpt":"","tags":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/tags/JavaScirpt/"}]},{"title":"满足条件的01序列","text":"题目描述 给定n个0和n个1，它们将按照某种顺序排成长度为2n的序列，求它们能排列成的所有序列中，能够满足任意前缀序列中0的个数都不少于1的个数的序列有多少个。 输出的答案对109+7取模。 输出格式 共一行，包含整数n。 输出格式 共一行，包含一个整数，表示答案。 数据范围 1≤n≤105 输入样例： 3 输出样例： 5 题解： 可以将这道题转化为表格的形式，0表示向左走一格，1表示向上走一格，要想满足前缀序列中0的个数始终不少于1的个数，只需满足x &gt;= y即可，如下图所示 即到(n, n)的路径中不能越过红线，越过红线的路径皆为违法的路径,如下图所示： 任意一条违法的路径都能通过 y = x 这条线从(n, n)映射到(n - 1, n + 1) 所以违法的路径我们是可以求出来的，即C(2n, n - 1), 那么用总路径减去违法的路径便是我们想要求出的答案 即answer = C(2n, n) - C(2n, n - 1), 化简可得answer = (2n)! /(n! * n!)/(1 + n) = C(2n, n) / (1 + n) 代码如下： 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;typedef long long ll;const int mod = 1e9 + 7;int ksm(int a, int b)//快速幂求乘法逆元&#123; ll ans = 1; while(b)&#123; if(b &amp; 1)ans = (ll)ans * a % mod; b &gt;&gt;= 1; a = (ll)a * a % mod; &#125; return ans;&#125;int main()&#123; int n; cin &gt;&gt; n; int a = 2 * n, b = n; int ans = 1; for(int i = a; i &gt; a - b; i--) ans = (ll)ans * i % mod; for(int i = 1; i &lt;= b; i++) ans = (ll)ans * ksm(i, mod - 2) % mod; ans = (ll)ans * ksm(n + 1, mod - 2) % mod; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","path":"2019/07/10/数论/满足条件的01序列/","date":"07-10","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"}]},{"title":"组合数IV之高精度","text":"题目描述 输入a,b，求C(a, b)的值。 注意结果可能很大，需要使用高精度计算。 输入格式 共一行，包含两个整数a和b。 输出格式 共一行，输出C(a, b)的值。 数据范围 1≤b≤a≤5000 输入样例： 5 3 输出样例： 10 题解： 可以用公式C(a, b) = a! / (b! * (a - b)!) 来做，如果直接用for循环求阶乘的话，时间复杂度很大，我们求除法运算的时候，一般都是将他们分解质因数，然后用分子分解质因数的个数减去分母分解质因数的个数，最后将质因数乘起来便是最后的答案 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N = 5010;int primes[N], cnt;int sum[N];bool st[N];void get_primes(int n) //线性筛法得到质因数&#123; for(int i = 2; i &lt;= n; i++)&#123; if(!st[i]) primes[cnt++] = i; for(int j = 0; j &lt; cnt &amp;&amp; primes[j] &lt;= n / i; j++)&#123; st[primes[j] * i] = true; if(i % primes[j] == 0)break; &#125; &#125;&#125;int get(int n, int p)//得到p这个质因数的个数&#123; int res = 0; while(n)&#123; res += n / p; n /= p; &#125; return res;&#125;vector&lt;int&gt; mul(vector&lt;int&gt; a, int b)//高精度乘法&#123; vector&lt;int&gt; ans; int t = 0; for(int i = 0; i &lt; a.size(); i++)&#123; t += a[i] * b; ans.push_back(t % 10); t /= 10; &#125; while(t)&#123; ans.push_back(t % 10); t /= 10; &#125; return ans;&#125;int main()&#123; int a, b; cin &gt;&gt; a &gt;&gt; b; get_primes(a); for(int i = 0; i &lt; cnt; i++)&#123; int p = primes[i]; sum[i] = get(a, p) - get(b, p) - get(a - b, p);//获取除法运算中每个质因数的个数 &#125; vector&lt;int&gt;res; res.push_back(1); for(int i = 0; i &lt; cnt; i++)&#123;//枚举每个质因数 for(int j = 0; j &lt; sum[i]; j++)&#123;//枚举个数 res = mul(res, primes[i]);//高精度乘法 &#125; &#125; for(int i = res.size() - 1; i &gt;= 0; i--)&#123;//倒序输出 cout &lt;&lt; res[i]; &#125; return 0;&#125;","path":"2019/07/10/数论/组合数IV之高精度/","date":"07-10","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"组合数","slug":"组合数","permalink":"http://zhumenger.top/tags/组合数/"}]},{"title":"高斯消元解线性方程组","text":"一.高斯消元解线性方程组题目描述输入一个包含n个方程n个未知数的线性方程组。 方程组中的系数为实数。 求解这个方程组。 下图为一个包含m个方程n个未知数的线性方程组示例： 输入格式 第一行包含整数n。 接下来n行，每行包含n+1个实数，表示一个方程的n个系数以及等号右侧的常数。 输出格式 如果给定线性方程组存在唯一解，则输出共n行，其中第i行输出第i个未知数的解，结果保留两位小数。 如果给定线性方程组存在无数解，则输出“Infinite group solutions”。 如果给定线性方程组无解，则输出“No solution”。 数据范围 1≤n≤100,所有输入系数以及常数均保留两位小数，绝对值均不超过100。 输入样例： 3 1.00 2.00 -1.00 -6.002.00 1.00 -3.00 -9.00-1.00 -1.00 2.00 7.00 输出样例： 1.00-2.003.00 题解： 高斯消元，即线性代数的知识，将方程组系数矩阵转化为三角矩阵: 1.枚举每一列，在每一列中找到绝对值最大的一行 2.将改行放到最上面，并将该行首非零元素化为1 3.将下面的所有行的第c列化为0， 4.最终得到三角矩阵，倒叙遍历，不断减去前面的解乘以系数，便可得到所有的解 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int N = 110;const double eps = 1e-6;int n;double a[N][N];int gauss()&#123; int c, r; for(c = 0, r = 0; c &lt; n; c++)&#123;//枚举每一列 int t = r; for(int i = r; i &lt; n; i++) if(fabs(a[i][c]) &gt; fabs(a[t][c]))//找到这一列绝对值最大的一行 t = i; if(fabs(a[t][c]) &lt; eps)continue; //如果全为0，则略过 for(int i = c; i &lt; n + 1; i++)swap(a[t][i], a[r][i]);//将第t行与第r行交换 for(int i = n; i &gt;= c; i--)a[r][i] /= a[r][c];//将首元素系数化为1 for(int i = r + 1; i &lt; n; i++) //将第r + 1行以下的第c列的元素化为0 if(fabs(a[i][c]) &gt; eps) for(int j = n; j &gt;= c; j--) //每一列都要相减 a[i][j] -= a[r][j] * a[i][c]; r++; &#125; if(r &lt; n)&#123; //如果r &lt; n, r + 1 行一下的系数都为0 for(int i = r; i &lt; n; i++) if(fabs(a[i][n]) &gt; eps) //a[i][n]不为0，说明0 = a[i][n]，无解 return 2; return 1; //否则有无穷多解 &#125; for(int i = n - 1 ; i &gt;= 0; i--) //否则有唯一解 for(int j = i + 1; j &lt; n; j++) //倒叙遍历，减去xi之前的x(i + j) * 系数，变得到了xi的解 a[i][n] -= a[j][n] * a[i][j]; return 0;&#125;int main()&#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt;= n; j++) cin &gt;&gt; a[i][j]; int t = gauss(); if(t == 0)&#123; for(int i = 0; i &lt; n; i++)printf(\"%.2lf\\n\", a[i][n]); &#125; else if(t == 1)puts(\"Infinite group solutions\"); else puts(\"No solution\"); return 0;&#125; 二.高斯消元解异或线性方程组题目描述 输入一个包含n个方程n个未知数的异或线性方程组。 方程组中的系数和常数为0或1，每个未知数的取值也为0或1。 求解这个方程组. 异或线性方程组示例如下： 1234M[1][1]x[1] ^ M[1][2]x[2] ^ … ^ M[1][n]x[n] = B[1]M[2][1]x[1] ^ M[2][2]x[2] ^ … ^ M[2][n]x[n] = B[2]…M[n][1]x[1] ^ M[n][2]x[2] ^ … ^ M[n][n]x[n] = B[n] 其中“^”表示异或(XOR)，M[i][j]表示第i个式子中x[j]的系数，B[i]是第i个方程右端的常数，取值均为0或1。 输入格式 第一行包含整数n。 接下来n行，每行包含n+1个整数0或1，表示一个方程的n个系数以及等号右侧的常数。 输出格式 如果给定线性方程组存在唯一解，则输出共n行，其中第i行输出第i个未知数的解。 如果给定线性方程组存在无数解，则输出“Infinite group solutions”。 如果给定线性方程组无解，则输出“No solution”。 数据范围 1≤n≤100 输入样例： 3 1 1 0 10 1 1 01 0 0 1 输出样例： 1 00 题解： 思路跟第一题一样，代码稍微改改就行 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int N = 110;int n;int a[N][N];int gauss()&#123; int c, r; for(c = 0, r = 0; c &lt; n; c++)&#123;//枚举每一列 int t = r; for(int i = r; i &lt; n; i++) if(a[i][c] &gt; a[t][c])//找到这一列绝对值最大的一行 t = i; if(!a[t][c])continue; //如果全为0，则略过 for(int i = c; i &lt; n + 1; i++)swap(a[t][i], a[r][i]);//将第t行与第r行交换 for(int i = r + 1; i &lt; n; i++) //将第r + 1行以下的第c列的元素化为0 if(a[i][c]) for(int j = n; j &gt;= c; j--) //每一列都要异或 a[i][j] ^= a[r][j]; r++; &#125; if(r &lt; n)&#123; //如果r &lt; n, r + 1 行一下的系数都为0 for(int i = r; i &lt; n; i++) if(a[i][n]) //a[i][n]不为0，说明0 = a[i][n]，无解 return 2; return 1; //否则有无穷多解 &#125; for(int i = n - 1 ; i &gt;= 0; i--) for(int j = i + 1; j &lt; n; j++) a[i][n] ^= a[j][n] * a[i][j]; return 0;&#125;int main()&#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt;= n; j++) cin &gt;&gt; a[i][j]; int t = gauss(); if(t == 0)&#123; for(int i = 0; i &lt; n; i++)printf(\"%d\\n\", a[i][n]); &#125; else if(t == 1)puts(\"Infinite group solutions\"); else puts(\"No solution\"); return 0;&#125;","path":"2019/07/09/数论/高斯消元解线性方程组/","date":"07-09","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"高斯消元","slug":"高斯消元","permalink":"http://zhumenger.top/tags/高斯消元/"}]},{"title":"JS基础之标识符、数据类型","text":"一.标识符1.在JS中所有的可以由我们自主命名的都可以称为标识符 2.命名规则： 1.标识符中可以含有字母、数字、下划线和$。2.标识符不能以数字开头3.标识符不能是关键字 4.标识符一般采用驼峰命名法： 首字母小写，每个单词的开头字母大写，其余字母小写 如: var helloWorld = 123； 二.数据类型数据类型指的是字面量的类型，一共有6种 String 字符串 Number 数值 Boolean 布尔值 Null 空值 Undefined 未定义 Object 对象 前5个为基本数据类型，Object属于引用数据类型 1.字符串声明: 1234567&lt;script type=\"text/javascript\"&gt; var str = \"hello\"; //输出字面量 字符串str alert(\"str\"); //输出变量str alert(str);&lt;/script&gt; 1&gt;.单引号，双引号都可以，但必须配对，不能混淆 2&gt;.引号不能嵌套，双引号里不能放双引号，单引号里不能放单引号 3&gt;.双引号里可以嵌套单引号 4&gt;.如果想要任意嵌套，必须加入转义字符 转义字符： 在字符串中可以用\\作为转义字符 如\\ “表示 单引号， \\ n 表示换行， \\ \\ 表示斜杠 2.数值1&gt;.声明 123&lt;script type=\"text/javascript\"&gt; var a = 123;&lt;/script&gt; 2&gt;.可以用 typeof 来检查一个变量的类型 123456&lt;script type=\"text/javascript\"&gt; var a = 123; console.log(typeof a);//输出“number”类型 var b = \"123\" console.log(typeof b);//输出“string”类型&lt;/script&gt; 3&gt;.输出数字的最大值、最小值 1234567&lt;script type=\"text/javascript\"&gt; //输出最大值 console.log(Number.MAX_VALUE); //输出最小值 console.log(Number.MIN_VALUE); //如果使用的Number表示的数字超过了最大值,则会返回一个Infinity表示无穷&lt;/script&gt; 4&gt;.NAN 是一个特殊的数字， 表示Not A Number 1234567&lt;script type=\"text/javascript\"&gt; var a = \"abc\" * \"abc\"; console.log(a); //输出NAN， console.log(typeof a); //输出number&lt;/script&gt; 5&gt;.如果JS进行浮点元素，可能得到一个不确定的结果 12345&lt;script type=\"text/javascript\"&gt; var a = 0.1 + 0.2; comsole.log(a); //输出0.3000000000000004&lt;/script&gt; 3.布尔值 Boolean1234567891011&lt;script type=\"text/javascript\"&gt; /* *Boolean 布尔值 * 布尔值只有俩个 * true -表示真 * false -表示假 */ var bool = false; console.log(bool)//输出false console.log(typeof bool)//输出boolean&lt;/script&gt; 4.Null12345678910&lt;script type=\"text/javascript\"&gt; /* * Null类型只有一个,就是null * null表示一个为空的对象 * 使用typeof检查null值时，返回object */ var a = null; console.log(a);//输出null console.log(typeof a);//输出//object &lt;/script&gt; 5.Undefined12345678&lt;script type=\"text/javascript\"&gt; /* * Undefined的类型只有一个，就是undefined * 当声明一个变量未赋值时，就是undefined */ var a; console.log(a)//输出undefined &lt;/script&gt;","path":"2019/07/08/JavaScirpt/JS基础之标识符、数据类型/","date":"07-08","excerpt":"","tags":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/tags/JavaScirpt/"}]},{"title":"扩展欧几里得算法","text":"一.扩展欧几里得算法裴蜀定理 对于任意的整数a, b，存在一对整数 x，y，满足ax + by = gcd(a, b). 题目描述 给定n对正整数ai,bi，对于每对数，求出一组xi,yi，使其满足ai∗xi+bi∗yi=gcd(ai,bi)。 输入格式 第一行包含整数n。 接下来n行，每行包含两个整数ai,bi。 输出格式 输出共n行，对于每组ai,bi，求出一组满足条件的xi,yi，每组结果占一行。 本题答案不唯一，输出任意满足条件的xi,yi均可。 数据范围 1≤n≤1051≤ai,bi≤2∗109 输入样例： 2 4 68 18 输出样例： -1 1-2 1 代码如下： 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;typedef long long int ll;ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y)&#123; if(b == 0)&#123; x = 1; y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x ; //y表示b的系数 return d;&#125;int main()&#123; int n; ll a, b, x, y; cin &gt;&gt; n; while(n--)&#123; scanf(\"%lld%lld\", &amp;a, &amp;b); ll d = exgcd(a, b, x, y); printf(\"%lld %lld\\n\", x, y); &#125; return 0;&#125; 二.线性同余方程题目描述给定n组数据ai,bi,mi，对于每组数求出一个xi，使其满足ai∗xi≡bi(mod mi)，如果无解则输出impossible。 输入格式第一行包含整数n。 接下来n行，每行包含一组数据ai,bi,mi。 输出格式输出共n行，每组数据输出一个整数表示一个满足条件的xi，如果无解则输出impossible。 每组数据结果占一行，结果可能不唯一，输出任意一个满足条件的结果均可。 输出答案必须在int范围之内。 数据范围1≤n≤10^51≤ai,bi,mi≤2∗10^9 输入样例： 2 2 3 64 3 5 输出样例： impossible7 题解： 对于a * x % m = b 等价于 a * x - b 是m的倍数，不妨设为 -y 倍。于是，该方程可以改写为 a * x + m * y = b。 这样就变成了欧几里得算法，只有 b 为 gcd(a, m) 的倍数的时候，方程才有解，带公式即可 代码如下： 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;typedef long long int ll;ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y)&#123; if(b == 0)&#123; x = 1; y = 0; return a; &#125; ll d = exgcd(b, a % b, y ,x); y -= a / b * x; return d;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; ll a, b, c; ll x, y; scanf(\"%lld %lld %lld\", &amp;a, &amp;b, &amp;c); ll d = exgcd(a, c, x, y); if(b % d == 0) printf(\"%lld\\n\", x *(b / d) % c); //x 乘以倍数 % c else puts(\"impossible\"); &#125; return 0;&#125;","path":"2019/07/08/数论/扩展欧几里得算法/","date":"07-08","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"http://zhumenger.top/tags/扩展欧几里得/"}]},{"title":"JS基础之基本语法、字面量和变量","text":"一.基本语法1.注释 123456&lt;script type=\"text/javascript\"&gt; //单行注释 /* 多行注释，注释中的内容不会被执行 */&lt;/script&gt; 2.JS中严格区分大小写 12alert(\"hello world\");//可以执行Alert(\"hello world\")；//会报错 3.分号表示一个语句的结束. 如果不写分号，浏览器会自动添加，但是会消耗一些系统资源 而且有点时候，浏览器会加错分号，所以在开发中分号必须写 4.JS会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化 二.字面量和变量1.字面量 都是一些不可改变的值，比如：1 2 3 4 5 字面量可以直接使用，但是我们一般都不会直接使用字面量 2.变量 可以用来保存字面量，而且变量的值可以任意改变 所以在开发中都是通过变量取保存一个字面量，而很少直接用到字面量 3.变量的使用 123456//在JS中使用var关键字来声明一个变量var a;//为变量赋值a = 123；//向页面输出adocument.write(a)","path":"2019/07/07/JavaScirpt/JS基础之基本语法、字面量和变量/","date":"07-07","excerpt":"","tags":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/tags/JavaScirpt/"}]},{"title":"JS基础之编写位置","text":"1.可以将JS的代码写到标签的属性中，当点击按钮时执行 1&lt;button onclick = \"alert('讨厌，你点我干嘛');\"&gt;点我一下&lt;/button&gt; 2.可以将JS代码写在href属性中，这样点击超链接时，会执行JS代码 1&lt;a href=\"javascript:alert('让你点你就点');\"&gt;你也点我一下&lt;/a&gt; 虽然可以写在标签的属性中，但是他们属于结构与行为耦合不方便维护，不推荐使用 3.可以将JS写在script标签中,打开网页时直接运行 123&lt;script type=\"text/javascript\"&gt; alert(\"我是script标签中的代码\");&lt;/script&gt; 4.可以将JS代码写到外部JS文件中，然后通过script标签引入,用src引入路径 1&lt;script type=\"text/javascript\" src=\"script.js\"&gt;&lt;/script&gt; script标签一旦引入外部文件，就不能编写代码了，即使编写了代码，编译器也会忽略","path":"2019/07/07/JavaScirpt/JS基础之编写位置/","date":"07-07","excerpt":"","tags":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/tags/JavaScirpt/"}]},{"title":"JS基础之Hello World","text":"输出语句1.所有的JS代码都要放到script标签里 2.alert(）：可以控制浏览器发出一个警告框 123&lt;script type=\"text/javascript\"&gt; alert(\"这是我的第一行JS代码\");&lt;/script&gt; 效果如下： 3.document.write()可以向body中输出一个内容 123&lt;script type=\"text/javascript\"&gt; document.write(\"看我出不出来\");&lt;/script&gt; 4.console.log()可以向控制台输出一个内容 123&lt;script type=\"text/javascript\"&gt; console.log(\"你猜猜我在哪\");&lt;/script&gt; 效果如下：","path":"2019/07/07/JavaScirpt/JS基础之Hello-World/","date":"07-07","excerpt":"","tags":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/tags/JavaScirpt/"}]},{"title":"快速幂","text":"一.快速幂快速幂问题（求a^b）: 1.我们都知道当指数为偶数的时候，对于a ^b，可以变为(a ^ 2) ^ (b/2)。2.而当指数为奇数的时候，对于a ^ b，可以化简为a * (a ^ (b-1))，然后即可以化简为a * ((a ^ 2) ^ ((b-1)/2))3.如此我们便可知道 如果b为奇数，则将b减一除二，将一个a取到外面，同时对里面的a平方。4.如果b为偶数，则直接除二，同时对a平方。 若b为7，a为2。则a变为4，b变为3，ans变为2 * (2 ^ 2) ^ 3。然后继续向后运，(注意此时a为4)，a变为16，b变为1，ans变为2* 4*(2 ^ 2 ^ 2) ^ 1。结果为128。 若b为10，a为2。则a变为4，b变为5，ans变(2 ^ 2) ^ 5。然后继续向后运，(注意此时a为4)，a变为16，b变为2，ans变为4(2 ^ 2 ^ 2) ^2。再之后(注意此时a为16)，a变为256，b变为1，ans变为4(2 ^ 2 ^ 2 ^ 2) ^ 1。结果为1024 快速幂取余 代码如下： 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;typedef long long int ll;ll a, b, c;void solve()&#123; ll ans = 1; while(b)&#123; if(b &amp; 1)ans = ans * a % c; //如果b为奇数 b &gt;&gt;= 1; //b除以2 a = a * a % c; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; solve(); &#125; return 0;&#125; 二.快速幂求逆元题目描述 给定n组ai,pi，其中pi是质数,求ai模pi的乘法逆元，若逆元不存在则输出impossible。 输入格式 第一行包含整数n。 接下来n行，每行包含一个数组ai,pi，数据保证pi是质数。 输出格式 输出共n行，每组数据输出一个结果，每个结果占一行。 若ai模pi的乘法逆元存在，则输出一个整数，表示逆元，否则输出impossible。 数据范围 1≤n≤10^51≤ai,pi≤2∗10^9 输入样例： 3 4 38 56 3 输出样例： 1 2impossible 什么是逆元** 若b与m互质，对于a/b(a是b的倍数) % m，可以找到一个数x使得ax % m = a/b % m,那么我们称x为b%m的逆元 费马定理： 若p为质数，则b^(p - 1) % p == 1。 题解： 这道题用到了费马定理，b * b^(p - 2) % p == 1,所以只需求b^(p - 2) % p即可，那么这道题便转化为了一道快速幂的问题 代码如下： 12345678910111213141516171819202122232425//费马定理：若p为质数，则a^(p -1)% p == 1,可得a * a^(p - 2) % p == 1，这道题求a^(p - 2) % p 便是a的逆元#include&lt;iostream&gt;using namespace std;typedef long long int ll;ll ksm(ll a, ll b, ll c)&#123; ll ans = 1; while(b)&#123; if(b &amp; 1)ans = ans * a % c; b &gt;&gt;= 1; a =a * a % c; &#125; return ans;&#125;int main()&#123; ll t, a, b; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; a &gt;&gt; b; if(a % b == 0)cout &lt;&lt; \"impossible\" &lt;&lt; endl;//若a是p的倍数，则不存在逆元 else cout &lt;&lt; ksm(a, b - 2, b) &lt;&lt;endl; &#125; return 0;&#125;","path":"2019/07/07/数论/快速幂/","date":"07-07","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"快速幂","slug":"快速幂","permalink":"http://zhumenger.top/tags/快速幂/"}]},{"title":"欧拉函数","text":"一.欧拉函数什么是欧拉函数： 1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)。 欧拉函数的通式： φ(n)=n(1-1/p1)(1-1/p2)(1-1/p3)(1-1/p4)…..(1-1/pn),其中p1, p2……pn为n的所有质因数，n是不为0的整数。φ(1)=1（唯一和1互质的数就是1本身）。 欧拉定理： 若a与n互质，则a^φ(n) % n == 1 求欧拉函数的代码如下： 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;typedef long long int ll;void solve(ll n)&#123; ll ans = n; for(int i = 2; i &lt;= n / i; i++)&#123; if(n % i == 0)&#123; ans = ans / i * (i - 1);//如果i为n的质因数，则带入公式 while(n % i == 0)n /= i;//分解质因数 &#125; &#125; if(n &gt; 1)ans = ans / n * (n - 1); cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; ll n, t; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; n; solve(n); &#125; return 0;&#125; 二.. 筛法求欧拉函数 给定一个正整数n，求1~n中每个数的欧拉函数之和。 输入格式 共一行，包含一个整数n。 输出格式 共一行，包含一个整数，表示1~n中每个数的欧拉函数之和。 数据范围 1≤n≤10^6 输入样例： 6 输出样例： 12 思路： 在线性筛法的过程得到每个数的欧拉函数 1.如果i为质数，则i之前的数都与i互质,所以φ(i) = i - 1, 2.如果i % prime[j] == 0,φ(prime[j] * i) = prime[j] * ouler[i]; 3.若果i % prime[j] != 0, φ(prime[j] * i) = ouler[i] * (prime[j] - 1) 代码如下： 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int prime[N], ouler[N], cnt;typedef long long int ll;bool vis[N];void get_ouler(int n)&#123; ouler[1] = 1; //φ(1) = 1,与1互质的数为1 for(int i = 2; i &lt;= n; i++)&#123; if(!vis[i])&#123; //如果是质数 prime[cnt++] = i; ouler[i] = i - 1;//φ(i) = i - 1 &#125; for(int j = 0; j &lt; cnt &amp;&amp; prime[j] &lt;= n / i; j++)&#123; vis[prime[j] * i] = true; if(i % prime[j] == 0)&#123; ouler[prime[j] * i] = prime[j] * ouler[i]; break; &#125; ouler[prime[j] * i] = ouler[i] * (prime[j] - 1); &#125; &#125; ll ans = 0; for(int i = 1; i &lt;= n; i++) ans += ouler[i]; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; int n; cin &gt;&gt; n; get_ouler(n); return 0;&#125;","path":"2019/07/07/数论/欧拉函数/","date":"07-07","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"http://zhumenger.top/tags/欧拉函数/"}]},{"title":"约数","text":"算术基本定理任何一个大于1的自然数 N ，如果N不为质数，都可以唯一分解成有限个质数的乘积 N = P1^a1 * P2^a2 ….Pn^an , 这里 P1&lt;P2&lt;….&lt;Pn均为质数，其诸指数 ai 是正整数。 定理应用（1）一个大于1的正整数N，如果它的标准分解式为： N = P1^a1 * P2^a2 ….Pn^an ，那么它的正因数个数为 φ(N) = (1 + a1)(1 + a2)(1 +a3)。 （2） 它的全体正因数之和为φ(N) = (1 + p1 + p1^2 + …+ p1^a1)(1 + p2 + p2^2 + … + p2^a2)…(1 + pn + pn^2 + … + pn^an). 一.约数个数题目描述 给定n个正整数ai，请你输出这些数的乘积的约数个数，答案对109+7取模。 输入格式 第一行包含整数n。 接下来n行，每行包含一个整数ai。 输出格式 输出一个整数，表示所给正整数的乘积的约数个数，答案需对109+7109+7取模。 数据范围 1≤n≤1001≤ai≤2∗10^9 输入样例： 3 26 8 输出样例： 12 求n个数乘积的约数的个数，用到了定理（1）的知识，代码如下： 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;unordered_map&gt;using namespace std;unordered_map&lt;int, int&gt; mp;typedef long long int ll;const int mod = 1e9 + 7;void solve(ll n)&#123; for(int i = 2; i &lt;= n / i; i++)&#123; while(n % i == 0)&#123; n /= i; mp[i]++; &#125; &#125; if(n &gt; 1)mp[n]++;//先分解所有的质因子&#125;int main()&#123; ll n, t; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt;n; solve(n); &#125; ll ans = 1; for(auto mps : mp)&#123; ans = ans * (mps.second + 1) % mod;//代公式即可 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 二.约数之和 给定n个正整数ai，请你输出这些数的乘积的约数之和，答案对109+7取模。 输入格式 第一行包含整数n。 接下来n行，每行包含一个整数ai。 输出格式 输出一个整数，表示所给正整数的乘积的约数之和，答案需对109+7取模。 数据范围 1≤n≤1001≤ai≤2∗10^9 输入样例： 3 26 8 输出样例： 252 求n个数乘积的约数之和，用到了定理（2）的知识，代码如下： 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;unordered_map&gt;using namespace std;const int mod = 1e9 + 7;typedef long long int ll;unordered_map&lt;int, int &gt;mp;void solve(ll n)&#123; for(ll i = 2; i &lt;= n / i; i++)&#123; while(n % i == 0)&#123; n /= i; mp[i]++; &#125; &#125; if(n &gt; 1)mp[n]++;//分解所有的质因数&#125;int main()&#123; int t; ll n; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; n; solve(n); &#125; ll ans = 1; for(auto mps : mp)&#123; ll t= 1; ll x = mps.first, a = mps.second; while(a--)t = (t * x + 1) % mod; //带公式即可 ans = ans * t % mod; &#125; cout &lt;&lt;ans &lt;&lt; endl;&#125;","path":"2019/07/07/数论/约数/","date":"07-07","excerpt":"","tags":[{"name":"数论，约数","slug":"数论，约数","permalink":"http://zhumenger.top/tags/数论，约数/"}]},{"title":"二分图","text":"二分图1.定义： 二分图是指将图中的点分为俩个集合X和Y，满足所有的边仅在俩个集合之间，并且俩个集合中没有边，即X中的点只与Y中的点相连，如下图所示，这样的图称为二分图。 2.性质： 当且仅当图中不含奇数环，即所有的环的边数为偶数。这样的图一定是二分图。 3.判定： 染色法判定二分图原理： 首先任意取出一个顶点进行染色,和该节点相邻的点有三种情况: 1.未染色 那么继续染色此节点(染色为另一种颜色) 2.已染色但和当前节点颜色不同 跳过该点 3.已染色并且和当前节点颜色相同 返回失败(该图不是二分图) 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int h[N], e[N], ne[N], idx;int n, m, color[N];//color表示哪些点已经被染了色void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;bool dfs(int x, int c)//c表示染色的种类&#123; color[x] = c; for(int i = h[x]; i != -1; i = ne[i])&#123; int j = e[i]; if(color[j] == c)return false;//如果与i相连的点与i染成了相同的颜色，返回false else if(color[j] == 0 &amp;&amp; !dfs(j, -c))return false; //如果该点还没有被染色，并且染成相反的染色失败了的话，返回false &#125; return true;&#125;int main()&#123; scanf(\"%d%d\", &amp;n, &amp;m); memset(h, -1, sizeof h); while(m--)&#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); add(a, b); add(b, a); &#125; bool flag = false; for(int i = 1; i &lt;= n; i++)&#123;//遍历每一个点 if(color[i] == 0)&#123;//如果没有被染色 if(!dfs(i, 1))&#123;// 判断是否能被染色 flag = true; break; &#125; &#125; &#125; if(flag)puts(\"No\"); else puts(\"Yes\"); return 0;&#125; 二分图的最大匹配什么是匹配： 给定一个二分图G，在G的一个子图M中， M的边集{E}中的任意两条边都不交汇于同一个结点，则称M是一个匹配。 图中加粗的边是数量为2的匹配。 二分图的最大匹配 ：选择匹配边数最多的一个子图称为图的最大匹配 如下图所示，加粗的边数最多为3，所以该子图为二分图的最大匹配 如何求二分图的最大匹配： 匈牙利算法 假设左边的集合都为男生，右边的集合都为女生，让我们求出最多有多少对情侣能够配对成功。 对于每个男生，遍历他所有有好感度的女生，有俩种情况： 1.如果该女生是单身，则匹配成功 2.否则我们寻找与该女生的配对的那个男生，看看这个男生是否能和其他的女生配对，如果可以的话，让这个男与其备胎匹配，空出来的这个女生便可以与当前的这个男生配对成功。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e5 + 10;int h[N], e[N], ne[N], idx;int match[N];//一个映射关系:表示妹子与谁配了对bool vis[N];//表示哪些妹子已经遍历过了int n1, n2, m;void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;bool Find(int x)&#123; for(int i = h[x]; i != -1; i = ne[i])&#123;//遍历该男生所有有好感度的女生 int j = e[i]; if(!vis[j])&#123;//如果该女生还没有被当前男生询问过 vis[j] = true;//已经被询问过 if(match[j] == 0 || Find(match[j]))&#123;//如果该女生还没有配对或者与该女生配对的那个男生可以跟另 match[j] = x; //一个女生配对的话，该女生便可以与当前的这个男生配对。 return true;//返回true &#125; &#125; &#125; return false;//否则，返回false&#125;int main()&#123; cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m; memset(h, -1, sizeof h); while(m--)&#123; int a, b; cin &gt;&gt; a &gt;&gt; b; add(a, b); &#125; int ans = 0;//表示成功匹配了对少对 for(int i = 1; i &lt;= n1; i++)&#123; memset(vis, false, sizeof vis);//对于每一个男生，所有的妹子还没有询问过，所以这里要初始化 if(Find(i))ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","path":"2019/06/24/图论/二分图/二分图/","date":"06-24","excerpt":"","tags":[{"name":"图论","slug":"图论","permalink":"http://zhumenger.top/tags/图论/"},{"name":"二分图","slug":"二分图","permalink":"http://zhumenger.top/tags/二分图/"}]},{"title":"最小生成树","text":"最小生成树题目描述 给出无向图中M个节点间N条边的权值。求一个使得所有点连通的子图,要求图内的边权和最小 输入格式 第一行包含两个整数n和m。 接下来m行，每行包含三个整数u，v，w，表示点u和点v之间存在一条权值为w的边。 输出格式 共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。 数据范围 1≤n≤5001≤n≤500,1≤m≤1051≤m≤105,图中涉及边的边权的绝对值均不超过10000。 输入样例： 4 51 2 11 3 21 4 32 3 23 4 4 输出样例： 6 一.克鲁斯卡尔算法(kruskal)算法定义： 假设 WN=(V,{E}) 是一个含有 n 个顶点的连通图，那么我们把它定义为含有 n 棵树的一个森林。每次从图的边集 E 中选取一条权值最小的边，若该条边的两个顶点分属不同的树，就将这两个顶点分别所在的两棵树合成一棵树，表示这俩个点已经连通；若该条边的两个顶点已落在同一棵树上，则直接跳过，因为前面已经选了一个更小的权值的边使得俩个点连在了一起。然后继续选择下一条最小的边加入到集合里面。依次类推，直至森林中只有一棵树，也即子图中含有 n-1条边为止。 kruskal算法流程: 1.建立并查集，每个点各自构成一个集合2.把所有的边按照权值从小到大排序，一次扫描每一条边3.若x，y属于同一个集合，则忽略这条边，继续扫描下一条边4.否则，合并x，y所在的集合，并将边权值累加到答案中 时间复杂度：O(mlogm) 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e6 + 10, INF = 0x3f3f3f3f;int f[N];struct p&#123; //存储所有的边 int a, b, c;&#125;arr[N];int n, m;bool cmp(p a, p b) //按照边权值从小到达排序&#123; return a.c &lt; b.c;&#125;int Find(int x) //找到x的根节点&#123; if(x != f[x])f[x] = Find(f[x]); return f[x];&#125;int main()&#123; int cnt = 0, ans = 0; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)f[i] = i; //初始化为n个集合 for(int i = 0; i &lt; m; i++) cin &gt;&gt; arr[i].a &gt;&gt; arr[i].b &gt;&gt; arr[i].c; sort(arr, arr + m, cmp); for(int i = 0; i &lt; m; i++)&#123; int x = Find(arr[i].a); int y = Find(arr[i].b); if(x != y)&#123; //如果不属于同一个集合 f[x] = y; cnt++; //边数++ ans += arr[i].c; //累加边权值 &#125; if(cnt == n - 1)break; &#125; if(cnt == n - 1)cout &lt;&lt; ans &lt;&lt; endl; else cout &lt;&lt; \"impossible\" &lt;&lt;endl; return 0;&#125; 二.prime算法算法简介： 首先维护一个集合，找到集合之外的距离这个集合最近的点，将这个点加入集合，并用这个点去更新其他点到集合的距离，这样得出来的生成树一定是最小的。算法思想跟dijstra算法类似。 时间复杂度：O(n^2) 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 510, INF = 0x3f3f3f3f;int n, m;int arr[N][N], dis[N];bool vis[N];void prime()&#123; memset(dis, INF, sizeof dis); int ans = 0; for(int i = 0; i &lt; n; i++)&#123; int t = -1; for(int j = 1; j &lt;= n; j++) if(!vis[j] &amp;&amp; (t == -1 || dis[t] &gt; dis[j]))//找到集合外的点到该集合距离最短的点 t = j; //用t记录该下标 if(i &amp;&amp; dis[t] == INF)&#123; //如果没有找到距离集合最短的点，说明这个图是不连通的 puts(\"impossible\"); return ; &#125; if(i)ans += dis[t]; //不断的加上该边权值 vis[t] = true; //表示该点已经加入到集合里了 //用t不断更新其他的点到集合的距离 for(int j = 1; j &lt;= n; j++)dis[j] = min(dis[j], arr[t][j]); &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; memset(vis, false, sizeof vis); cin &gt;&gt; n &gt;&gt; m; int a, b, c; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) arr[i][j] = i == j ? 0 : INF; while(m--)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; arr[a][b] = arr[b][a] = min(arr[a][b], c); &#125; prime(); return 0;&#125; 2.prime算法堆优化 跟dijstra算法一样，再找集合外的点到该集合距离最小的点时用堆做了一个优化。时间复杂度为：O(mlogn) 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;int arr[505][505];int dis[505];bool vis[505];typedef pair&lt;int ,int &gt; p;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt;= n; i++) for(int j = 0; j &lt;= n; j++) arr[i][j] = i == j ? 0 : INF; memset(dis, INF, sizeof dis); memset(vis, false, sizeof vis); int a, b, c; for(int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; arr[a][b] = arr[b][a] = min(arr[a][b], c); &#125; priority_queue&lt;p, vector&lt;p&gt;, greater&lt;p&gt; &gt; q; int ans = 0, sum = 0; dis[1] = 0; q.push(&#123;0, 1&#125;); while(q.size()) &#123; p cur = q.top(); q.pop(); int u = cur.second; if(vis[u])continue; vis[u] = true; sum++; //表示该点已经加入到集合当中 ans += dis[u];//加上该边权值 for(int i = 1; i &lt;= n; i++)&#123; //用该点不断更新集合外的点到集合的距离 if(!vis[i] &amp;&amp; dis[i] &gt; arr[u][i])&#123; dis[i] = arr[u][i]; q.push(&#123;dis[i], i&#125;); //如果该点被更新过，就加入到队列中去 &#125; &#125; &#125; if(sum == n)cout &lt;&lt; ans &lt;&lt; endl; //判断是否连通 else cout &lt;&lt; \"impossible\" &lt;&lt; endl; return 0;&#125;","path":"2019/06/24/图论/最小生成树/最小生成树/","date":"06-24","excerpt":"","tags":[{"name":"图论","slug":"图论","permalink":"http://zhumenger.top/tags/图论/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://zhumenger.top/tags/最小生成树/"}]},{"title":"编程俱乐部6月常规赛二题解","text":"编程俱乐部6月常规赛二题解一.魔法雪花 ** **题解： 字符串的最小表示法：每一个字符串都有一个字典序最小的表示，比较这俩个字符串的最小表示是否相等即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;stdio.h&gt;using namespace std;string s1, s2;int n;int get(string s) //获得最小字典序的起始下标&#123; int i = 0, j = 1; while(i &lt;= n &amp;&amp; j &lt;= n) &#123; int k = 0; while(k &lt; n &amp;&amp; s[i + k] == s[j + k])k++; if(k == n)break; if(s[i + k] &lt; s[j + k])&#123; j = j + k + 1; if(i == j)j++; &#125; else &#123; i = i + k + 1; if(i == j)i++; &#125; &#125; return min(i, j);&#125;bool cmp(int i, int j) //比较字符串是否相同&#123; for(int k = 0; k &lt; n; k++)&#123; if(s1[i + k] != s2[j + k])return false; &#125; return true;&#125;int main()&#123; cin &gt;&gt; s1 &gt;&gt; s2; n = s1.size(); s1 += s1; //长度增加2倍 s2 += s2; int l = get(s1); int r = get(s2); if(cmp(l, r))&#123; cout &lt;&lt; \"Yes\" &lt;&lt; endl; for(int i = l; i &lt; l + n; i++) printf(\"%c\", s1[i]); &#125; else cout &lt;&lt; \"No\" &lt;&lt; endl; return 0;&#125; 二.魔仙彩石 题解：单调栈的运用，如果栈首的元素与a[i]相加&gt;m，就不断的弹出元素，直到a[i]与栈首的和&lt;=m或栈中的元素为空，让ans+=q[t]求出答案。 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int a[20010], q[20010], t = 0;int main()&#123; int n, m; long long int ans =0; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; sort(a, a + n); for(int i = 0; i &lt; n; i++)&#123; while(t &gt; 0 &amp;&amp; a[i] + a[q[t]] &gt;m)t--; if(t &gt; 0)ans += q[t] + 1; //单调栈的性质，该下标之前的元素与a[i]相加都小于等于m q[++t] = i; //单调栈记录下标 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; *三黑暗法阵 * 题解：经典的水池问题，如果该点为1，则让它等于0，继续往上下左右遍历，记录最大的ans即可 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;const int N = 110;int a[N][N];int dx[] = &#123;1, 0, -1, 0&#125;;int dy[] = &#123;0, 1, 0, -1&#125;;int n, m, res;void dfs(int x, int y)&#123; res++; a[x][y] = 0; for(int i = 0; i &lt; 4; i++)&#123; int xx = x + dx[i]; int yy = y + dy[i]; if(xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; m &amp;&amp; a[xx][yy] == 1) dfs(xx, yy); &#125;&#125;int main()&#123; while(cin &gt;&gt; n &gt;&gt; m)&#123; if(n == 0 &amp;&amp; m == 0)break; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) cin &gt;&gt; a[i][j]; int ans = 0; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j ++)&#123; if(a[i][j] == 1)&#123; res = 0; dfs(i, j); ans = max(ans, res); &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 四.女王搬水泥 题解： 最小生成树的题，将每条路的建造的时间从小到大排个序，依次遍历，如果都联通了输出当前的时间，break;如果遍历完一遍还没有全部联通，则输出-1 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e6 + 10;int f[N];struct p&#123; int a; int b; int c;&#125;arr[N];int Find(int x)&#123; if(x != f[x])f[x] = Find(f[x]); return f[x];&#125;bool cmp(p a, p b)&#123; return a.c &lt; b.c;&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) f[i] = i; for(int i = 0; i &lt; m; i++) cin &gt;&gt; arr[i].a &gt;&gt; arr[i].b &gt;&gt; arr[i].c; sort(arr, arr + m, cmp); int ans = 0, res = 1; for(int i = 0; i &lt; m; i++)&#123; int x = Find(arr[i].a); int y = Find(arr[i].b); if(x != y)&#123; res++; //记录联通了几个点 f[x] = y; &#125; if(res == n)&#123; //全部联通就输出当前的时间 ans = arr[i].c; break; &#125; &#125; if(res == n)cout &lt;&lt; ans &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; return 0;&#125; 五.游ne娃子的取石子游戏 题解: 取三个最大的互质的数，得到的最小公倍数一定是最大的。如果n为奇数，三个最大的互质的数就是n, n - 1, n- 2。如果n为偶数， 需要判断一下n是否为3的倍数，如果不是，那么三个最大的互质的数就是n, n - 1, n - 3，如果是,那么三个最大的互质的数就是n - 1, n- 2， n - 3. 12345678910111213#include&lt;iostream&gt;using namespace std;int main()&#123; long long int n, ans; cin &gt;&gt; n; if(n % 2)cout &lt;&lt; n &lt;&lt; ' ' &lt;&lt; n - 1 &lt;&lt; ' ' &lt;&lt; n - 2 &lt;&lt; endl; else &#123; if(n % 3)cout &lt;&lt; n &lt;&lt; ' ' &lt;&lt; n - 1 &lt;&lt; ' ' &lt;&lt; n - 3 &lt;&lt; endl; else cout &lt;&lt; n - 1 &lt;&lt; ' ' &lt;&lt; n - 2 &lt;&lt; ' ' &lt;&lt; n - 3 &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/06/23/题解/编程俱乐部6月常规赛二题解/","date":"06-23","excerpt":"","tags":[{"name":"题解","slug":"题解","permalink":"http://zhumenger.top/tags/题解/"}]},{"title":"图论之最短路问题","text":"图论之最短路问题1.什么是最短路： 从某顶点出发，沿图的边到达另一顶点所经过的路径中，各边上权值之和最小的一条路径 2.常用的最短路算法： Dijkstra算法，Bellman-Ford算法，Floyd算法和SPFA算法 3.最短路所有算法的适用情况以及时间复杂度，如下表所示。 算法详解一.Dijkstra算法1.朴素版的Dijkstra 简介： 每次找到已知的能够到达的一条最短的路径，并用这条路径更新它能够到达的所有的点，这样得到的路径一定是最短的，假设有n个点，那么我们就需要遍历n - 1次找到n - 1个边，每次用得到的最短的边依次更新其他可以到达的点。所以时间复杂度为O(n^2) 适用条件： 求单源最短路，并且所有的边都为正数。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1010, INF = 0x3f3f3f3f;int arr[N][N], n, m; //arr用来存边bool vis[N]; //判断边是否已经被选过int d[N]; //存储到每个点的距离void dijstra()&#123; d[1] = 0;//起点距离为1 for(int i = 0; i &lt;n - 1; i++)&#123; //遍历n - 1次，找到至少n -1 条边 int t = -1; for(int j = 1; j &lt;= n; j++)&#123; if(!vis[j] &amp;&amp; (t == -1 || d[t] &gt; d[j])) //找到已知的距离起点最短的一条路 t = j; &#125; for(int j = 1; j &lt;= n; j++) //用这条路径不断的更新到其他的点 d[j] = min(d[j], d[t] + arr[t][j]); //取最小值 vis[t] = true; //表示该点已经被选过了 &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; memset(arr, INF, sizeof arr); //初始化 memset(vis, false, sizeof vis); memset(d, INF, sizeof d); int a, b, c; for(int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; arr[a][b] = min(arr[a][b], c); //有可能给你多条相同的，所以要取最短的那条 &#125; dijstra(); if(d[n] == INF)cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; d[n] &lt;&lt; endl; return 0;&#125; 2.堆优化的Dijkstra： 主要是针对朴素版找到距离最小的一条路径用堆做了一个优化，我们可以用堆来储存已经更新过的点，每次取出堆中的最小的一条边即可，堆的时间复杂度为O(1)，所以在时间上要优化不少。 存图方式： 如果n和m非常大的话，比如1 &lt;= n, m &lt;= 1000000.用数组的方式肯定是存不下的，所以我们一般要用到邻接表的存图方式。也有很多人用vector动态数组来存，但当数据非常大时，vector动态数组开拓空间花费的时间也是非常大的，有的题就专门卡vector，所以邻接表最常用的一种存图方式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N = 1e5 + 10, INF = 0x3f3f3f3f;typedef pair&lt;int, int &gt; p;int h[N], e[N], ne[N], idx, w[N];//邻接表，由n个单链表组成，w[idx]用来存边权值int dis[N], n, m;bool vis[N];//判断这条边是否被选过void add(int a, int b, int c) //建图&#123; e[idx] = b, w[idx] = c, ne[idx]= h[a], h[a] = idx++;&#125;void dijstra()&#123; dis[1] = 0;//起点的距离为0 priority_queue&lt;p, vector&lt;p&gt;, greater&lt;p&gt; &gt; q; //优先队列 q.push(&#123;0, 1&#125;); while(q.size())&#123; p t = q.top(); q.pop(); int u = t.second, d = t.first; if(vis[u])continue; vis[u] = true; for(int i = h[u]; i != -1; i = ne[i])&#123;//遍历每一条边 int j = e[i]; if(dis[j] &gt; d + w[i])&#123;//不断更新为最短距离 dis[j] = d + w[i]; q.push(&#123;dis[j], j&#125;);//放入到队列中 &#125; &#125; &#125;&#125;int main()&#123; memset(dis, INF, sizeof dis);//初始化 memset(vis, false, sizeof vis); memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m; int a, b, c; while(m--)&#123; cin &gt;&gt; a&gt;&gt; b &gt;&gt; c; add(a, b, c); &#125; dijstra(); if(dis[n] == INF)cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; dis[n] &lt;&lt;endl; return 0;&#125; 二.bellman-ford算法简介： 循环n次，每次遍历所有的边，遍历的同时，不断更新a到b的最短距离即dis[b] = min(dis[b], backup[a] + w)，循环完一遍后，得到的所有路径一定满足dis[b] &lt;= dis[a] + w[i] 适用条件： 可以用来判断是否存在负边，时间复杂度为O(nm)，一般情况下不会用到这个算法，常用来求有边数限制的最短路问题，用结构体存储所有的边即可， 代码如下： 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10, INF = 0x3f3f3f3f;int n, m, k;int dis[N], backup[N];struct p&#123; //结构体存边 int a, b, c;&#125;arr[N];void bellman_ford()&#123; memset(dis, INF, sizeof dis); dis[1] = 0; for(int i = 0; i &lt; k; i++)&#123; //限制条件为k条边 memcpy(backup, dis, sizeof dis); //防止出现连锁反应，所以这里的用backup将上一次的最 //短路备份一下 for(int j = 0; j &lt; m; j++)&#123;//遍历所有的边 int a = arr[j].a, b = arr[j].b, w = arr[j].c; dis[b] = min(dis[b], backup[a] + w);//更新 &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 0; i &lt; m; i++) cin &gt;&gt; arr[i].a &gt;&gt; arr[i].b &gt;&gt; arr[i].c; bellman_ford(); if(dis[n] &gt; INF / 2)cout &lt;&lt; \"impossible\" &lt;&lt; endl; //有可能有负权边，所以要大于INF/2 else cout &lt;&lt; dis[n] &lt;&lt; endl; return 0;&#125; 三.spfa算法简介： spfa算法是对bellman-ford算法的一个优化，要想dis[b]变小，前提一定是dis[a]变小了，所以我们用队列来存储已经更新过的点，再用该点不断去更新其他的点，原理跟dijstra算法类似 如何判断负环 用一个变量cnt[i]表示到达 i 这个点的最短路径中经过了多少条边，如果cnt[i] &gt;= n表示有至少经过了n条边，那么就说明至少多走了一条边，那么这条边一定是一个负环。 适用条件： 用来求最短路以及判断是否存在负环，时间复杂度为O(m) 1.spaf算法求最短路 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N = 1e6 + 10, INF = 0x3f3f3f3f;int h[N], e[N], ne[N], w[N], idx;//邻接表存图int n, m;int dis[N];bool vis[N]; //vis含义跟dijstra算法中的不太一样，在这里表示当前这个点是否在队列当中void add(int a, int b, int c)//建边&#123; e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;&#125;void spfa()&#123; memset(dis, INF, sizeof dis); dis[1] = 0; //起点距离为0 queue&lt;int&gt; q; q.push(1); //将1放入队列 while(q.size())&#123; int u = q.front(); q.pop(); vis[u] = false; //表示u不在这个队列中 for(int i = h[u]; i != -1; i = ne[i])&#123; //遍历所有能够到达的点 int v = e[i]; if(dis[v] &gt; dis[u] + w[i])&#123; //更新距离 dis[v] = dis[u] + w[i]; if(!vis[v])&#123; //如果不在队列中 q.push(v); //放入队列 vis[v] = true;//表示v已经在队列当中 &#125; &#125; &#125; &#125;&#125;int main()&#123; memset(h, -1, sizeof h);//初始化 memset(vis, false, sizeof vis); cin &gt;&gt; n &gt;&gt; m; int a, b, c; while(m--)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); &#125; spfa(); if(dis[n] == INF)cout &lt;&lt; \"impossible\" &lt;&lt; endl; else cout &lt;&lt; dis[n] &lt;&lt; endl;&#125; 2.spfa判断是否存在负环 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N = 1e6 + 10, INF = 0x3f3f3f3f;int h[N], e[N], ne[N], w[N], idx;int dis[N], cnt[N]; //cnt[i]表示到达i这个点经过了多少条边bool vis[N];int n, m;void add(int a, int b, int c)&#123; e[idx] = b, w[idx]= c, ne[idx] = h[a], h[a] = idx++;&#125;bool spfa()&#123; queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i++)&#123;//因为不知道负环出现在哪一个起点，所以要将所有的点放入到队列中 vis[i] = true; q.push(i); &#125; while(q.size())&#123; int u = q.front(); q.pop(); vis[u] = false; for(int i = h[u]; i != -1; i = ne[i])&#123; int v = e[i]; if(dis[v] &gt; dis[u] + w[i])&#123; dis[v] = dis[u] +w[i]; cnt[v] = cnt[u] + 1; //边数+1 if(cnt[v] &gt;= n)return true; //如果大于n说明一定存在负环 if(!vis[v])&#123; q.push(v); vis[v] = true; &#125; &#125; &#125; &#125; return false;&#125;int main()&#123; memset(dis, INF, sizeof dis); memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m; int a, b, c; while(m--)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); &#125; if(spfa())puts(\"Yes\"); else puts(\"No\"); return 0;&#125; 四.floyd算法简介： 从任意节点A到任意节点B的最短路径不外乎2种可能，1是直接从A到B，2是从A经过若干个节点到B，所以，我们假设dist(AB)为节点A到节点B的最短路径的距离，对于每一个节点K，我们检查dist(AK) + dist(KB) &lt; dist(AB)是否成立，如果成立，证明从A到K再到B的路径比A直接到B的路径短，我们便设置 dist(AB) = dist(AK) + dist(KB)，这样一来，当我们遍历完所有节点K，dist(AB)中记录的便是A到B的最短路径的距离。 适用条件 能求出任意俩条边的最短路，时间复杂度为O(n^3) 代码如下： 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;const int N = 210, INF = 0x3f3f3f3f;int arr[N][N];int main()&#123; int n ,m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) arr[i][j] = i == j ? 0 : INF; //初始化 int a, b, c; for(int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; arr[a][b] = min(arr[a][b], c); &#125; //floyd算法核心 for(int k = 1; k &lt;= n; k++) for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) arr[i][j] = min(arr[i][j], arr[i][k] + arr[k][j]); while(k--)&#123; cin &gt;&gt; a &gt;&gt; b; if(arr[a][b] &gt; INF / 2)puts(\"impossible\");//可能有负环，所以这里是大于INF/2 else cout &lt;&lt; arr[a][b] &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/06/23/图论/最短路/图论之最短路问题/","date":"06-23","excerpt":"","tags":[{"name":"图论","slug":"图论","permalink":"http://zhumenger.top/tags/图论/"},{"name":"最短路问题","slug":"最短路问题","permalink":"http://zhumenger.top/tags/最短路问题/"}]},{"title":"八数码(bfs)","text":"在一个3×3的网格中，1~8这8个数字和一个“X”恰好不重不漏地分布在这3×3的网格中。 例如： 1 2 3X 4 67 5 8 在游戏过程中，可以把“X”与其上、下、左、右四个方向之一的数字交换（如果存在）。 我们的目的是通过交换，使得网格变为如下排列（称为正确排列）： 1 2 34 5 67 8 X 例如，示例中图形就可以通过让“X”先后与右、下、右三个方向的数字交换成功得到正确排列。 交换过程如下： 1 2 3 1 2 3 1 2 3 1 2 3X 4 6 4 X 6 4 5 6 4 5 67 5 8 7 5 8 7 X 8 7 8 X 现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换。 输入格式输入占一行，将3×3的初始网格描绘出来。 例如，如果初始网格如下所示：1 2 3 x 4 6 7 5 8 则输入为：1 2 3 x 4 6 7 5 8 输出格式输出占一行，包含一个整数，表示最少交换次数。 如果不存在解决方案，则输出”-1”。 输入样例： 2 3 4 1 5 x 7 6 8 输出样例 19 题解：图的最短路问题，肯定要用到bfs, 可以将这个图转化为一个字符串,终点状态就是到达特定字符串”12345678x”，最先到达的一定是最短的 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;unordered_map&gt;using namespace std;unordered_map&lt;string, int &gt; d; //字符串哈希来表示到达该字串的距离string End, cur;int dx[] = &#123;0, 1, 0, -1&#125;;int dy[] = &#123;1, 0, -1, 0&#125;;int bfs()&#123; End = \"12345678x\"; d[cur] = 0; queue&lt;string &gt;q; q.push(cur); while(q.size())&#123; string u = q.front(); if(u == End)return d[u];//如果找到了，返回距离 int distance = d[u]; q.pop(); int x = u.find('x'); //在字符串里找到x int i = x / 3, j = x % 3; //得到x在图里的行和列 for(int k = 0; k &lt; 4; k++)&#123; //上下左右4个方向交换 int xx = i + dx[k]; int yy = j + dy[k]; if(xx &gt;= 0 &amp;&amp; xx &lt; 3 &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; 3)&#123; swap(u[x], u[xx * 3 + yy]);//交换 if(!d.count(u))&#123; //如果该字符串没有出现过，放入到队列中 d[u] = distance + 1; q.push(u); &#125; swap(u[x], u[xx * 3 + yy]); //恢复 &#125; &#125; &#125; return -1;&#125;int main()&#123; char ch; for(int i = 0; i &lt; 9; i++)&#123; cin &gt;&gt; ch; cur += ch; &#125; cout &lt;&lt; bfs() &lt;&lt; endl; return 0;&#125;","path":"2019/06/21/搜索/八数码/","date":"06-21","excerpt":"","tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"dfs和bfs简介","text":"dfs和bfs简介一.深度优先遍历(dfs)本质： 通过递归的方式遍历图中的每一个点。 遍历流程： 从起点开始，在其一条分支上一条路走到黑，走不通了就开始往回走，只要当前有分支就继续往下走，直到将所有的点遍历一遍。 剪枝： 如果已经确定这条路没有我们想要的答案，那么就不用继续在这条路上走下去了，于是我们就开始走其他的分支或者往回走，这样节省时间的方法称之为剪枝。 回溯： 当我们一条路走到头，往回走时，就叫做回溯。 恢复现场： 当我们回溯的时候，原来这个图是什么样的，我们还要变回什么样。这是一个好习惯，我们用了什么东西，就需要还回什么东西。这样做的目的： 当我们遍历完这条分支，去遍历下一条分支的时候，我们需要保证当前图其他条件的一致性，也就是遍历每一条分支的时候，当前图的状态都是一样的。保证遍历每一条分支的时候都是公平的。 下面是流程图： 二.广度优先遍历(bfs)遍历流程： 逐层逐层的遍历，先遍历第一层，再遍历第二层…，也就是遍历当前节点所能到达的所有子节点。直到遍历所有的点。不存在剪枝，回溯和恢复现场的操作。 流程图如下： 三.对比dfs和bfs时间复杂度： dfs: 因为我们需要枚举没一个点，以及每一条边，所示它的时间复杂度为O(n + e) 即点的个数+边的个数 bfs:跟dfs时间复杂度一样，都为O(n + e) 不同的是对每个点的访问顺序是不一样的 用到的数据结构： dfs: stack bfs: queue 空间复杂度： dfs: O(h) h为树的深度 bfs: O(2^h) 特性： dfs: 不具有最短性 bfs: 具有最短性","path":"2019/06/16/搜索/dfs和bfs简介/","date":"06-16","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"},{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"有向图的拓扑排序(bfs)","text":"题目描述 给定一个n个点m条边的有向图，图中可能存在重边和自环。 请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出-1。 若一个由图中所有点构成的序列A满足：对于图中的每条边(x, y)，x在A中都出现在y之前，则称A是该图的一个拓扑序列。 输入格式 第一行包含两个整数n和m 接下来m行，每行包含两个整数x和y，表示点x和点y之间存在一条有向边(x, y)。 输出格式 共一行，如果存在拓扑序列，则输出拓扑序列。 否则输出-1。 数据范围 1≤n,m≤10^5, 1≤n,m≤10^5 输入样例： 3 31 22 31 3 输出样例： 1 2 3 拓扑序列简介： 若一个由图中所有点构成的序列A满足：对于图中的每条边(x, y)，x在A中都出现在y之前，则称A是该图的一个拓扑序列。范围是有向图， 无向图是没有拓扑排序的。 入度： 有多少个点指向该元素，就表示该元素的入度是多少。 初出度： 该元素指向了多少个点，就表示该元素的出度是多少、 拓扑序列的起点： ​ 因为入度为0的点，没有其他的点指向它，所以它一定是一个起点，如果入度为0的点有多个，那么该拓扑序列不唯一，如果没有入度为0的点，也就是这个图是一个环，那么它没有拓扑排序。所以我们要求拓扑序列，那么该图一定是一个有向无环图 如何求拓扑序列： ​ 将入度为0的点加入队列当中，每次从入度为0的点开始遍历它的每一个子节点，不断删去前一个点，并且该节点的入度–，如果入度为0,则加入队列当中，在删去节点的同时用一个数组来存储该拓扑排序的顺序，最后输出答案即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int h[N], e[N], ne[N], idx;//邻接表int d[N], n ,m;//入度vector&lt;int &gt; ans;void add(int a, int b)//邻接表建图&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;int bfs()&#123; queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i++) if(!d[i])q.push(i); //将入度为0的点入队 while(q.size())&#123; int u = q.front(); q.pop(); ans.push_back(u); //储存该拓扑排序 for(int i = h[u]; i != -1; i = ne[i])&#123; int s = e[i]; d[s]--; if(!d[s])q.push(s); &#125; &#125; return (ans.size() == n); //判断是否所有的点都已经入队&#125;int main()&#123; int a, b; memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; a &gt;&gt; b; add(a, b); d[b]++; //入度++ &#125; if(bfs())&#123; for(int i = 0; i &lt; ans.size(); i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; cout &lt;&lt; endl; &#125; else cout &lt;&lt; -1 &lt;&lt; endl; return 0;&#125;","path":"2019/06/15/搜索/有向图的拓扑排序/","date":"06-15","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"树与图的广度优先遍历(bfs)","text":"题目描述 给定一个n个点m条边的有向图，图中可能存在重边和自环。 所有边的长度都是1，点的编号为1~n。 请你求出1号点到n号点的最短距离，如果从1号点无法走到n号点，输出-1。 输入格式 第一行包含两个整数n和m。 接下来m行，每行包含两个整数a和b，表示存在一条从a走到b的长度为1的边。 输出格式 输出一个整数，表示1号点到n号点的最短距离。 数据范围 1≤n,m≤10^5, 输入样例： 4 51 22 33 41 31 4 输出样例： 1 题解： 找图的最短路，所以用到的一定是bfs,首先将起点入队，然后不断的弹出队列元素，让该元素的所有没有走过的叶子节点的距离+1, 然后让子节点入队，直到弹出队首元素为n，这样最先得到的距离一定是最短的。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 +10;int e[N], h[N], ne[N], idx;int d[N], n, m;queue&lt;int&gt; q;void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;void bfs()&#123; d[1] = 0; q.push(1); while(q.size())&#123; int u = q.front(); q.pop(); if(u == n)break; for(int i = h[u]; i != -1; i = ne[i])&#123; int s = e[i]; if(d[s] == -1)&#123; d[s] = d[u] + 1; q.push(s); &#125; &#125; &#125;&#125;int main()&#123; int a, b; memset(d, -1, sizeof d); memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; a &gt;&gt; b; add(a, b); &#125; bfs(); cout &lt;&lt; d[n] &lt;&lt; endl; return 0;&#125;","path":"2019/06/15/搜索/树与图的广度优先遍历/","date":"06-15","excerpt":"","tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"迷宫问题(bfs)","text":"题目描述给定一个n*m的二维整数数组，用来表示一个迷宫，数组中只包含0或1，其中0表示可以走的路，1表示不可通过的墙壁。 最初，有一个人位于左上角(1, 1)处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。 请问，该人从左上角移动至右下角(n, m)处，至少需要移动多少次。 数据保证(1, 1)处和(n, m)处的数字为0，且一定至少存在一条通路。 输入格式 第一行包含两个整数n和m。 接下来n行，每行包含m个整数（0或1），表示完整的二维数组迷宫。 输出格式 输出一个整数，表示从左上角移动至右下角的最少移动次数。 数据范围 1≤n,m≤1001≤n,m≤100 输入样例： 5 50 1 0 0 00 1 0 1 00 0 0 0 00 1 1 1 00 0 0 1 0 输出样例： 8 题解： 经典的bfs问题：bfs有最短路的性质，如果每条边的边权值都是1的话，bfs最先遍历到的点离起点的距离一定是最短的，所以我们可以用bfs来做这道题，用队列的方法是bfs的主要特征。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int N = 1000, INF = 0x3f3f3f3f;int a[N][N], d[N][N]; //a数组用来存图， d数组表示距离int dx[] = &#123;0, 1, 0, -1&#125;;//往上下左右4个方向遍历int dy[] = &#123;1, 0, -1, 0&#125;; int n ,m;typedef pair&lt;int ,int &gt;P;queue&lt;P&gt; q;void bfs()&#123; memset(d, INF, sizeof d); //将开始的距离都初始化为最大值， d[1][1] = 0; //起点的距离为0 q.push(&#123;1, 1&#125;); while(q.size())&#123; P cur = q.front(); q.pop(); if(cur.first == n &amp;&amp; cur.second == m)&#123; cout &lt;&lt; d[n][m] &lt;&lt; endl; break; &#125; //4个方向遍历 for(int i = 0; i &lt; 4; i++)&#123; int x = cur.first + dx[i]; int y = cur.second + dy[i]; if(x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m &amp;&amp; d[x][y] == INF &amp;&amp; a[x][y] == 0)&#123;//x，y一定是合法的 &amp;&amp; 判断这条路是否可通 &amp;&amp; 判断这条路是否已经走过了 d[x][y] = d[cur.first][cur.second] +1; //距离+1 q.push(&#123;x, y&#125;);//放入到队列中 &#125; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) cin &gt;&gt; a[i][j]; bfs(); return 0;&#125;","path":"2019/06/14/搜索/迷宫问题/","date":"06-14","excerpt":"","tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"n-皇后问题(dfs)","text":"题目描述n-皇后问题是指将 n 个皇后放在 n∗n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。 现在给定整数n，请你输出所有的满足条件的棋子摆法。 输入格式 共一行，包含整数n。 输出格式 每个解决方案占n行，每行输出一个长度为n的字符串，用来表示完整的棋盘状态。其中”.”表示某一个位置的方格状态为空，”Q”表示某一个位置的方格上摆着皇后。每个方案输出完成后，输出一个空行。 数据范围 1≤n≤9 输入样例： 4 输出样例： .Q..…QQ…..Q. ..Q.Q……Q.Q.. 题解： 经典的n皇后问题:dfs深搜每一行，用col[J]， dg[J], udg[J]数组分别来标记第J列， 正对角线， 反对角线是否有皇后，如果有我们就剪掉， 否则就把皇后放到该位置。代码如下： 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;const int N = 20;int arr[N][N], col[N], dg[N], udg[N], n; void dfs(int cur)&#123; if(cur == n)&#123; //如果放了n个皇后，直接输出 for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(arr[i][j])cout &lt;&lt; 'Q'; else cout &lt;&lt; '.'; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl; return ; &#125; for(int i = 0; i &lt; n; i++)&#123; if(col[i] || dg[cur + i] ||udg[n - cur + i])continue; //如果有了皇后，剪枝 arr[cur][i] = col[i] = dg[cur + i] = udg[n - cur + i] = 1; dfs(cur + 1); arr[cur][i] = col[i] = dg[cur + i] = udg[n - cur + i] = 0; //恢复现场 &#125;&#125;int main()&#123; cin &gt;&gt; n; dfs(0); return 0;&#125;","path":"2019/06/14/搜索/n-皇后问题/","date":"06-14","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"树的重心(dfs)","text":"题目描述 给定一颗树，树中包含n个结点（编号1~n）和n-1条无向边。请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。 输入格式 第一行包含整数n，表示树的结点数。接下来n-1行，每行包含两个整数a和b，表示点a和点b之前存在一条边。 输出格式 输出一个整数m，表示重心的所有的子树中最大的子树的结点数目。 数据范围 1≤n≤105 输入样例 9 1 21 71 42 82 54 33 94 6 输出样例： 4 解题思路： 这道题就是树的深度优先遍历，我们只需套用模板，遍历每个点的同时，返回该子树的点的个数，以及计算去掉该点时连通块点的最大值即可，最后用ans取去掉每个点之后的最大联通块的最小值就是最后的答案。具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int h[N], e[N], ne[N], idx, n;int ans = N; //答案bool vis[N]; //判断是否遍历过void add(int a, int b) //邻接表存树与图&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;int dfs(int cur)&#123; vis[cur] = true; int res = 0, sum = 1; //res表示去掉cur这个节点，联通块点的最大值， sum表示该子树点的个数 for(int i = h[cur]; i != -1; i = ne[i])&#123; //遍历树 int u = e[i]; if(!vis[u])&#123; int s = dfs(u); res = max(res, s); sum += s; &#125; &#125; res = max(res, n - sum); // sum是该子树的点的个数， n - sum表示它的父节点所连接的联通块点的个数 ans = min(res, ans); //取最大连通块点的最小值 return sum;&#125;int main()&#123; int a, b; cin &gt;&gt; n; //初始化 memset(h, -1, sizeof h); memset(vis, false, sizeof vis); for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; a &gt;&gt; b; //建树，双向图 add(a, b); add(b, a); &#125; dfs(1); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","path":"2019/06/14/搜索/树的重心/","date":"06-14","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"树与图的深度优先遍历(dfs)","text":"树与图的深度优先遍历: 树其实也是图的一种图: 分为有向图和无向图图的储存: 第一种：邻接矩阵，就是一个二维数组，缺点：当点和边特别多的时候，存不下，一般用的比较少，而且非常浪费空间第二种：邻接表:由n个单链表组成，也可以用vector动态数组来实现，但vector有很大的缺点，当点和边非常大时，用vector动态数组的方法很容易超时，所以我们常用n个但链表的方式来存储图 邻接表如何存图呢：假设有这样一个图:那么我们可以给每个节点开一个单链表，如下图所示：这样我们就把图用邻接表的方法存了下来树与图深度优先遍历的大致流程：一条路走到黑，直到撞到南墙，走不通了，然后往回走，只要有分支就继续往下走树与图的遍历模板： 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int h[N], e[N], ne[N], idx, n;//这里跟单链表一样，只不过这里是N个头节点，H[N]bool vis[N]; //判断是否遍历过void add(int a, int b) //邻接表存树与图&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;void dfs(int cur)&#123; vis[cur] = true; for(int i = h[cur]; i != -1; i = ne[i])&#123; //遍历树 int u = e[i]; if(!vis[u])&#123; dfs(u); &#125; &#125;&#125;int main()&#123; int a, b; cin &gt;&gt; n; //初始化 memset(h, -1, sizeof h); memset(vis, false, sizeof vis); for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; a &gt;&gt; b; //建树，双向图 add(a, b); add(b, a); &#125; dfs(1); return 0;&#125; 这样我们就遍历了每个点。","path":"2019/06/14/搜索/树与图的深度优先遍历/","date":"06-14","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"字符串哈希","text":"字符串哈希：简介：为了方便的找到某个字符串，我们可以把该字符串转化为一个数值，每一个字符串都有一个唯一确定的编号，这样在绝大多数情况下可以在O(1)的时间复杂度中完成对字符串元素的查找 字符串哈希函数：为每一个字符串赋予唯一确定的数值或编号。 题目描述 给定一个长度为n的字符串，再给定m个询问，每个询问包含四个整数l1,r1,l2,r2l1,r1,l2,r2，请你判断[l1,r1l1,r1]和[l2,r2l2,r2]这两个区间所包含的字符串子串是否完全相同。 字符串中只包含大小写英文字母和数字。 输入格式 第一行包含整数n和m，表示字符串长度和询问次数。 第二行包含一个长度为n的字符串，字符串中只包含大小写英文字母和数字。 接下来m行，每行包含四个整数l1,r1,l2,r2l1,r1,l2,r2，表示一次询问所涉及的两个区间。 注意，字符串的位置从1开始编号。 输出格式 对于每个询问输出一个结果，如果两个字符串子串完全相同则输出“Yes”，否则输出“No”。 每个结果占一行。 数据范围 1≤n,m≤1051≤n,m≤105 输入样例： 8 3aabbaabb1 3 5 71 3 6 81 2 1 2 输出样例： YesNoYes 代码如下： 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef unsigned long long ULL;const int N = 1e6 + 10, base = 131;ULL h[N], p[N];char s[N];ULL solve(int l, int r)&#123; return h[r] - h[l - 1] * p[r - l + 1];&#125;int main()&#123; int n, m; int a, b, c, d; cin &gt;&gt; n &gt;&gt; m; cin &gt;&gt; (s + 1); p[0] = 1; for(int i = 1; i &lt;= n; i++) &#123; h[i] = h[i - 1] * base + s[i] - 'a' + 1; p[i] = p[i - 1] * base; &#125; while(m--)&#123; cin &gt;&gt; a&gt;&gt; b &gt;&gt; c &gt;&gt; d; if(solve(a, b) == solve(c, d))cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/06/13/数据结构基础/字符串哈希/","date":"06-13","excerpt":"","tags":[{"name":"字符串哈希","slug":"字符串哈希","permalink":"http://zhumenger.top/tags/字符串哈希/"}]},{"title":"哈希表(散列表)","text":"简介： 哈希表又称为散列表，是实现字典操作的一种有效的数据结构。通过哈希函数将关键字映射到表中的某个位置上进行存放，以实现快速插入和查询的。时间复杂度可达到O(n).为什么要用到哈希：比如说有n(1&lt;=n&lt;=1e6)个数,当给你一个非常大的数时，为了方便查找这个数是否出现过，我们可以给这个数重新编号到1~n，这样我们就可以快速的找到想要的答案。 题目描述 维护一个集合，支持如下几种操作：“I x”，插入一个数x；“Q x”，询问数x是否在集合中出现过；现在要进行N次操作，对于每个询问操作输出对应的结果。 输入格式 第一行包含整数N，表示操作数量。接下来N行，每行包含一个操作指令，操作指令为”I x”，”Q x”中的一种。 输出格式 对于每个询问指令“Q x”，输出一个询问结果，如果x在集合中出现过，则输出“Yes”，否则输出“No”。每个结果占一行。 数据范围 1≤N≤105−109≤x≤109 输入样例： 5 I 1I 2I 3Q 2Q 5 输出样例： YesNo 题解： 拉链法： ​ 先找出编号的数据范围MOD，最好是一个质数，这样冲突的几率是最小的，让输入的数字x%mod，这样就可以让x重新编号到0~mod - 1， 有的时候我们得到的余数是一样的，我们可以以这个余数为head， 把这些余数相同的储存到一个链表当中，具体代码如下： 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10, mod = 100003;int h[N], e[N], ne[N], idx = 1;void insert(int x)&#123; int k = (x % mod + mod) % mod; //得到余数head e[idx] = x, ne[idx] = h[k], h[k] = idx++;//在以head为头结点的链表中插入数值&#125;bool Find(int x)&#123; int k = (x % mod + mod) % mod; for(int i = h[k]; i != -1; i = ne[i]) //在以head为头结点的链表中查找x if(e[i] == x)return true; return false;&#125;int main()&#123; int n, x; string s; memset(h, -1, sizeof h); cin &gt;&gt; n; while(n--)&#123; cin &gt;&gt; s &gt;&gt;x; if(s == \"I\")&#123; insert(x); &#125; else &#123; if(Find(x))cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; &#125; return 0;&#125; 开放寻址法： ​ 这种方法也是先让x对mod取模， 得到x应该去到哪个坑里，如果这个坑已经被占了，就继续往下遍历直到寻找到一个没有人的坑位，数据范围往往开到n的俩到三倍。 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 200003, Max = 0x3f3f3f3f;int h[N];int Find(int x)&#123; int k = (x % N + N) % N; //取模 while(h[k] != Max &amp;&amp; h[k] != x)&#123; //找到一个没有人的坑位 k++; if(k == N)k = 0; //如果到头了，就从0重新开始遍历，因为一共就只有n个数，所以肯定有剩余的 //坑位供x使用 &#125; return k; //返回坑位的下标&#125;int main()&#123; int n, x; string s; cin &gt;&gt; n; memset(h, Max, sizeof h);//初始化，开始的时候都没有人 while(n--)&#123; cin &gt;&gt; s &gt;&gt; x; if(s == \"I\")&#123; int k = Find(x); h[k] = x; //把x放到该坑位 &#125; else &#123; int k = Find(x); if(h[k] != Max)cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; &#125; return 0;&#125;","path":"2019/06/12/数据结构基础/哈希表-散列表/","date":"06-12","excerpt":"","tags":[{"name":"哈希","slug":"哈希","permalink":"http://zhumenger.top/tags/哈希/"}]},{"title":"最大异或对","text":"Acwing-&gt;143.最大异或对 题目描述在给定的N个整数A1，A2……AN中选出两个进行xor（异或）运算，得到的结果最大是多少？ 输入格式 第一行输入一个整数N。第二行输入N个整数A1～AN。 输出格式 输出一个整数表示答案。 数据范围 1≤N≤105,0≤Ai&lt;231 输入样例： 3 1 2 3 输出样例： 3 题解：异或+前缀+字典树其实来说,一个整数,是可以转化成为一个32位的二进制数,而也就可以变成长度为32位的二进制字符串.既然如此话,那么我们可以这么做,每一次检索的时候,我们都走与当前Ai的二进制位的数值相反的位置走,这样就可以让Xor值最大,如果说没有路可以走的话,那么就走相同的路.时间复杂度：位数*n，所以是O(32 * n) 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int a[N], trie[N * 32][5], idx;void insert(int x) //建树&#123; int p = 1; for(int i = 30; i &gt;= 0; i--)&#123; int u = x &gt;&gt; i &amp; 1; if(!trie[p][u])trie[p][u] = idx++; p = trie[p][u]; &#125;&#125;int search(int x)//找最大的&#123; int p = 1, ans = 0; for(int i = 30; i &gt;= 0; i--)&#123; int u = x &gt;&gt; i &amp;1; if(trie[p][u^1])&#123; p = trie[p][u^1]; ans +=(1 &lt;&lt; i); &#125; else p = trie[p][u]; &#125; return ans;&#125;int main()&#123; int n; cin &gt;&gt; n; idx =2; for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; a[i]; insert(a[i]); &#125; int res = 0; for(int i = 0; i &lt; n; i++)res = max(res, search(a[i])); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;","path":"2019/06/11/数据结构基础/最大异或对/","date":"06-11","excerpt":"","tags":[{"name":"Trie","slug":"Trie","permalink":"http://zhumenger.top/tags/Trie/"}]},{"title":"Trie-字典树","text":"Trie(字典树): 一种用于实现字符串快速检索的多叉树结构 Trie插入： 当需要插入一个字符串s时，我们令一个指针P起始指向根节点。然后，依次扫描S中的每个字符c：若P的c字符指针指向一个已经存在的节点Q，则令P = Q。若P的c字符指针指向空，则新建一个节点Q，令P的c字符指针指向Q，然后令P = Q。当S中的字符扫描完毕时，在当前节点P上标记它是一个字符串的结尾。 检索： 当需要检索一个字符串S在Trie中是否存在时，我们令一个指针P起初指向根节点，然后依次扫描S中的每个字符c：若P的c字符指针指向空，则说明S没有被插入过Trie，结束检索。若P的c字符指针指向一个已经存在的节点Q，则令P = Q。当S中的字符扫描完毕时，若当前节点P被标记为一个字符串的结尾，则说明S在Trie中存在，否则说明S没有被插入过Trie。 问题描述 “I x”向集合中插入一个字符串x；“Q x”询问一个字符串在集合中出现了多少次。共有N个操作，输入的字符串总长度不超过 105，字符串仅包含小写英文字母。 输入格式 第一行包含整数N，表示操作数。接下来N行，每行包含一个操作指令，指令为”I x”或”Q x”中的一种。 输出格式 对于每个询问指令”Q x”，都要输出一个整数作为结果，表示x在集合中出现的次数。每个结果占一行。 数据范围 1≤N≤2∗104 输入样例： 5 I abcQ abcQ abI abQ ab 输出样例： 1 01 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int trie[N][26], cnt[N], idx;char str[N], c;void insert(char *str)&#123; int len = strlen(str), p = 1; //从根节点开始 for(int i = 0; i &lt; len; i++)&#123; int u = str[i] - 'a'; if(!trie[p][u])//如果没有节点，便创造一个节点 trie[p][u] = idx++; //对每个字符串进行编号 p = trie[p][u]; //p等于该节点，继续往下遍历 &#125; cnt[p]++;// 统计编号为p的字符串的个数&#125;int search(char *str)&#123; int len = strlen(str), p = 1; for(int i = 0; i &lt; len; i++)&#123; int u = str[i] - 'a'; if(!trie[p][u])return 0; //如果该节点为空，说明该字符串没有出现 p = trie[p][u]; &#125; return cnt[p];&#125;int main()&#123; int n; cin &gt;&gt; n; idx = 1; while(n--)&#123; cin &gt;&gt; c &gt;&gt; str; if(c == 'I')insert(str); else cout &lt;&lt; search(str) &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/06/11/数据结构基础/Trie-字典树/","date":"06-11","excerpt":"","tags":[{"name":"Trie","slug":"Trie","permalink":"http://zhumenger.top/tags/Trie/"}]},{"title":"单链表","text":"题目描述实现一个单链表，链表初始为空，支持三种操作： (1) 向链表头插入一个数； (2) 删除第k个插入的数后面的数； (3) 在第k个插入的数后插入一个数 现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。 注意:题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。 输入格式 第一行包含整数M，表示操作次数。接下来M行，每行包含一个操作命令，操作命令可能为以下几种：(1) “H x”，表示向链表头插入一个数x。(2) “D k”，表示删除第k个输入的数后面的数（当k为0时，表示删除头结点）。(3) “I k x”，表示在第k个输入的数后面插入一个数x（此操作中k均大于0）。 输出格式 共一行，将整个链表从头到尾输出。 数据范围 1≤M≤100000所有操作保证合法。 输入样例： 10H 9I 1 1D 1D 0H 6I 3 6I 4 5I 4 5I 3 4D 6 输出样例： 6 4 6 5 1.单链表的简单介绍 单链表是一种链式存取的数据结构，用一组任意地址空间（地址空间即存储单元）来存放线性表的数据元素。单链表中的数据是以节点的形式来表示，而节点是用结构体来描述，每个节点都是由元素和指针构成，即该结构体中包含两个成员变量：存放元素的成员变量和存放下一个节点地址的成员变量。 2.顺序表与链表的区别 顺序表的特点为：逻辑相邻的两节点其物理地址也是相邻的；链表的特点为：逻辑相邻的两节点其物理地址不相邻。顺序表的存储方式是：节点元素连续存放在存储单元；链表的存储方式是：节点元素随机存放在存储单元。 链表的插入和删除操作：代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int head; //表示头结点int idx; //表示当前是第几个数int e[N]; //表示第i个数所存储的值int ne[N]; //i的下一个节点void init()&#123; head = -1; //初始化 idx = 0; //下标从0开始&#125;//插入到头结点//1.先用e[idx]存储该值//2.将ne[idx]即第idx个数的下一个节点指向头结点//3.头结点head更新为idx;//4.idx++;void add_to_head(int x)&#123; e[idx] = x, ne[idx] = head, head = idx, idx++; &#125;// 将x插入到第k个数的后面//1.先用e[idx]存储该值x//2.将ne[idx]即第idx个数的下一个节点指向第k个数的下一个节点//3.将ne[k]指向idx;//4.idx++;void add(int k, int x)&#123; e[idx] = x, ne[idx] = ne[k], ne[k] = idx, idx++;&#125;//删除第k个数后面的数//直接让ne[k] = ne[ne[k]]即可void move(int k)&#123; ne[k] = ne[ne[k]];&#125;int main()&#123; int t; init(); cin &gt;&gt; t; while(t--)&#123; char c; int k, x; cin &gt;&gt; c; if(c == 'H')&#123; cin &gt;&gt; x; add_to_head(x); &#125; else if(c == 'D')&#123; cin &gt;&gt; k; if(!k)head = ne[head]; //如果k == 0, 要删除头结点，即让head等于下一个节点 else move(k - 1); &#125; else if(c == 'I')&#123; cin &gt;&gt; k &gt;&gt; x; add(k - 1, x); &#125; &#125; for(int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; ' ' ; cout &lt;&lt; endl; return 0;&#125;","path":"2019/06/10/数据结构基础/单链表/","date":"06-10","excerpt":"","tags":[{"name":"单链表","slug":"单链表","permalink":"http://zhumenger.top/tags/单链表/"}]},{"title":"直方图中最大的矩形（单调栈2）","text":"题目描述直方图是由在公共基线处对齐的一系列矩形组成的多边形。 矩形具有相等的宽度，但可以具有不同的高度。 例如，图例左侧显示了由高度为2,1,4,5,1,3,3的矩形组成的直方图，矩形的宽度都为1:通常，直方图用于表示离散分布，例如，文本中字符的频率。 现在，请你计算在公共基线处对齐的直方图中最大矩形的面积。 图例右图显示了所描绘直方图的最大对齐矩形。 输入格式 输入包含几个测试用例。每个测试用例占据一行，用以描述一个直方图，并以整数n开始，表示组成直方图的矩形数目。然后跟随n个整数h1，…，hn。这些数字以从左到右的顺序表示直方图的各个矩形的高度。每个矩形的宽度为1。同行数字用空格隔开。当输入用例为n=0时，结束输入，且该用例不用考虑。 输出格式 对于每一个测试用例，输出一个整数，代表指定直方图中最大矩形的区域面积。每个数据占一行。请注意，此矩形必须在公共基线处对齐。 数据范围 1≤n≤100000,0≤hi≤1000000000 输入样例： 7 2 1 4 5 1 3 34 1000 1000 1000 10000 输出样例： 8 4000 题解： 以H[ i ]为高的矩形向左右扩展，找到能够到达的最远距离，即找到左右边界第一个小于H[ i ]的位置， 实际上就是一道单调栈的问题，用一个栈来维护一个单调递增的序列，如果栈中的某个元素比当前的数值的小，那么该元素之后的元素肯定是用不到了，所以就可以直接丢出栈， 并将该值加入栈中，遍历一遍，用ans记录最大值即可 代码如下: 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e5 + 10;int q[N], l[N], r[N], a[N], t;int n;void get(int *l)&#123; t = 0; a[0] = -1; q[0] = 0; for(int i = 1; i &lt;= n; i++)&#123; while(a[i] &lt;= a[q[t]])t--; l[i] = q[t] + 1; q[++t] = i; &#125;&#125;int main()&#123; while(cin &gt;&gt; n &amp;&amp; n)&#123; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; get(l); reverse(a + 1, a + 1 + n); get(r); reverse(a + 1, a + 1 + n); long long int ans = 0; for(int i = 1; i &lt;= n; i++)&#123; ans = max(ans, (long long)a[i] * (n - r[n - i + 1] +1 - l[i] + 1)); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/06/10/数据结构基础/直方图中最大的矩形（单调栈2）/","date":"06-10","excerpt":"","tags":[{"name":"栈","slug":"栈","permalink":"http://zhumenger.top/tags/栈/"},{"name":"单调栈","slug":"单调栈","permalink":"http://zhumenger.top/tags/单调栈/"}]},{"title":"堆","text":"堆：一种支持插入，删除，查询最值的数据结构，是一颗完全二叉树，实际上就是一个优先队列priority_queue,这里我们用数组的实现这个堆大根堆：树中的任意一个节点的权值都小于等于其父节点小根堆：树中的任意一个节点的权值都大于等于其父节点如何实现堆： 直接用一个数组来保存二叉堆， 逐层的从左到右依次编号，将此编号作为节点在数组中存储的位置。所以，父亲点编号等于子节点编号除以2，左子节点编号等于父节点编号乘以2，又子节点等于父节点编号乘2加1 堆的基本操作： 1求集合中的最小值：h[ 1 ]2.插入一个数：h[++n] = x;up(n); //up函数将x向上调整，找到x的位置，保证堆的有序性3.删除最小值：h[1] = h[n–];down(1) //down函数，将x向下调整，找到x的位置，保证堆的有序性4.删除任意一个元素：h[x] = h[n–];down(x);up(x);//因为不确定x的大小，所以可能是向上调整，也可能是向下调整，这俩个函数虽然都写上了，但实际上只会执行一个，5.修改任意一个元素：h[k] = x;down(k);up(k)//跟4同理时间复杂度：与堆的高度有关，所以是O（logN）代码如下： 题目描述 输入一个长度为n的整数数列，从小到大输出前m小的数。 输入格式 第一行包含整数n和m。第二行包含n个整数，表示整数数列。 输出格式 共一行，包含m个整数，表示整数数列中前m小的数。 数据范围 1≤m≤n≤105，1≤数列中元素≤109 输入样例： 5 34 5 1 3 2 输出样例： 1 2 3 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int h[N], n ,m;void down(int p) //向上调整&#123; int s = 2 * p; //子节点 while(s &lt;= n)&#123; if(s &lt; n &amp;&amp; h[s] &gt; h[s + 1])s++; //找到左右子节点的最小值 if(h[s] &lt; h[p])&#123; //如果子节点比父节点小 swap(h[s], h[p]); //则交换 p = s; //继续向下调整 s = 2 * p; &#125; else break; &#125;&#125;void up(int p) //向上调整，&#123; while(p &gt; 1)&#123; if(h[p] &lt; h[p / 2])&#123; //如果子节点小于父节点 swap(h[p], h[p / 2]); //则交换 p /= 2; //继续向上调整 &#125; else break; &#125;&#125;int main()&#123; cin&gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; h[i]; for(int i = n / 2; i &gt;= 1; i--)down(i); while(m--)&#123; cout &lt;&lt; h[1] &lt;&lt; ' '; h[1] = h[n--]; down(1); &#125; return 0;&#125;","path":"2019/06/10/数据结构基础/堆/","date":"06-10","excerpt":"","tags":[{"name":"堆","slug":"堆","permalink":"http://zhumenger.top/tags/堆/"}]}]}