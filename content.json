{"meta":{"title":"zhumenger ❤ blog","subtitle":null,"description":null,"author":"zhumenger","url":"http://zhumenger.top","root":"/"},"pages":[{"title":"404","date":"2019-06-10T10:17:33.000Z","updated":"2019-06-10T10:17:33.852Z","comments":true,"path":"404/index.html","permalink":"http://zhumenger.top/404/index.html","excerpt":"","text":""},{"title":"about","date":"2019-06-10T09:53:05.000Z","updated":"2019-06-10T09:53:05.025Z","comments":true,"path":"about/index.html","permalink":"http://zhumenger.top/about/index.html","excerpt":"","text":""},{"title":"about","date":"2019-06-10T10:18:02.000Z","updated":"2019-06-10T10:18:02.435Z","comments":true,"path":"about/index-1.html","permalink":"http://zhumenger.top/about/index-1.html","excerpt":"","text":""},{"title":"categories","date":"2019-06-10T10:18:41.000Z","updated":"2019-06-10T10:18:41.392Z","comments":true,"path":"categories/index-1.html","permalink":"http://zhumenger.top/categories/index-1.html","excerpt":"","text":""},{"title":"categories","date":"2019-06-10T09:52:55.000Z","updated":"2019-06-10T11:04:03.570Z","comments":true,"path":"categories/index.html","permalink":"http://zhumenger.top/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2019-06-10T10:17:29.000Z","updated":"2019-06-10T10:17:29.558Z","comments":true,"path":"search/index.html","permalink":"http://zhumenger.top/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-10T09:52:42.000Z","updated":"2019-06-10T11:04:57.276Z","comments":true,"path":"tags/index.html","permalink":"http://zhumenger.top/tags/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-10T10:18:32.000Z","updated":"2019-06-10T10:18:32.868Z","comments":true,"path":"tags/index-1.html","permalink":"http://zhumenger.top/tags/index-1.html","excerpt":"","text":""}],"posts":[{"title":"1","slug":"1","date":"2019-06-10T13:25:59.000Z","updated":"2019-06-10T13:25:59.240Z","comments":true,"path":"2019/06/10/1/","link":"","permalink":"http://zhumenger.top/2019/06/10/1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"堆","slug":"堆","date":"2019-06-10T11:07:00.000Z","updated":"2019-06-10T13:27:26.162Z","comments":true,"path":"2019/06/10/堆/","link":"","permalink":"http://zhumenger.top/2019/06/10/堆/","excerpt":"","text":"堆：一种支持插入，删除，查询最值的数据结构，是一颗完全二叉树，实际上就是一个优先队列priority_queue,这里我们用数组的实现这个堆大根堆：树中的任意一个节点的权值都小于等于其父节点小根堆：树中的任意一个节点的权值都大于等于其父节点如何实现堆： 直接用一个数组来保存二叉堆， 逐层的从左到右依次编号，将此编号作为节点在数组中存储的位置。所以，父亲点编号等于子节点编号除以2，左子节点编号等于父节点编号乘以2，又子节点等于父节点编号乘2加1 堆的基本操作： 1求集合中的最小值：h[ 1 ]2.插入一个数：h[++n] = x;up(n); //up函数将x向上调整，找到x的位置，保证堆的有序性3.删除最小值：h[1] = h[n–];down(1) //down函数，将x向下调整，找到x的位置，保证堆的有序性4.删除任意一个元素：h[x] = h[n–];down(x);up(x);//因为不确定x的大小，所以可能是向上调整，也可能是向下调整，这俩个函数虽然都写上了，但实际上只会执行一个，5.修改任意一个元素：h[k] = x;down(k);up(k)//跟4同理时间复杂度：与堆的高度有关，所以是O（logN）代码如下： 题目描述 输入一个长度为n的整数数列，从小到大输出前m小的数。 输入格式 第一行包含整数n和m。第二行包含n个整数，表示整数数列。 输出格式 共一行，包含m个整数，表示整数数列中前m小的数。 数据范围 1≤m≤n≤105，1≤数列中元素≤109 输入样例： 5 34 5 1 3 2 输出样例： 1 2 3 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int h[N], n ,m;void down(int p) //向上调整&#123; int s = 2 * p; //子节点 while(s &lt;= n)&#123; if(s &lt; n &amp;&amp; h[s] &gt; h[s + 1])s++; //找到左右子节点的最小值 if(h[s] &lt; h[p])&#123; //如果子节点比父节点小 swap(h[s], h[p]); //则交换 p = s; //继续向下调整 s = 2 * p; &#125; else break; &#125;&#125;void up(int p) //向上调整，&#123; while(p &gt; 1)&#123; if(h[p] &lt; h[p / 2])&#123; //如果子节点小于父节点 swap(h[p], h[p / 2]); //则交换 p /= 2; //继续向上调整 &#125; else break; &#125;&#125;int main()&#123; cin&gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; h[i]; for(int i = n / 2; i &gt;= 1; i--)down(i); while(m--)&#123; cout &lt;&lt; h[1] &lt;&lt; ' '; h[1] = h[n--]; down(1); &#125; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"堆","slug":"堆","permalink":"http://zhumenger.top/tags/堆/"}]},{"title":"单调栈1","slug":"你好","date":"2019-06-10T11:05:33.000Z","updated":"2019-06-10T13:29:40.728Z","comments":true,"path":"2019/06/10/你好/","link":"","permalink":"http://zhumenger.top/2019/06/10/你好/","excerpt":"","text":"题目描述 给定一个长度为N的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出-1。 输入格式 第一行包含整数N，表示数列长度。第二行包含N个整数，表示整数数列。 输出格式 共一行，包含N个整数，其中第i个数表示第i个数的左边第一个比它小的数，如果不存在则输出-1。 数据范围 1≤N≤1051≤数列中元素≤109 输入样例： 5 3 4 2 7 5 输出样例： -1 3 -1 2 2 单调栈： 一种具有单调性的栈如何插入元素： 1.若插入的元素比栈顶的元素大，直接插入并不会影响单调性，所以直接进栈就好 2.插入的元素比栈顶的元素小，为了满足栈的单调性，需要弹出栈顶元素，一直找到小于该元素的值，进栈即可。用途： 利用单调栈，可以找到从左/右遍历第一个比它小/大的元素的位置优点：及时排除了不可能的选项， 保证了策略集合的有效性和秩序性 代码如下： 123456789101112131415161718#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int a[N], st[N];int main()&#123; int n, k = 0; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; for(int i = 0; i &lt; n; i++)&#123; while(k &amp;&amp; st[k] &gt;= a[i])k--; //保持栈的单调性 if(k == 0)cout &lt;&lt; -1 &lt;&lt; ' '; else cout &lt;&lt; st[k] &lt;&lt; ' '; //找到第一个比该元素小的数 st[++k] = a[i]; //进栈 &#125; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"栈","slug":"栈","permalink":"http://zhumenger.top/tags/栈/"},{"name":"单调栈","slug":"单调栈","permalink":"http://zhumenger.top/tags/单调栈/"}]},{"title":"hello","slug":"hello","date":"2019-06-10T11:01:23.000Z","updated":"2019-06-10T13:28:08.383Z","comments":true,"path":"2019/06/10/hello/","link":"","permalink":"http://zhumenger.top/2019/06/10/hello/","excerpt":"","text":"","categories":[],"tags":[]}]}