{"meta":{"title":"zhumenger ❤ blog","subtitle":null,"description":"穿过落雁修竹, 看过日升月暮<br/>你说有一天你会名扬天下实现你的抱负!","author":"zhumenger","url":"http://zhumenger.top","root":"/"},"pages":[{"title":"404","date":"2019-06-10T10:17:33.000Z","updated":"2019-06-10T10:17:33.852Z","comments":true,"path":"404/index.html","permalink":"http://zhumenger.top/404/index.html","excerpt":"","text":""},{"title":"about","date":"2019-06-10T10:18:02.000Z","updated":"2019-06-10T10:18:02.435Z","comments":true,"path":"about/index-1.html","permalink":"http://zhumenger.top/about/index-1.html","excerpt":"","text":""},{"title":"about","date":"2019-06-10T09:53:05.000Z","updated":"2019-06-10T09:53:05.025Z","comments":true,"path":"about/index.html","permalink":"http://zhumenger.top/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-06-10T10:18:41.000Z","updated":"2019-06-10T10:18:41.392Z","comments":true,"path":"categories/index-1.html","permalink":"http://zhumenger.top/categories/index-1.html","excerpt":"","text":""},{"title":"categories","date":"2019-06-10T09:52:55.000Z","updated":"2019-06-10T11:04:03.570Z","comments":true,"path":"categories/index.html","permalink":"http://zhumenger.top/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2019-06-10T10:17:29.000Z","updated":"2019-06-10T10:17:29.558Z","comments":true,"path":"search/index.html","permalink":"http://zhumenger.top/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-10T10:18:32.000Z","updated":"2019-06-10T10:18:32.868Z","comments":true,"path":"tags/index-1.html","permalink":"http://zhumenger.top/tags/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-10T09:52:42.000Z","updated":"2019-06-10T11:04:57.276Z","comments":true,"path":"tags/index.html","permalink":"http://zhumenger.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"最大异或对","slug":"最大异或对","date":"2019-06-11T03:37:08.000Z","updated":"2019-06-11T03:45:19.192Z","comments":true,"path":"2019/06/11/最大异或对/","link":"","permalink":"http://zhumenger.top/2019/06/11/最大异或对/","excerpt":"","text":"Acwing-&gt;143.最大异或对 题目描述在给定的N个整数A1，A2……AN中选出两个进行xor（异或）运算，得到的结果最大是多少？ 输入格式 第一行输入一个整数N。第二行输入N个整数A1～AN。 输出格式 输出一个整数表示答案。 数据范围 1≤N≤105,0≤Ai&lt;231 输入样例： 3 1 2 3 输出样例： 3 题解：异或+前缀+字典树其实来说,一个整数,是可以转化成为一个32位的二进制数,而也就可以变成长度为32位的二进制字符串.既然如此话,那么我们可以这么做,每一次检索的时候,我们都走与当前Ai的二进制位的数值相反的位置走,这样就可以让Xor值最大,如果说没有路可以走的话,那么就走相同的路.时间复杂度：位数*n，所以是O(32 * n) 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int a[N], trie[N * 32][5], idx;void insert(int x) //建树&#123; int p = 1; for(int i = 30; i &gt;= 0; i--)&#123; int u = x &gt;&gt; i &amp; 1; if(!trie[p][u])trie[p][u] = idx++; p = trie[p][u]; &#125;&#125;int search(int x)//找最大的&#123; int p = 1, ans = 0; for(int i = 30; i &gt;= 0; i--)&#123; int u = x &gt;&gt; i &amp;1; if(trie[p][u^1])&#123; p = trie[p][u^1]; ans +=(1 &lt;&lt; i); &#125; else p = trie[p][u]; &#125; return ans;&#125;int main()&#123; int n; cin &gt;&gt; n; idx =2; for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; a[i]; insert(a[i]); &#125; int res = 0; for(int i = 0; i &lt; n; i++)res = max(res, search(a[i])); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"Trie","slug":"Trie","permalink":"http://zhumenger.top/tags/Trie/"}]},{"title":"Trie-字典树","slug":"Trie-字典树","date":"2019-06-11T00:57:01.000Z","updated":"2019-06-11T03:13:20.709Z","comments":true,"path":"2019/06/11/Trie-字典树/","link":"","permalink":"http://zhumenger.top/2019/06/11/Trie-字典树/","excerpt":"","text":"Trie(字典树): 一种用于实现字符串快速检索的多叉树结构 Trie插入： 当需要插入一个字符串s时，我们令一个指针P起始指向根节点。然后，依次扫描S中的每个字符c：若P的c字符指针指向一个已经存在的节点Q，则令P = Q。若P的c字符指针指向空，则新建一个节点Q，令P的c字符指针指向Q，然后令P = Q。当S中的字符扫描完毕时，在当前节点P上标记它是一个字符串的结尾。 检索： 当需要检索一个字符串S在Trie中是否存在时，我们令一个指针P起初指向根节点，然后依次扫描S中的每个字符c：若P的c字符指针指向空，则说明S没有被插入过Trie，结束检索。若P的c字符指针指向一个已经存在的节点Q，则令P = Q。当S中的字符扫描完毕时，若当前节点P被标记为一个字符串的结尾，则说明S在Trie中存在，否则说明S没有被插入过Trie。 问题描述 “I x”向集合中插入一个字符串x；“Q x”询问一个字符串在集合中出现了多少次。共有N个操作，输入的字符串总长度不超过 105，字符串仅包含小写英文字母。 输入格式 第一行包含整数N，表示操作数。接下来N行，每行包含一个操作指令，指令为”I x”或”Q x”中的一种。 输出格式 对于每个询问指令”Q x”，都要输出一个整数作为结果，表示x在集合中出现的次数。每个结果占一行。 数据范围 1≤N≤2∗104 输入样例： 5 I abcQ abcQ abI abQ ab 输出样例： 1 01 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int trie[N][26], cnt[N], idx;char str[N], c;void insert(char *str)&#123; int len = strlen(str), p = 1; //从根节点开始 for(int i = 0; i &lt; len; i++)&#123; int u = str[i] - 'a'; if(!trie[p][u])//如果没有节点，便创造一个节点 trie[p][u] = idx++; //对每个字符串进行编号 p = trie[p][u]; //p等于该节点，继续往下遍历 &#125; cnt[p]++;// 统计编号为p的字符串的个数&#125;int search(char *str)&#123; int len = strlen(str), p = 1; for(int i = 0; i &lt; len; i++)&#123; int u = str[i] - 'a'; if(!trie[p][u])return 0; //如果该节点为空，说明该字符串没有出现 p = trie[p][u]; &#125; return cnt[p];&#125;int main()&#123; int n; cin &gt;&gt; n; idx = 1; while(n--)&#123; cin &gt;&gt; c &gt;&gt; str; if(c == 'I')insert(str); else cout &lt;&lt; search(str) &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"Trie","slug":"Trie","permalink":"http://zhumenger.top/tags/Trie/"}]},{"title":"单链表","slug":"单链表","date":"2019-06-10T14:32:06.000Z","updated":"2019-06-10T14:33:06.797Z","comments":true,"path":"2019/06/10/单链表/","link":"","permalink":"http://zhumenger.top/2019/06/10/单链表/","excerpt":"","text":"题目描述实现一个单链表，链表初始为空，支持三种操作： (1) 向链表头插入一个数； (2) 删除第k个插入的数后面的数； (3) 在第k个插入的数后插入一个数 现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。 注意:题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。 输入格式 第一行包含整数M，表示操作次数。接下来M行，每行包含一个操作命令，操作命令可能为以下几种：(1) “H x”，表示向链表头插入一个数x。(2) “D k”，表示删除第k个输入的数后面的数（当k为0时，表示删除头结点）。(3) “I k x”，表示在第k个输入的数后面插入一个数x（此操作中k均大于0）。 输出格式 共一行，将整个链表从头到尾输出。 数据范围 1≤M≤100000所有操作保证合法。 输入样例： 10H 9I 1 1D 1D 0H 6I 3 6I 4 5I 4 5I 3 4D 6 输出样例： 6 4 6 5 1.单链表的简单介绍 单链表是一种链式存取的数据结构，用一组任意地址空间（地址空间即存储单元）来存放线性表的数据元素。单链表中的数据是以节点的形式来表示，而节点是用结构体来描述，每个节点都是由元素和指针构成，即该结构体中包含两个成员变量：存放元素的成员变量和存放下一个节点地址的成员变量。 2.顺序表与链表的区别 顺序表的特点为：逻辑相邻的两节点其物理地址也是相邻的；链表的特点为：逻辑相邻的两节点其物理地址不相邻。顺序表的存储方式是：节点元素连续存放在存储单元；链表的存储方式是：节点元素随机存放在存储单元。 链表的插入和删除操作：代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int head; //表示头结点int idx; //表示当前是第几个数int e[N]; //表示第i个数所存储的值int ne[N]; //i的下一个节点void init()&#123; head = -1; //初始化 idx = 0; //下标从0开始&#125;//插入到头结点//1.先用e[idx]存储该值//2.将ne[idx]即第idx个数的下一个节点指向头结点//3.头结点head更新为idx;//4.idx++;void add_to_head(int x)&#123; e[idx] = x, ne[idx] = head, head = idx, idx++; &#125;// 将x插入到第k个数的后面//1.先用e[idx]存储该值x//2.将ne[idx]即第idx个数的下一个节点指向第k个数的下一个节点//3.将ne[k]指向idx;//4.idx++;void add(int k, int x)&#123; e[idx] = x, ne[idx] = ne[k], ne[k] = idx, idx++;&#125;//删除第k个数后面的数//直接让ne[k] = ne[ne[k]]即可void move(int k)&#123; ne[k] = ne[ne[k]];&#125;int main()&#123; int t; init(); cin &gt;&gt; t; while(t--)&#123; char c; int k, x; cin &gt;&gt; c; if(c == 'H')&#123; cin &gt;&gt; x; add_to_head(x); &#125; else if(c == 'D')&#123; cin &gt;&gt; k; if(!k)head = ne[head]; //如果k == 0, 要删除头结点，即让head等于下一个节点 else move(k - 1); &#125; else if(c == 'I')&#123; cin &gt;&gt; k &gt;&gt; x; add(k - 1, x); &#125; &#125; for(int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; ' ' ; cout &lt;&lt; endl; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"单链表","slug":"单链表","permalink":"http://zhumenger.top/tags/单链表/"}]},{"title":"直方图中最大的矩形（单调栈2）","slug":"直方图中最大的矩形（单调栈2）","date":"2019-06-10T14:16:22.000Z","updated":"2019-06-10T14:24:55.938Z","comments":true,"path":"2019/06/10/直方图中最大的矩形（单调栈2）/","link":"","permalink":"http://zhumenger.top/2019/06/10/直方图中最大的矩形（单调栈2）/","excerpt":"","text":"题目描述直方图是由在公共基线处对齐的一系列矩形组成的多边形。 矩形具有相等的宽度，但可以具有不同的高度。 例如，图例左侧显示了由高度为2,1,4,5,1,3,3的矩形组成的直方图，矩形的宽度都为1:通常，直方图用于表示离散分布，例如，文本中字符的频率。 现在，请你计算在公共基线处对齐的直方图中最大矩形的面积。 图例右图显示了所描绘直方图的最大对齐矩形。 输入格式 输入包含几个测试用例。每个测试用例占据一行，用以描述一个直方图，并以整数n开始，表示组成直方图的矩形数目。然后跟随n个整数h1，…，hn。这些数字以从左到右的顺序表示直方图的各个矩形的高度。每个矩形的宽度为1。同行数字用空格隔开。当输入用例为n=0时，结束输入，且该用例不用考虑。 输出格式 对于每一个测试用例，输出一个整数，代表指定直方图中最大矩形的区域面积。每个数据占一行。请注意，此矩形必须在公共基线处对齐。 数据范围 1≤n≤100000,0≤hi≤1000000000 输入样例： 7 2 1 4 5 1 3 34 1000 1000 1000 10000 输出样例： 8 4000 题解： 以H[ i ]为高的矩形向左右扩展，找到能够到达的最远距离，即找到左右边界第一个小于H[ i ]的位置， 实际上就是一道单调栈的问题，用一个栈来维护一个单调递增的序列，如果栈中的某个元素比当前的数值的小，那么该元素之后的元素肯定是用不到了，所以就可以直接丢出栈， 并将该值加入栈中，遍历一遍，用ans记录最大值即可 代码如下: 123456789101112131415161718192021222324252627282930313233//这样就形成了一个单调栈#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e6 + 10;typedef long long int ll;int l[N], r[N], h[N], q[N];int n;void get(int a[])&#123; int t = 0; h[0] = -1; for(int i = 1; i &lt;= n; i++)&#123; while(h[q[t]] &gt;= h[i])t--; //找到栈中第一个比该值小的位置 a[i] = q[t]; //记录以H[i]为高能够到达的左右边界 q[++t] = i; //加入栈中 &#125;&#125;int main()&#123; while(cin &gt;&gt; n &amp;&amp; n)&#123; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; h[i]; get(l); //get左边界 reverse(h + 1, h + 1 + n); //翻转 get(r); //get有边界 ll ans = 0; for(int i = 1, j = n; i &lt;= n; i++, j--) ans = max(ans, (ll)h[i] * (n - r[i] - l[j])); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"栈","slug":"栈","permalink":"http://zhumenger.top/tags/栈/"},{"name":"单调栈","slug":"单调栈","permalink":"http://zhumenger.top/tags/单调栈/"}]},{"title":"堆","slug":"堆","date":"2019-06-10T11:07:00.000Z","updated":"2019-06-10T14:24:17.724Z","comments":true,"path":"2019/06/10/堆/","link":"","permalink":"http://zhumenger.top/2019/06/10/堆/","excerpt":"","text":"堆：一种支持插入，删除，查询最值的数据结构，是一颗完全二叉树，实际上就是一个优先队列priority_queue,这里我们用数组的实现这个堆大根堆：树中的任意一个节点的权值都小于等于其父节点小根堆：树中的任意一个节点的权值都大于等于其父节点如何实现堆： 直接用一个数组来保存二叉堆， 逐层的从左到右依次编号，将此编号作为节点在数组中存储的位置。所以，父亲点编号等于子节点编号除以2，左子节点编号等于父节点编号乘以2，又子节点等于父节点编号乘2加1 堆的基本操作： 1求集合中的最小值：h[ 1 ]2.插入一个数：h[++n] = x;up(n); //up函数将x向上调整，找到x的位置，保证堆的有序性3.删除最小值：h[1] = h[n–];down(1) //down函数，将x向下调整，找到x的位置，保证堆的有序性4.删除任意一个元素：h[x] = h[n–];down(x);up(x);//因为不确定x的大小，所以可能是向上调整，也可能是向下调整，这俩个函数虽然都写上了，但实际上只会执行一个，5.修改任意一个元素：h[k] = x;down(k);up(k)//跟4同理时间复杂度：与堆的高度有关，所以是O（logN）代码如下： 题目描述 输入一个长度为n的整数数列，从小到大输出前m小的数。 输入格式 第一行包含整数n和m。第二行包含n个整数，表示整数数列。 输出格式 共一行，包含m个整数，表示整数数列中前m小的数。 数据范围 1≤m≤n≤105，1≤数列中元素≤109 输入样例： 5 34 5 1 3 2 输出样例： 1 2 3 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int h[N], n ,m;void down(int p) //向上调整&#123; int s = 2 * p; //子节点 while(s &lt;= n)&#123; if(s &lt; n &amp;&amp; h[s] &gt; h[s + 1])s++; //找到左右子节点的最小值 if(h[s] &lt; h[p])&#123; //如果子节点比父节点小 swap(h[s], h[p]); //则交换 p = s; //继续向下调整 s = 2 * p; &#125; else break; &#125;&#125;void up(int p) //向上调整，&#123; while(p &gt; 1)&#123; if(h[p] &lt; h[p / 2])&#123; //如果子节点小于父节点 swap(h[p], h[p / 2]); //则交换 p /= 2; //继续向上调整 &#125; else break; &#125;&#125;int main()&#123; cin&gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; h[i]; for(int i = n / 2; i &gt;= 1; i--)down(i); while(m--)&#123; cout &lt;&lt; h[1] &lt;&lt; ' '; h[1] = h[n--]; down(1); &#125; return 0;&#125;","categories":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"http://zhumenger.top/categories/数据结构基础/"}],"tags":[{"name":"堆","slug":"堆","permalink":"http://zhumenger.top/tags/堆/"}]}]}