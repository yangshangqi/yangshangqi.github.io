{"meta":{"title":"zhumenger ❤ blog","subtitle":null,"description":"穿过落雁修竹, 看过日升月暮<br/>你说总有一天你会名扬天下实现你的抱负!","author":"zhumenger","url":"http://zhumenger.top","root":"/"},"pages":[{"title":"guestbook","text":"","path":"guestbook/index.html","date":"06-13","excerpt":""},{"title":"search","text":"","path":"search/index-1.html","date":"07-09","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"06-10","excerpt":""},{"title":"tags","text":"","path":"tags/index-1.html","date":"06-10","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"06-10","excerpt":""},{"title":"404","text":"","path":"404/index.html","date":"06-10","excerpt":""},{"title":"timeline","text":"","path":"timeline/index.html","date":"06-14","excerpt":""},{"title":"about","text":"人生是一个很长很长的梦 每个人都想着把这个梦做得完美 却奈何，奇怪的东西总是会出现在梦里 而我们只会不断沉迷，越陷越深 早已忘却了 这，只是一场梦…","path":"about/index.html","date":"06-10","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"06-10","excerpt":""}],"posts":[{"title":"剪纸游戏","text":"题目描述给定一张N*M的矩形网格纸，两名玩家轮流行动。 在每一次行动中，可以任选一张矩形网格纸，沿着某一行或某一列的格线，把它剪成两部分。 首先剪出1*1的格纸的玩家获胜。 两名玩家都采取最优策略行动，求先手是否能获胜。 提示：开始时只有一张纸可以进行裁剪，随着游戏进行，纸张被裁剪成2,3,…更多张，可选择进行裁剪的纸张就会越来越多。 输入格式 输入包含多组测试数据，每组数据占一行。 每组数据包括两个整数N和M，表示初始网格纸的尺寸。 输出格式 每组测试数据输出一个结果，结果占一行。 如果先手方必胜，则输出”WIN”； 如果先手方必输，则输出”LOSE”。 数据范围 2≤N,M≤200 输入样例： 2 23 24 2 输出样例： LOSELOSEWIN 题解：1.在游戏过程中可能会有若干张大小不同的矩形网格图,每一个矩形网格图都是一个子游戏,所有子游戏构成了一个”游戏的和” 2.因为俩人都是选择的最优策略, 所以他们肯定不会最先剪出1 * x 或 x * 1的纸张，这样的话对手就可以直接剪出1 * 1 的纸张而获胜 3.所以要剪出1 * 1的纸张必定先经过2 * 2, 2 * 3, 3 * 2三种局面之一,4.所以我们可以枚举如何行动,把这张纸剪成俩部分,根据SG函数定理,二者执行xor运算，再对合法行动中产生的子局面构成的集合做mex运算，便得到父亲游戏的的SG值,只要整个游戏开始的SG值不为0,先手必胜，否则先手必败 代码如下： 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int sg[1010][1010];int dfs(int x, int y)&#123; if(sg[x][y] != -1) return sg[x][y]; int f[210]; memset(f, 0, sizeof f); //枚举所有的情况 for(int i = 2; i &lt;= x - i; i++)f[dfs(i, y) ^ dfs(x - i, y)] = 1; for(int i = 2; i &lt;= y - i; i++)f[dfs(x, i) ^ dfs(x, y - i)] = 1; int t = 0; while(f[t])t++;//mex运算 return sg[x][y] = t;&#125;int main()&#123; int n, m; memset(sg, -1, sizeof sg); sg[0][0] = 0; while( cin &gt;&gt; n &gt;&gt; m)&#123; if(dfs(n, m))puts(\"WIN\"); else puts(\"LOSE\"); &#125; return 0;&#125;","path":"2019/09/04/数论/剪纸游戏/","date":"09-04","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"SG函数","slug":"SG函数","permalink":"http://zhumenger.top/tags/SG函数/"}]},{"title":"绿豆蛙的归宿(数学期望)","text":"题目描述给出一个有向无环的连通图，起点为1，终点为N，每条边都有一个长度。 数据保证从起点出发能够到达图中所有的点，图中所有的点也都能够到达终点。 绿豆蛙从起点出发，走向终点。 到达每一个顶点时，如果有K条离开该点的道路，绿豆蛙可以选择任意一条道路离开该点，并且走向每条路的概率为 1/K 。 现在绿豆蛙想知道，从起点走到终点所经过的路径总长度的期望是多少？ 输入格式 第一行: 两个整数 N， M，代表图中有N个点、M条边。 第二行到第 1+M 行: 每行3个整数 a, b, c，代表从a到b有一条长度为c的有向边。 输出格式 输出从起点到终点路径总长度的期望值，结果四舍五入保留两位小数。 数据范围 1≤N≤105,1≤M≤2N 输入样例：123454 41 2 11 3 22 3 33 4 4 输出样例：17.00 题解：设f(x)表示从节点 x 到终点所经过的路径的期望长度。若从 x 出发有 k 条边，分别到达y1,y2,..yk, 边长为z1,z2…zk, 根据数学期望定义有f(x) = (f[yi] + zi) / k (1 &lt;= i &lt;= k), 显然f(N) = 0, 我们的目标是求出f(1),所以我们可以从终点出发, 在反向图上执行拓扑排序在拓扑排序的过程中顺便计算f(x)即可 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int h[N], e[2 * N], ne[2 * N], w[2 * N], idx;int out[2 * N], deg[2 * N];double dis[N];int n, m;void add(int a, int b, int c)&#123; e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof h); while(m--)&#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(b, a, c); out[a]++; deg[a]++; &#125; queue&lt;int&gt; q; q.push(n); while(q.size())&#123; int x = q.front(); q.pop(); for(int i = h[x]; i != -1; i = ne[i])&#123; int y = e[i]; dis[y] += (dis[x] + w[i]) * 1.0 / deg[y]; out[y]--; if(!out[y])q.push(y); &#125; &#125; printf(\"%.2f\\n\", dis[1]); return 0;&#125;","path":"2019/09/04/数论/绿豆蛙的归宿-数学期望/","date":"09-04","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"数学期望","slug":"数学期望","permalink":"http://zhumenger.top/tags/数学期望/"}]},{"title":"开关问题(高斯消元)","text":"题目描述有N个相同的开关，每个开关都与某些开关有着联系，每当你打开或者关闭某个开关的时候，其他的与此开关相关联的开关也会相应地发生变化，即这些相联系的开关的状态如果原来为开就变为关，如果为关就变为开。 你的目标是经过若干次开关操作后使得最后N个开关达到一个特定的状态。 对于任意一个开关，最多只能进行一次开关操作。 你的任务是，计算有多少种可以达到指定状态的方法。（不计开关操作的顺序） 输入格式输入第一行有一个数K，表示以下有K组测试数据。 每组测试数据的格式如下： 第一行 一个数N（0 &lt; N &lt; 29）。 第二行 N个0或者1的数，表示开始时N个开关状态。 第三行 N个0或者1的数，表示操作结束后N个开关的状态。 接下来 每行两个数I J，表示如果操作第 I 个开关，第J个开关的状态也会变化。 每组数据以 0 0 结束。 输出格式如果有可行方法，输出总数，否则输出“Oh,it’s impossible~!!” 。 输入样例： 2 30 0 01 1 11 21 32 12 33 13 20 03 0 0 01 0 11 22 10 0 输出样例： 4 Oh,it’s impossible~!! 题解：1.设xi表示第i个开关的操作情况,那么xi = 1为按了这个开关,否则xi = 0表示这个开关并没有按下去, 2.我们接着统计ai,j表示第i个开关和第j个开关的联系情况,ai,j = 1表示按下j会影响i的状态, 否则就是不会影响,即ai,j = 0,特殊地一个点就是,ai,i = 1,因为我们本身肯定会影响本身. 3.设一个开关起始状态为srci, 最后一个状态为dsti,那么我们可到一个线性方程组 最后我们解方程组ai,1x1 xor ai,2x2 xor…xor ai,nxn = srci xor dsti(1 &lt;= i &lt;= n) 4.为了高效简便, 可以把曾广矩阵的每一行进行状态压缩, 用一个int类型的整数表示n + 1位二进制数, 其中第0 位为曾广矩阵最后一列的常数,第1 ~ n位分别表示为曾广矩阵1 ~ n位的系数 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;using namespace std;int a[50];int main()&#123; int t, n; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for(int i = 1, j; i &lt;= n; i++)&#123; cin &gt;&gt; j; a[i] ^= j; a[i] |= 1 &lt;&lt; i; // ai,i = 1 &#125; int x, y, ans = 1; while(cin &gt;&gt; x &gt;&gt; y &amp;&amp; x &amp;&amp; y)&#123; a[y] |= 1 &lt;&lt; x; //ay,x = 1 &#125; for(int i = 1; i &lt;= n; i++)&#123; //找到一个最大的a[i]， 即主元位数最高的a[i] for(int j = i + 1; j &lt;= n; j++) if(a[j] &gt; a[i])swap(a[i], a[j]); //如果最大的a[i]为0，说明消元完毕 //此时有i - 1个主元, n - i + 1个自由元 if(a[i] == 0)&#123;ans = 1 &lt;&lt; (n - i + 1); break;&#125; if(a[i] == 1)&#123;ans = 0; break;&#125; //如果0 = 1，无解 for(int k = n; k; k--)&#123; //枚举系数 if(a[i] &gt;&gt; k &amp;&amp; 1)&#123; //a[i]最高位的1作为主元, 消去其他方程该位的系数 for(int j = 1; j &lt;= n; j++)&#123; if(i != j &amp;&amp; a[j] &gt;&gt; k &amp; 1)a[j] ^= a[i]; &#125; break; &#125; &#125; &#125; if(ans == 0)puts(\"Oh,it's impossible~!!\"); else cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/09/01/数论/开关问题-高斯消元/","date":"09-01","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"高斯消元","slug":"高斯消元","permalink":"http://zhumenger.top/tags/高斯消元/"}]},{"title":"矩阵快速幂(斐波那契)","text":"题目描述在斐波那契数列中，Fib0 = 0,Fib1 = 1,Fibn = Fibn−1 + Fibn−2 (n &gt; 1)。 给定整数n，求Fibn mod 10000。 输入格式 输入包含多组测试用例。 每个测试用例占一行，包含一个整数n。 当输入用例n=-1时，表示输入终止，且该用例无需处理。 输出格式 每个测试用例输出一个整数表示结果。 每个结果占一行。 数据范围 0≤n≤2∗10 ^ 9 输入样例： 0 99999999991000000000-1 输出样例： 0 346266875 题解：1.直接递归: 时间复杂度为O(n),超时 2.设f(n)表示一个1 * 2的矩阵,F(n) = {b(n), b(n + 1)},我们可以用f(n - 1) = {b(n - 1), b(n)}来得到F(n),也就是说, 要把F(n - 1)第二列上的数作为F(n)的第一列上的数,并把F(n - 1)第1、2列上的数累加到F(n)的第二列上,因此,根 据矩阵乘法原理我们可以让矩阵a = [[0, 1], [1, 1]],那么F(n) = F(n - 1) * a, 设初始值F(0) = {0, 1},目标F(n) = F(0) * A ^ n 3.用快速幂来计算F(0) * A^n, 把快速幂算法中的乘法改成矩阵的乘法就可以了,时间复杂度为O(2^3 * log(n) 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;int n;void mul(int f[2], int a[2][2])&#123; int c[2]; memset(c, 0, sizeof c); for(int i = 0; i &lt; 2; i++) for(int j = 0; j &lt; 2; j++) c[i] = (c[i] + (ll)f[j] * a[j][i]) % 10000; memcpy(f, c, sizeof c);&#125;void mulself(int a[2][2])&#123; int c[2][2]; memset(c, 0, sizeof c); for(int i = 0; i &lt; 2; i++) for(int j = 0; j &lt; 2; j++) for(int k = 0; k &lt; 2; k++) c[i][j] = (c[i][j] + (ll)a[i][k] * a[k][j]) % 10000; memcpy(a, c, sizeof c);&#125;int main()&#123; while(cin &gt;&gt; n &amp;&amp; n != -1)&#123; int f[2] = &#123;0, 1&#125;; int a[2][2] = &#123;&#123;0, 1&#125;, &#123;1, 1&#125;&#125;; while(n)&#123; if(n &amp; 1)mul(f, a); n &gt;&gt;= 1; mulself(a); &#125; cout &lt;&lt; f[0] &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/09/01/数论/矩阵快速幂-斐波那契/","date":"09-01","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"http://zhumenger.top/tags/矩阵快速幂/"}]},{"title":"球形空间产生器(高斯消元)","text":"题目描述有一个球形空间产生器能够在n维空间中产生一个坚硬的球体。 现在，你被困在了这个n维球体中，你只知道球面上n+1个点的坐标，你需要以最快的速度确定这个n维球体的球心坐标，以便于摧毁这个球形空间产生器。 输入格式 第一行是一个整数n。 接下来的n+1行，每行有n个实数，表示球面上一点的n维坐标。 每一个实数精确到小数点后6位，且其绝对值都不超过20000。 输出格式 有且只有一行，依次给出球心的n维坐标（n个实数），两个实数之间用一个空格隔开。 每个实数精确到小数点后3位。 数据保证有解。 数据范围 1≤n≤10 输入样例： 2 0.0 0.0-1.0 1.01.0 0.0 输出样例： 0.500 1.500 题解：对于一个球体而言,所有点到球心的距离相等,所以只需要求出一个点(x1,x2,…,xn)使得满足 ∑(0 &lt;= j &lt;= n)(ai,j − xj)^2 = C 记住C是常数,i∈[1,n+1]那么这个方程组是由n+1个n元二次方程,然后我们同时消去C.得到： ∑(1 &lt;= j &lt;= n)((ai,j ^ 2) − (ai+1,j ^ 2) − 2xj(ai,j − ai+1,j)) = 0 (i = 1,2,3,…,n) 我们再把变量放左边,常数放右边. ∑(1 &lt;= j &lt;= n)2(ai,j − ai+1,j) * xj = ∑(1 &lt;= j &lt;= n)(ai,j ^ 2 − ai+1,j ^ 2)(i = 1,2,3,…,n) 然后我们就可以开始愉快地高斯消元了. 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;double a[20][20], b[20], c[20][20];int main()&#123; int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n + 1; i++) for(int j = 1; j &lt;= n; j++) scanf(\"%lf\", &amp;a[i][j]); //c: 系数矩阵, b: 常数, 二者一起构成增广矩阵 for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; c[i][j] = 2 * (a[i][j] - a[i + 1][j]);//得到系数矩阵 b[i] += a[i][j] * a[i][j] - a[i + 1][j] * a[i + 1][j]; //得到常数 &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; // 枚举每一个系数x[i] //找到x[i]的系数不为0的一个方程 for(int j = i; j &lt;= n; j++)&#123; //枚举第i列的每一行 if(fabs(c[j][i]) &gt; 1e-8)&#123; //将第j行与第i行交换 for(int k = i; k &lt;= n; k++)swap(c[i][k], c[j][k]); swap(b[i], b[j]); &#125; &#125; for(int j = 1; j &lt;= n; j++)&#123; //枚举行 if(i == j)continue; double rate = c[j][i] / c[i][i]; //将j行的首元素消除,第j行每一列都需要第i行的系数rate倍 for(int k = i; k &lt;= n; k++)c[j][k] -= c[i][k] * rate; b[j] -= b[i] * rate; &#125; &#125; for(int i = 1; i &lt; n; i++)printf(\"%.3f \", b[i] / c[i][i]); //输出答案 printf(\"%.3f\\n\", b[n] / c[n][n]); return 0;&#125;","path":"2019/09/01/数论/球形空间产生器-高斯消元/","date":"09-01","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"高斯消元","slug":"高斯消元","permalink":"http://zhumenger.top/tags/高斯消元/"}]},{"title":"约数之和","text":"题目描述假设现在有两个自然数A和B，S是ABAB的所有约数之和。 请你求出S mod 9901的值是多少。 输入格式 在一行中输入用空格隔开的两个整数A和B。 输出格式 输出一个整数，代表S mod 9901的值。 数据范围 0≤A,B≤5×10 ^ 7 输入样例： 2 3 输出样例： 15 注意: A和B不会同时为0 题解：1.约数之和公式:φ(N) = (1 + p1 + p1^2 + …+ p1^a1)(1 + p2 + p2^2 + … + p2^a2)…(1 + pn + pn^2 + … + pn^an). 2. 这道题求：φ(N) ^ b = (1 + p1 + p1^2 + …+ p1^(b * a1))(1 + p2 + p2^2 + … + p2^(b * a2))…(1 + pn + pn^2 + … + pn^(b * an)). 3.可以用等比数列求和公式来计算: (1 + p + p^2 + …+ p^(b * a1)) = (p^(b * a1 + 1) - 1) / (p - 1)使用快速幂来计算分子(p^(b*a1 + 1) - 1) % mod的值,和分母(p - 1) % mod的值 4.因为9931是质数,所以只要(p - 1)和mod互质,即不是mod的倍数便可以用乘法逆元来做,如果是mod的倍数,乘法逆元不存在,但p % mod = 1;所以1 + p + p^2 + …+ p^(b * a1) % mod = 1 + 1^2 + …1^b * a1 % mod = b * a1 + 1 % mod 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;const int mod = 9901;typedef long long ll;int a, b, p[20], c[20], cnt;void divide(int x) //分解质因数&#123; for(int i = 2; i * i &lt;= x; i++)&#123; if(x % i == 0)&#123; p[++cnt] = i, c[cnt] = 0; while(x % i == 0)&#123; c[cnt]++; x /= i; &#125; &#125; &#125; if(x &gt; 1) p[++cnt] = x, c[cnt]++;&#125;int qsm(int a, ll b) //快速幂&#123; int ans = 1; while(b != 0)&#123; if(b &amp; 1)ans = (ll)ans * a % mod; b &gt;&gt;= 1; a = (ll)a * a % mod; &#125; return ans;&#125;int main()&#123; int ans = 1; cin &gt;&gt; a &gt;&gt; b; divide(a); for(int i = 1; i &lt;= cnt; i++)&#123; if((p[i] - 1) % mod == 0)ans = (ll)(b * c[i] + 1) % mod * ans % mod; //如果是mod的倍数, 特判 else &#123; int x = qsm(p[i], (ll)b * c[i] + 1); x = (x - 1 + mod) % mod; //分母 % mod int y = (p[i] - 1) % mod; //分子 % mod y = qsm(y, mod - 2); //得到分子的乘法逆元 ans = (ll)ans * x % mod * y % mod; //累计答案 &#125; &#125; if(a)cout &lt;&lt; ans &lt;&lt; endl; else cout &lt;&lt; 0 &lt;&lt; endl;&#125;","path":"2019/08/28/数论/约数之和/","date":"08-28","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"约数","slug":"约数","permalink":"http://zhumenger.top/tags/约数/"}]},{"title":"同余方程","text":"题目描述求关于x的同余方程 ax ≡ 1(mod b) 的最小正整数解。 输入格式 输入只有一行，包含两个正整数a,b,用一个空格隔开。 输出格式 输出只有一行,包含一个正整数x，表示最小正整数解。 输入数据保证一定有解。 数据范围 2≤a,b≤2∗10^9 输入样例： 3 10 输出样例： 7 题解：扩展欧几里得算法： 对于任意整数a,b，存在一对整数x,y, 满足ax + by = gcd(a, b) 这道题求ax % b == 1, 即ax - 1是b的倍数,假设为-y倍, 则ax + by = 1, 利用扩展欧几里得算法即可求出一组特解(x0, y0)(x, y), 有多种解, 题目要求最小正整数解,还需要转化为1~b之间 代码如下： 123456789101112131415161718#include&lt;iostream&gt;using namespace std;typedef long long ll;ll x, y, a, b;ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y)//扩展欧几里得算法&#123; if(b == 0) &#123;x = 1, y = 0; return a;&#125; ll d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;int main()&#123; cin &gt;&gt; a &gt;&gt; b; exgcd(a, b, x, y); cout &lt;&lt; (x % b + b) % b &lt;&lt; endl; return 0;&#125;","path":"2019/08/27/数论/同余方程/","date":"08-27","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"同余","slug":"同余","permalink":"http://zhumenger.top/tags/同余/"}]},{"title":"最幸运的数字","text":"题目描述8是中国的幸运数字，如果一个数字的每一位都由8构成则该数字被称作是幸运数字。 现在给定一个正整数L，请问至少多少个8连在一起组成的正整数（即最小幸运数字）是L的倍数。 输入格式 输入包含多组测试用例。 每组测试用例占一行，包含一个整数L。 当输入用例L=0时，表示输入终止，该用例无需处理。 输出格式 每组测试用例输出结果占一行。 结果为“Case 1: ”+一个整数N，N代表满足条件的最小幸运数字的位数。 如果满足条件的幸运数字不存在，则N=0。 数据范围 1≤L≤2∗10^9 输入样例： 8 11160 输出样例： Case 1: 1Case 2: 2Case 3: 0 题解：欧拉定理：若a，b互质，则a^f(b) % b == 1.其中f(b)为欧拉函数 引理1:对于任何一个111，22…22，333…33,形如这样的数，我们都是可以用一个公式表示的。即:k * (10^x - 1) / 9; 所以目前的可以将问题转化为: 找到最小的x,使得满足(8 * (10^x - 1) / 9) % l == 0，将公式化简: 9L | (8 * (10^x - 1))。我们令d = gcd(L,8),然后同时两边除上d，可得9L/d | (8/d * (10^x - 1))。 9L/d 与 8/d 这两个数一定是互质的。故，我们可以得到9L/d 因是 (10^x - 1)的因子。可得：9L/d | (10^x - 1).可得：10^x % （9L/d） == 1.至此 这个函数跟欧拉定理，就是一样的形式了。 引理2: 如正整数a, n互质,则满足a^x % n == 1的最小正整数x0是f(n)的约数 证明：若10 与 (9L/d) 不是互质的，则二者有相同的因子b为2或者5。若b为2 则：9L/d 为偶数，那么10 % （9L/d）一定不能等于1.同理可证b为5的情况。 继续根据欧拉函数推测：f(9L/d)可以为x的取值。但是现在要找的是最小的x。我们知道a^b % n是有循环节r的。r应是f(9L/d)的约数。 综上所述,我们推出了公式10^x % p == 1(p = 9 * l / (gcd(8, l))), 并且x满足为f(p)的约数至此，我们目的明确了。求出（9L/d）的欧拉函数值，枚举他的所有约数，找到满足10^x % （9L/d） == 1.的x的最小值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;typedef long long ll;ll l;ll gcd(ll a, ll b) &#123; return b ? gcd(b, a % b) : a;&#125;ll get_ouler(ll p) //获得p的欧拉函数&#123; ll ans = p; for(int i = 2; i * i &lt;= p; i++)&#123; if(p % i == 0) ans = ans / i * (i - 1); while(p % i == 0) p /= i; &#125; if(p &gt; 1) ans = ans / p * (p - 1); return ans;&#125; ll qsm(ll a, ll b, ll mod) //快速幂取模&#123; ll ans = 1; while(b != 0)&#123; if(b &amp; 1)ans = ans * a % mod; b &gt;&gt;= 1; a = a * a % mod; &#125; return ans;&#125;int main()&#123; int t = 1; while(cin &gt;&gt; l &amp;&amp; l != 0)&#123; ll p = 9 * l / gcd(l, 8); //得到模数p ll ouler = get_ouler(p); //得到p的欧拉函数 ll ans = 1e18; for(ll i = 1; i * i &lt;= ouler; i++)&#123; //枚举ouler所有的的约数,找到最小的满足条件的x if(ouler % i == 0)&#123; if(qsm(10, i, p) == 1) ans = min(ans, i); //由推论可知,x满足10 ^ x % p == 1 if(qsm(10, ouler / i, p) == 1) ans = min(ans, ouler / i); &#125; &#125; printf(\"Case %d: \", t++); //输出答案 if(ans == 1e18)cout &lt;&lt; 0 &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/08/27/数论/最幸运的数字/","date":"08-27","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"同余","slug":"同余","permalink":"http://zhumenger.top/tags/同余/"}]},{"title":"可见的点","text":"题目描述在一个平面直角坐标系的第一象限内，如果一个点(x,y)与原点（0,0）的连线中没有通过其他任何点，则称该点在原点处是可见的。 例如，点(4,2)就是不可见的，因为它与原点的连线会通过点(2,1)。 部分可见点与原点的连线如下图所示： 编写一个程序，计算给定整数N的情况下，满足0≤x，y≤N0≤x，y≤N的可见点（x，y）的数量（可见点不包括原点）。 输入格式 第一行包含整数C，表示共有C组测试数据。 每组测试数据占一行，包含一个整数N。 输出格式 每组测试数据的输出占据一行。 应包括：测试数据的编号（从1开始），该组测试数据对应的N以及可见点的数量。 同行数据之间用空格隔开。 数据范围 1≤N,C≤1000 输入样例： 4 24 5231 输出样例： 1 2 52 4 133 5 214 231 32549 题解：1.除了(1, 0),(0, 1),(1, 1) 一个钉子被看到当且仅当gcd(x, y) == 1, 我们只需考虑一半的情况即可,对于每个y(2 &lt;= y &lt;= N), 求出有多个数x与y互质,最后的答案ans = 3 + 2 * f(i)(2 &lt;= i &lt;= N)2.对于f(i),我们可以用欧拉函数来求解 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;const int N = 1010;int phi[N];int t, n;void solve()&#123; for(int i = 2; i &lt;= n; i++)phi[i] = i; for(int i = 2; i &lt;= n; i++)&#123; //枚举每一个数i if(phi[i] == i)&#123; // 如果i为素数 for(int j = i; j &lt;= n; j += i) phi[j] = phi[j] / i * (i - 1); &#125; &#125;&#125;int main()&#123; int p = 1; cin &gt;&gt; t; while(t--)&#123; int ans = 0; cin &gt;&gt; n; solve(); for(int i = 2; i &lt;= n; i++) ans += 2 * phi[i]; printf(\"%d %d %d\\n\", p++, n, ans +3); //输出答案 &#125; return 0;&#125;","path":"2019/08/27/数论/可见的点/","date":"08-27","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"约数","slug":"约数","permalink":"http://zhumenger.top/tags/约数/"}]},{"title":"余数之和","text":"题目描述给出正整数n和k，计算j(n, k)=k mod 1 + k mod 2 + k mod 3 + … + k mod n的值。 例如j(5, 3)=3 mod 1 + 3 mod 2 + 3 mod 3 + 3 mod 4 + 3 mod 5=0+1+0+3+3=7。 输入格式 输入仅一行，包含两个整数n, k。 输出格式 输出仅一行，即j(n, k)。 数据范围1≤n,k≤10 ^ 9 输入样例： 5 3 输出样例： 7 题解：1.k % i = k - (k / i) * i, 所以我们要求的答案就是:n * k - (k / i) * i(1 &lt;= i &lt;= n) 2.令g(x) = k / (k / x),(1 &lt;= x &lt;= k)由夹逼准则可求得k / g(x) = k / x,所以对于 i 属于[x, k / (k / x)],k / i 的值都相同，等于k / x所以算式(k / i) * i = (k / x) * i,在区间[x, k / (k / x)]就是一个公差为(k / x)的等差数列，直接用等差数列求和公式计算即可 代码如下： 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;typedef long long ll;int main()&#123; ll n, k; cin &gt;&gt; n &gt;&gt; k; ll l, r, a1, an, q; ll ans = n * k; for(int l = 1; l &lt;= n; l = r + 1)&#123; //不断找寻下一区间,枚举左端点 r = k / l ? min(k / (k / l), n) : n; //得到又端点, q = k / l;//公差 a1 = l * q;//第一项 an = r * q;//第二项 ans -= (a1 + an) * (r - l + 1) / 2; //ans减去这段的区间和 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","path":"2019/08/26/数论/余数之和/","date":"08-26","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"约数","slug":"约数","permalink":"http://zhumenger.top/tags/约数/"}]},{"title":"反素数","text":"题目描述对于任何正整数x，其约数的个数记作g(x)，例如g(1)=1、g(6)=4。 如果某个正整数x满足：对于任意的小于x的正整数 i，都有g(x)&gt;g(i) ，则称x为反素数。 例如，整数1，2，4，6等都是反素数。 现在给定一个数N，请求出不超过N的最大的反素数。 输入格式 一个正整数N。 输出格式 一个整数，表示不超过N的最大反素数。 数据范围 1≤N≤2∗109 输入样例： 1000 输出样例： 840 题解：引理1: 1~N中任何数的质因子都不会超过10个,且所有的质因子的指数总和不会超过30, 因为最小1的10个质数的乘积2 * 3 * 5 * 7 * 9 * 11 * 13 * 17 * 19 * 23 &gt; 2 * 10 ^ 9 即使只包括最小的质数,任然有2 ^ 31 &gt; 2 * 10 ^ 9, 所以N &lt;= 2 * 10 ^ 9 的质因子指数总和不可能超过30 引理2: x为反质数的必要条件是, x分解质因数后可以写作2^c1 * 3^c2 * 5^c3 * 7^c4 * 11^c5 * 13^c6 * 17^c7 * 19^c8 * 23^c9 * 29^c10并且c1 &gt;= c2 &gt;= c3 &gt;= ..c10 &gt;= 0, 即x的质因子是连续的若干个最小的质数,并且指数单调递减因为如果不满足连续若干个最小的话,我们就可以使用交换质因子的方法,得到一个x使得x的质因子连续,约数个数相同,且x更小指数如果不是递减的话,也是一样的道理,我们总能找到一个约数相同且比原先更小的x使得x的指数递减综上所述,我们可以使用深度优先搜索(DFS),尝试确定前10个质数的指数,并满足指数单调递减,总乘积不超过N,同时记录约数的个数 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;typedef long long ll;int sum ,minx;int a[] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29&#125;;int n;void dfs(int u, int cnt, int p, int ans) //u表示当前质数, cnt表示指数,p表示约数乘积,ans表示约数个数&#123; if(ans &gt; sum || ans == sum &amp;&amp; p &lt; minx)&#123; minx = p; sum = ans; &#125; for(int i = 1; i &lt;= cnt; i++)&#123; if((ll)p * a[u] &gt; n)break; p *= a[u]; //确定当前质数的指数 dfs(u + 1, i, p, ans * (i + 1)); //搜索下一个质数的指数,并保证指数递减,更新约数乘积和约数个数 &#125;&#125;int main()&#123; cin &gt;&gt; n; dfs(0, 30, 1, 1); cout &lt;&lt; minx &lt;&lt; endl; return 0;&#125;","path":"2019/08/26/数论/反素数/","date":"08-26","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"约数","slug":"约数","permalink":"http://zhumenger.top/tags/约数/"}]},{"title":"阶乘分解","text":"题目描述给定整数 N ，试把阶乘 N! 分解质因数，按照算术基本定理的形式输出分解结果中的 pipi 和 cici 即可。 输入格式 一个整数N。 输出格式 N! 分解质因数后的结果，共若干行，每行一对pi,cipi,ci，表示含有pciipici项。按照pipi从小到大的顺序输出。 数据范围 1≤N≤106 输入样例： 5 输出样例： 2 33 15 1 样例解释5!=120=23∗3∗5 题解：*1.若把1~N中的每个数分别分解质因数,再把结果合并，时间复杂度过高为O(NlogN) * 2.N!的质因子不会超过N，所以我们可以先筛选出1~N的每个质数p,然后考虑N！中有多少个质因子p 3.N!中质因子p的个数等于1N每个数包含质因子p的个数之和。在1N中p的倍数显然有n / p个，而p^2的倍数，即至少含有2个质因子p的个数有n / p^2个,因为其中的一个质因子已经在N / p中统计过了，所以这里不需要 * 2** **4.一次类推，我们便可以得到N！中质因子p的个数为(N / P) + (N / P^2) + (N / P^3) + ….. + N / plogp(N) 代码如下: 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int prime[N], cnt;bool st[N];int main()&#123; memset(st, true, sizeof st); for(int i = 2; i &lt;= 1000000; i++)&#123; //线性筛法预处理出所有的质数 if(st[i])prime[cnt++] = i; for(int j = 0; j &lt; cnt &amp;&amp; i * prime[j] &lt;= 1000000; j++)&#123; st[i * prime[j]] = false; if(i % prime[j] == 0)break; &#125; &#125; int n; cin &gt;&gt; n; for(int i = 0; i &lt; cnt; i++)&#123; //枚举质数 if(prime[i] &gt; n)break; int ans = 0; for(int j = prime[i]; j &lt;= n; j *=prime[i])&#123; ans += n / j; if(j &gt; n / prime[i])break; //防止j * prime[i]溢出 &#125; cout &lt;&lt; prime[i] &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/08/24/数论/阶乘分解/","date":"08-24","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"素数","slug":"素数","permalink":"http://zhumenger.top/tags/素数/"}]},{"title":"质数距离","text":"题目描述给定两个整数L和U，你需要在闭区间[L,U]内找到距离最接近的两个相邻质数C1和C2（即C2-C1是最小的），如果存在相同距离的其他相邻质数对，则输出第一对。 同时，你还需要找到距离最远的两个相邻质数D1和D2（即D1-D2是最大的），如果存在相同距离的其他相邻质数对，则输出第一对。 输入格式 每行输入两个整数L和U，其中L和U的差值不会超过1000000。 输出格式 对于每个L和U ，输出一个结果，结果占一行。 结果包括距离最近的相邻质数对和距离最远的相邻质数对。（具体格式参照样例） 如果L和U之间不存在质数对，则输出“There are no adjacent primes.”。 数据范围 1≤L&lt;U≤2^31−1 输入样例： 2 1714 17 输出样例： 2,3 are closest, 7,11 are most distant.There are no adjacent primes. 题解：1.虽然给出的数据范围很大，用已知的算法无法在规定时间内生成[L,R]中的所有质数，但r - l的数据范围确很小，并且任何一个合数N,必定包含一个不超过sqrt(n)的质因子 2.我们可以先用线性筛法求出2~sqrt(n)内所有的的质数,对于每个质数p,把[L, R]中能被p整除的数去掉，剩下的数便都是质数了 3.最后对相邻的质数俩俩比较，找出答案 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;stdio.h&gt;using namespace std;typedef long long ll;const int N = 1e6 + 10;int prime[N], cnt;bool st[N];void init() //线性筛法预处理出所有的质数&#123; cnt = 0; memset(st, true, sizeof st); for(int i = 2; i &lt;= 50000; i++)&#123; if(st[i]) prime[cnt++] = i; for(int j = 0; j &lt; cnt &amp;&amp; i * prime[j] &lt;= 50000; j++)&#123; st[i * prime[j]] = false; if(i % prime[j] == 0)break; &#125; &#125;&#125;int main()&#123; ll l, r; while(cin &gt;&gt; l &gt;&gt; r)&#123; init(); memset(st, true, sizeof st); for(int i = 0; i &lt; cnt; i++)&#123; int p = prime[i]; //对于每个质数p,把[L, R]中能被p整除的数去掉 //找到[l, r]中第一个p的倍数,即(l / p)(向上取整) * p,因为在c++中没法做到直接向上取整 //所以一般的写法为(l + p - 1)(向下取整) / p * p for(ll j = max((l + p - 1) / p * p, 2ll * p); j &lt;= r; j += p)&#123; st[j - l] = false; //由于r - l数据范围很小，所以可以用偏移量来标记 &#125; &#125; int cnt = 0; for(int i = 0; i + l &lt;= r; i++) //记录[L, R]中所有的质数 if(st[i] &amp;&amp; i + l &gt; 1)prime[cnt++] = i + l; if(cnt &lt; 2)cout &lt;&lt; \"There are no adjacent primes.\" &lt;&lt; endl; else &#123; int Max = 0, Min = 1e6 + 10, a, b, c, d; for(int i = 1; i &lt; cnt; i++)&#123; int t = prime[i] - prime[i - 1]; if(t &gt; Max)&#123; Max = t; a = prime[i - 1], b = prime[i]; &#125; if(t &lt; Min)&#123; Min = t; c = prime[i - 1], d = prime[i]; &#125; &#125; printf(\"%d,%d are closest, %d,%d are most distant.\\n\", c, d, a, b); &#125; &#125; return 0;&#125;","path":"2019/08/24/数论/质数距离/","date":"08-24","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"素数","slug":"素数","permalink":"http://zhumenger.top/tags/素数/"}]},{"title":"导弹防御系统(dfs)","text":"题目描述为了对抗附近恶意国家的威胁，R国更新了他们的导弹防御系统。 一套防御系统的导弹拦截高度要么一直上升要么一直下降。 例如，一套系统先后拦截了高度为3和高度为4的两发导弹，那么接下来该系统就只能拦截高度大于4的导弹。 给定即将袭来的一系列导弹的高度，请你求出至少需要多少套防御系统，就可以将它们全部击落。 输入格式 输入包含多组测试用例。 对于每个测试用例，第一行包含整数n，表示来袭导弹数量。 第二行包含n个不同的整数，表示每个导弹的高度 当输入测试用例n=0时，表示输入终止，且该用例无需处理。 输出格式 对于每个测试用例，输出一个占据一行的整数，表示所需的防御系统数量。 数据范围 1≤n≤50 输入样例： 5 3 5 2 4 10 输出样例： 2 样例解释 对于给出样例，最少需要两套防御系统。 一套击落高度为3,4的导弹，另一套击落高度为5,2,1的导弹。 题解：导弹防御系统很自然的想到LIS算法，不过这里的条件是一套防御系统的导弹拦截高度要么一直上升要么一直下降，所以用LIS算法是不正确的 而LIS中，最核心的思想在于能否将一个元素加入到序列中，只与这个序列目前的最后一个元素有关这道题就用了这个关键的思想。用up[k]和down[k]记录第k套上升（下降）系统目前所拦截的最后一个导弹dfs(u,v,t)意味着已有u个上升，v个下降，正在处理第t个数 按理说，每拿到一个新的数字应该将它所有能放入的序列都放一遍的但扩展节点时却存在一个贪心策略，大大节省了时间。假设现在要把一个数放入一个上升序列，那么一定是所有能放入的上升序列中，最后一个元素最大的那一个。其实想想也是，既然每个数字都要放到一个序列中，对于上升序列，肯定是目前越小越有用，既然能放入大的里面，何必浪费一个小的呢注意到其实up[i]按这种策略已经是排好序的了，所以只用找最先碰到的一个就行了 代码如下： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;const int N = 55;int a[N], ans, up[N], down[N], n;void dfs(int u, int d, int t) //u表示上升的系统个数，d表示下降的系统个数,t表示第t个数&#123; if(u + d &gt;= ans) return ; if(t == n)&#123; if(u + d &lt; ans)ans = u + d; return ; &#125; int i; for(i = 1; i &lt;= u; i++) //找到第一个末尾数小于a[t]的导弹系统 if(up[i] &lt; a[t])break; int temp = up[i]; up[i] = a[t];//添加到该导弹系统中 dfs(max(u, i), d, t + 1); up[i] = temp; //恢复现场 for(i = 1; i &lt;= d; i++)//找到第一个末尾数大于a[t]的导弹系统 if(down[i] &gt; a[t])break; temp = down[i]; down[i] = a[t];//添加到该导弹系统中去 dfs(u, max(d, i), t + 1); down[i] = temp;//恢复现场&#125;int main()&#123; while(scanf(\"%d\", &amp;n) != EOF &amp;&amp; n != 0)&#123; ans = 100; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; dfs(0, 0, 0); printf(\"%d\\n\", ans); &#125; return 0;&#125;","path":"2019/08/20/搜索/导弹防御系统-dfs/","date":"08-20","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"靶形数独(数独1变形)","text":"题目描述小城和小华都是热爱数学的好学生，最近，他们不约而同地迷上了数独游戏，好胜的他们想用数独来一比高低。 但普通的数独对他们来说都过于简单了，于是他们向Z博士请教，Z博士拿出了他最近发明的“靶形数独”，作为这两个孩子比试的题目。 靶形数独的方格同普通数独一样，在9×9的大九宫格中有9个3×3的小九宫格（用粗黑色线隔开的）。 在这个大九宫格中，有一些数字是已知的，根据这些数字，利用逻辑推理，在其他的空格上填入1到9的数字。 每个数字在每个小九宫格内不能重复出现，每个数字在每行、每列也不能重复出现。 但靶形数独有一点和普通数独不同，即每一个方格都有一个分值，而且如同一个靶子一样，离中心越近则分值越高（如下图所示）。 上图具体的分值分布是：最里面一格（黄色区域）为10分，黄色区域外面的一圈（红色区域）每个格子为9分，再外面一圈（蓝色区域）每个格子为8分，蓝色区域外面一圈（棕色区域）每个格子为7分，最外面一圈（白色区域）每个格子为6 分，如上图所示。 比赛的要求是：每个人必须完成一个给定的数独（每个给定数独可能有不同的填法），而且要争取更高的总分数。 而这个总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和。 如图，在以下的这个已经填完数字的靶形数独游戏中，总分数为2829。 游戏规定，将以总分数的高低决出胜负。 由于求胜心切，小城找到了善于编程的你，让你帮他求出，对于给定的靶形数独，能够得到的最高分数。 输入格式 输入一共包含9行。 每行 9 个整数（每个数都在 0—9 的范围内），表示一个尚未填满的数独方格，未填的空格用“0”表示。 每两个数字之间用一个空格隔开。 输出格式 输出可以得到的靶形数独的最高分数。 如果这个数独无解，则输出整数-1。 数据范围 40%的数据，数独中非 0 数的个数不少于 30。 80%的数据，数独中非 0 数的个数不少于 26。 100%的数据，数独中非 0 数的个数不少于 24。 输入样例： 7 0 0 9 0 0 0 0 11 0 0 0 0 5 9 0 00 0 0 2 0 0 0 8 00 0 5 0 2 0 0 0 30 0 0 0 0 0 6 4 84 1 3 0 0 0 0 0 00 0 7 0 0 2 0 9 02 0 1 0 6 0 8 0 40 8 0 5 0 4 0 1 2 输出样例： 2829 题解：思路给我之前写的 数独题解 一模一样，这里多了一个get_source()函数用来获取填入数x时可以得到的分数,并用dfs(cnt, source)来记录每一个状态，当cnt减为0时，记录答案的最大值并返回，继续其他的分支 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;using namespace std;const int N = 9;int r[9], c[9], cell[3][3];//使用位运算来表示行，列和九宫格已经出现了的数int ones[1 &lt;&lt; N], map[1 &lt;&lt; N]; //ones表示i的二进制中有多少个1int g[10][10], ans = -1;int lowbit(int x) //lowbit运算，返回最低位的1以及后面的0&#123; return x &amp; (-x);&#125;int get(int x, int y)//获得x行y列还有哪些数可以选&#123; return r[x] &amp; c[y] &amp; cell[x / 3][y / 3];//位运算相与&#125;int get_source(int x, int y) //获得该坐标下的成绩&#123; return min(min(x, 8 - x), min(y, 8 - y)) + 6;&#125;void init()&#123; //map映射1左移i位对应的是哪个数可以填在九宫格里 for(int i = 0; i &lt; N; i++)map[1 &lt;&lt; i] = i; //枚举所有的状态，求出i的二进制中有多少个1 for(int i = 0; i &lt; 1 &lt;&lt; N; i++)&#123; int s = 0; for(int j = i; j != 0; j -= lowbit(j))s++; ones[i] = s; &#125; //预处理，将行，列，九宫格都初始化为二进制111111111，表示1~9都可以填 for(int i = 0; i &lt; 9; i++)r[i] = c[i] = (1 &lt;&lt; N) - 1; for(int i = 0; i &lt; 3; i++) for(int j = 0; j &lt; 3; j++) cell[i][j] = (1 &lt;&lt; N) - 1;&#125;bool dfs(int cnt, int source)&#123; if(cnt == 0)&#123; ans = max(ans, source); return false; //return false表示将所有的状态都搜索一遍 &#125; //找出可选方案数最少的格子 int minv = 10; int x, y; for(int i = 0; i &lt; 9; i++)&#123; for(int j = 0; j &lt; 9; j++)&#123; if(g[i][j] == 0)&#123; //t表示该格子有多少个可以填的数 int t = ones[get(i, j)]; if(t &lt; minv)&#123; minv = t; x = i, y = j; &#125; &#125; &#125; &#125; //枚举可以填入的数 for(int i = get(x, y); i != 0; i -= lowbit(i))&#123; int t = map[lowbit(i)]; r[x] -= 1 &lt;&lt; t; c[y] -= 1 &lt;&lt; t; cell[x / 3][y / 3] -= 1 &lt;&lt; t; g[x][y] = t + 1; dfs(cnt - 1, source + get_source(x, y) * (t + 1)); //恢复现场 r[x] += 1 &lt;&lt; t; c[y] += 1 &lt;&lt; t; cell[x / 3][y / 3] += 1 &lt;&lt; t; g[x][y] = 0; &#125; return false;&#125;int main()&#123; init(); int cnt = 0, source = 0;; for(int i = 0; i &lt; N; i++)&#123; for(int j = 0; j &lt; N; j++)&#123; int x; cin &gt;&gt; x; g[i][j] = x; //如果这个数已经填在了九宫格里，则需要在行，列和九空格中去掉该数 if(x != 0)&#123; r[i] -= 1 &lt;&lt; (x - 1);//(去掉x这个数，需要将1左移(x - 1)位) c[j] -= 1 &lt;&lt; (x - 1); cell[i / 3][j / 3] -= 1 &lt;&lt; (x - 1); source += get_source(i, j) * x;//统计分数 &#125; else cnt++; //统计有多少个空位需要填 &#125; &#125; dfs(cnt, source); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","path":"2019/08/20/搜索/靶形数独(数独1变形)/","date":"08-20","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"回转游戏(Astar + dfs)","text":"题目描述如下图所示，有一个“#”形的棋盘，上面有1,2,3三种数字各8个。 给定8种操作，分别为图中的A~H。 这些操作会按照图中字母和箭头所指明的方向，把一条长为8的序列循环移动1个单位。 例如下图最左边的“#”形棋盘执行操作A后，会变为下图中间的“#”形棋盘，再执行操作C后会变成下图最右边的“#”形棋盘。 给定一个初始状态，请使用最少的操作次数，使“#”形棋盘最中间的8个格子里的数字相同。 输入格式 输入包含多组测试用例。 每个测试用例占一行，包含24个数字，表示将初始棋盘中的每一个位置的数字，按整体从上到下，同行从左到右的顺序依次列出。 输入样例中的第一个测试用例，对应上图最左边棋盘的初始状态。 当输入只包含一个“0”的行时，表示输入终止。 输出格式 每个测试用例输出占两行。 第一行包含所有移动步骤，每步移动用大写字母“A~G”中的一个表示，字母之间没有空格，如果不需要移动则输出“No moves needed”。 第二行包含一个整数，表示移动完成后，中间8个格子里的数字。 如果有多种方案，则输出字典序最小的解决方案。 输入样例： 1 1 1 1 3 2 3 2 3 1 3 2 2 3 1 2 2 2 3 1 2 1 3 31 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 30 输出样例： AC2 DDHH2 题解： 1.确定dfs框架:dfs(depth, k)depth表示当前操作的步数,k表示步数限制 2.设计预估函数:首先计算出格子里出现最多次数的数字是k,剩下的数字有m个与k不同,那么把中间8个格子里的数字都变为k,至少需要m次操作因此我们可以m为估价即可 3.采用迭代加深的方法,可以先从深度为初始状态的预估值m开始从小到大依次限制操作次数，在每个dfs状态下，如果“当前深度步数 + 估价 &gt; 深度限制” 则直接回溯 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int a[10][10];char ans[100];int f() //估价函数&#123; int cnt[5] = &#123;0&#125;; for(int i = 3; i &lt;= 5; i++) for(int j = 3; j &lt;= 5; j++)&#123; if(i == 4 &amp;&amp; j == 4)continue; cnt[a[i][j]]++; &#125; return 8 - max(cnt[1], max(cnt[2], cnt[3]));&#125;bool dfs(int depth, int K)&#123; if(depth &gt;= K)&#123; for(int i = 3; i &lt;= 5; i++) for(int j = 3; j &lt;= 5; j++)&#123; if(i == 4 &amp;&amp; j == 4)continue; if(a[i][j] != a[3][3])return false; &#125; return true; &#125; if(depth + f() &gt; K)return false; //8个方向深搜，保证此次操作不会回到上一个状态 if(depth == 0 || (depth &gt; 0 &amp;&amp; ans[depth - 1] != 'F'))&#123; ans[depth] = 'A'; for(int i = 0; i &lt; 7; i++) a[i][3] = a[i + 1][3]; a[7][3] = a[0][3]; if(dfs(depth + 1, K))return true; for(int i = 8; i &gt;= 2; i--) a[i][3] = a[i - 1][3]; //恢复现场 a[1][3] = a[8][3]; &#125; if(depth == 0 || (depth &gt; 0 &amp;&amp; ans[depth - 1] != 'E'))&#123; ans[depth] = 'B'; for(int i = 0; i &lt; 7; i++) a[i][5] = a[i + 1][5]; a[7][5] = a[0][5]; if(dfs(depth + 1, K))return true; for(int i = 8; i &gt;= 2; i--) a[i][5] = a[i - 1][5]; a[1][5] = a[8][5]; &#125; if(depth == 0 || (depth &gt; 0 &amp;&amp; ans[depth - 1] != 'H'))&#123; ans[depth] = 'C'; for(int i = 8; i &gt;= 2; i--) a[3][i] = a[3][i - 1]; a[3][1] = a[3][8]; if(dfs(depth + 1, K))return true; for(int i = 0; i &lt; 7; i++) a[3][i] = a[3][i + 1]; a[3][7] = a[3][0]; &#125; if(depth == 0 || (depth &gt; 0 &amp;&amp; ans[depth - 1] != 'G'))&#123; ans[depth] = 'D'; for(int i = 8; i &gt;= 2; i--) a[5][i] = a[5][i - 1]; a[5][1] = a[5][8]; if(dfs(depth + 1, K))return true; for(int i = 0; i &lt; 7; i++) a[5][i] = a[5][i + 1]; a[5][7] = a[5][0]; &#125; if(depth == 0 || (depth &gt; 0 &amp;&amp; ans[depth - 1] != 'B'))&#123; ans[depth] = 'E'; for(int i = 8; i &gt;= 2; i--) a[i][5] = a[i - 1][5]; a[1][5] = a[8][5]; if(dfs(depth + 1, K))return true; for(int i = 0; i &lt; 7; i++) a[i][5] = a[i + 1][5]; a[7][5] = a[0][5]; &#125; if(depth == 0 || (depth &gt; 0 &amp;&amp; ans[depth - 1] != 'A'))&#123; ans[depth] = 'F'; for(int i = 8; i &gt;= 2; i--) a[i][3] = a[i - 1][3]; a[1][3] = a[8][3]; if(dfs(depth + 1, K))return true; for(int i = 0; i &lt; 7; i++) a[i][3] = a[i + 1][3]; a[7][3] = a[0][3]; &#125; if(depth == 0 || (depth &gt; 0 &amp;&amp; ans[depth - 1] != 'D'))&#123; ans[depth] = 'G'; for(int i = 0; i &lt; 7; i++) a[5][i] = a[5][i + 1]; a[5][7] = a[5][0]; if(dfs(depth + 1, K))return true; for(int i = 8; i &gt;= 2; i--) a[5][i] = a[5][i - 1]; a[5][1] = a[5][8]; &#125; if(depth == 0 || (depth &gt; 0 &amp;&amp; ans[depth - 1] != 'C'))&#123; ans[depth] = 'H'; for(int i = 0; i &lt; 7; i++) a[3][i] = a[3][i + 1]; a[3][7] = a[3][0]; if(dfs(depth + 1, K))return true; for(int i = 8; i &gt;= 2; i--) a[3][i] = a[3][i - 1]; a[3][1] = a[3][8]; &#125; return false;&#125;int main()&#123; scanf(\"%d\", &amp;a[1][3]); while(a[1][3])&#123; cin &gt;&gt; a[1][5] &gt;&gt; a[2][3] &gt;&gt; a[2][5]; for(int i = 1; i &lt;= 7; i++) cin &gt;&gt; a[3][i]; cin &gt;&gt; a[4][3] &gt;&gt; a[4][5]; for(int i = 1; i &lt;= 7; i++) cin &gt;&gt; a[5][i]; cin &gt;&gt; a[6][3] &gt;&gt; a[6][5] &gt;&gt; a[7][3] &gt;&gt; a[7][5]; for(int i = f(); ;i++)&#123; if(dfs(0, i))&#123; if(i == 0)&#123; cout &lt;&lt; \"No moves needed\" &lt;&lt; endl; cout &lt;&lt; a[3][3] &lt;&lt; endl; break; &#125; for(int j = 0; j &lt; i; j++)cout &lt;&lt; ans[j]; cout &lt;&lt; endl; cout &lt;&lt; a[3][3] &lt;&lt; endl; break; &#125; &#125; scanf(\"%d\", &amp;a[1][3]); &#125; return 0;&#125;","path":"2019/08/19/搜索/回转游戏-Astar-dfs/","date":"08-19","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"},{"name":"A*","slug":"A","permalink":"http://zhumenger.top/tags/A/"}]},{"title":"排书(A* + dfs)","text":"题目描述给定n本书，编号为1-n。 在初始状态下，书是任意排列的。 在每一次操作中，可以抽取其中连续的一段，再把这段插入到其他某个位置。 我们的目标状态是把书按照1-n的顺序依次排列。 求最少需要多少次操作。 输入格式 第一行包含整数T，表示共有T组测试数据。 每组数据包含两行，第一行为整数n，表示书的数量。 第二行为n个整数，表示1-n的一种任意排列。 同行数之间用空格隔开。 输出格式 每组数据输出一个最少操作次数。 如果最少操作次数大于或等于5次，则输出”5 or more”。 每个结果占一行。 数据范围 1≤n≤15 输入样例： 3 61 3 4 6 2 55 5 4 3 2 1106 8 5 3 4 7 2 9 1 10 输出样例： 2 35 or more 题解： 1.枚举长度i，当长度为i时有n - i + 1种不同的选择,有n - i种可以插入的位置，所以可以得到每个状态所有的分(n - i) * (n - i + 1)(1 &lt;= i &lt;= n - 1)的总和, 为560种 数量为(n - i) * (n - i + 1)(1 &lt;= i &lt;= n - 1)的总和, 为560种, 2.题目要求在4次操作内是否能实现目标, 4层搜索树的规模为560^4,时间复杂度过大,所以这里可以用到A*算法来做 3.首先我们需要得到预估函数值,在目标状态下,第i本书的后面应该是第i + 1本书,我们称i + 1 是 i 的正确后继, 在 任意状态我们可以算出错误后继的总个数tot,我们每进行一次操作,在最理想的情况下可以减少3个错误后继,消 除所有的错误后继,需要 tot / 3 (向上取整)个操作因此我们可以将预估函数设计为f(s) = tot / 3(向上取整), tot表 示在状态s下书的错误后继总数 4.采用迭代加深的方法，从起始状态dfs,每次将抽取的一段移动到它的后面某个位置，当进入状态s时，判断当 前深度 + 预估值f(s)是否超出了步数限制,直到找到正确答案。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 20;int a[N];int n;int ans;void dfs(int depth, int K)&#123; int tot = 0; for(int i = 0; i &lt; n - 1; i++) //找出书的错误后继 if(a[i] + 1 != a[i + 1]) tot++; if(tot == 0)&#123; //如果书摆放正确 ans = min(depth, ans);//更新答案 return ; &#125; if((depth + (tot + 2) / 3) &gt; K) return ; //判断判断当前深度depth + 预估值f(s)是否超出了步数限制K for(int i = 1; i &lt; n; i++)&#123; //枚举长度 for(int j = 0; j + i - 1 &lt; n; j ++)&#123; //枚举起点和终点 for(int k = j + 1; k + i - 1 &lt; n; k++)&#123; //枚举要插入的位置 int b[20]; for(int o = 0; o &lt; n; o++) b[o] = a[o]; for(int o = k; o &lt;= k + i - 1; o++)//移动 a[o] = b[o - k + j]; for(int o = i + j; o &lt;= k + i - 1; o ++) a[o - i] = b[o]; dfs(depth + 1, K); for(int o = 0; o &lt; n; o++)//恢复现场 a[o] = b[o]; &#125; &#125; &#125; return ;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; ans = 6; for(int k = 1; k &lt;= 4 &amp;&amp; ans == 6; k++) dfs(0, k); if(ans == 6) cout &lt;&lt; \"5 or more\" &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/08/19/搜索/排书-Astar + dfs/","date":"08-19","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"},{"name":"A*","slug":"A","permalink":"http://zhumenger.top/tags/A/"}]},{"title":"骑士(Astar + dfs)","text":"题目描述在一个5×5的棋盘上有12个白色的骑士和12个黑色的骑士， 且有一个空位。在任何时候一个骑士都能按照骑士的走法（它可以走到和它横坐标相差为1，纵坐标相差为2或者横坐标相差为2，纵坐标相差为1的格子）移动到空位上。 给定一个初始的棋盘，怎样才能经过移动变成如下目标棋盘： 为了体现出骑士精神，他们必须以最少的步数完成任务。 Input第一行有一个正整数T（T&lt;=10） 表示一共有T组数据 接下来有T个55的矩形。0表示白色骑士1表示黑色骑士，表示空位。(每组数据间有空行) Output 对每组数据都输出一行。如果能在15不以内（包括15）到达目标状态，则输出步数，否则输出“Bored!”没有引号。 Sample Input 2 1011001*11101110100100000 01011110*1011100101000100 Sample Output 7 Bored! 题解： 迭代加深的A*算法: 1.A*算法与dfs结合，这里的估价函数表示到达目的状态需要的最少的步数, 2.构建dfs(depth, x, y, k), depth表示到达(x, y)点时所需要的步数，k表示步数限制； 3.如果当前深度depth + 预估函数f &gt; k 则直接返回， 如果预估函数的值为0，说明已经到达目的状态，返回答案即可， 不断加大深度限制k，直到找到答案 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int dx[8] = &#123;-2, -2, -1, 1, 2, 2, -1, 1&#125;; //8个点遍历int dy[8] = &#123;-1, 1, 2, 2, -1, 1, -2, -2&#125;;char End[6][6] = &#123;\"11111\", \"01111\", \"00*11\", \"00001\", \"00000\"&#125;;//目的状态char g[6][6], f[6][6];int flag;int check() //预估函数,表示到达目的状态所需要的最少的步数&#123; int cnt = 0; for(int i = 0; i &lt; 5; i++) for(int j = 0; j &lt; 5; j++) if(f[i][j] != End[i][j]) cnt++; return cnt;&#125;void dfs(int death, int x, int y, int k)//深度限制为k时，到达(x, y)的当前步数为depth&#123; if(flag)return ; if(check() == 0)&#123; //如果到达目的状态 flag = 1; return ; &#125; if(death + check() - 1 &gt; k)return ; //当前步数 + 预估步数 &gt; 深度限制k for(int i = 0; i &lt; 8; i++)&#123; //8个方向遍历 int a = x + dx[i]; int b = y + dy[i]; if(a &gt;= 0 &amp;&amp; a &lt; 5 &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; 5)&#123; swap(f[a][b], f[x][y]); dfs(death + 1, a, b, k); swap(f[a][b], f[x][y]); &#125; &#125; return ;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; flag = 0; int x, y; for(int i = 0; i &lt; 5; i++)&#123; for(int j = 0; j &lt; 5; j++)&#123; cin &gt;&gt; g[i][j]; if(g[i][j] == '*') x = i, y = j; &#125; &#125; for(int i = 0; i &lt;= 15; i++)&#123; //增加深度限制 for(int i = 0; i &lt; 5; i ++) for(int j = 0; j &lt; 5; j++) f[i][j] = g[i][j]; dfs(0, x, y, i); if(flag)&#123; printf(\"%d\\n\", i); break; &#125; &#125; if(!flag)printf(\"Bored!\\n\"); &#125; return 0;&#125;","path":"2019/08/18/搜索/骑士-Astar-dfs/","date":"08-18","excerpt":"","tags":[{"name":"A*","slug":"A","permalink":"http://zhumenger.top/tags/A/"}]},{"title":"八数码(Astar + bfs)","text":"题目描述在一个3×3的网格中，1~8这8个数字和一个“X”恰好不重不漏地分布在这3×3的网格中。 例如： 1 2 3X 4 67 5 8 在游戏过程中，可以把“X”与其上、下、左、右四个方向之一的数字交换（如果存在）。 我们的目的是通过交换，使得网格变为如下排列（称为正确排列）： 1 2 34 5 67 8 X 例如，示例中图形就可以通过让“X”先后与右、下、右三个方向的数字交换成功得到正确排列。 交换过程如下： 1 2 3 1 2 3 1 2 3 1 2 3X 4 6 4 X 6 4 5 6 4 5 67 5 8 7 5 8 7 X 8 7 8 X 把“X”与上下左右方向数字交换的行动记录为“u”、“d”、“l”、“r”。 现在，给你一个初始网格，请你通过最少的移动次数，得到正确排列。 输入格式 输入占一行，将3×3的初始网格描绘出来。 例如，如果初始网格如下所示：1 2 3 x 4 6 7 5 8 则输入为：1 2 3 x 4 6 7 5 8 输出格式 输出占一行，包含一个字符串，表示得到正确排列的完整行动记录。 如果不存在解决方案，则输出”unsolvable”。 输入样例： 2 3 4 1 5 x 7 6 8 输出样例 ullddrurdllurdruldr 题解： 八数码问题无解: 当且仅当展开的逆序对数量是奇数1.使用A*算法搜索一种移动步数最少的方案, 预估函数可以是当前状态到目标状态的所有曼哈顿距离之和;2.建立二元组(dist + f(state), state) state表示当前状态， 建立二叉堆，从堆中不断的取出从初态到当前状态state已经移动过的步数f(state)最小的一个状态进行扩展，当终态第一次被取出时，就得到了答案;3.由于每一个状态都是用字符串来表示的,所以我们可以用hash来记录当前状态是否出现过,我们还需要俩个哈希变量prev和dist分别来记录移动的轨迹和距离 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;unordered_map&gt;using namespace std;int dx[] = &#123;0, 0, 1, -1&#125;;int dy[] = &#123;1, -1, 0, 0&#125;;char op[] = &#123;'r', 'l', 'd', 'u'&#125;;int f(string state) //得到当前状态到最终状态的预估值&#123; int res = 0; for(int i = 0; i &lt; state.size(); i++)&#123; if(state[i] != 'x')&#123; int t = state[i] - '1'; res += abs(i / 3 - t / 3) + abs(i % 3 - t % 3); &#125; &#125; return res;&#125;string bfs(string start)&#123; string end = \"12345678x\"; //终态 unordered_map&lt;string, int &gt; dist; //表示距离 unordered_map&lt;string, bool&gt; st; //记录当前状态是否出现过 unordered_map&lt;string, pair&lt;string, char&gt;&gt; prev; //当前状态的上一个状态是谁，并记录操作方法 priority_queue&lt;pair&lt;int, string&gt;, vector&lt;pair&lt;int, string&gt;&gt;, greater&lt;pair&lt;int, string&gt;&gt;&gt; q;//建立二叉堆 q.push(&#123;0, start&#125;); while(q.size())&#123; auto t = q.top(); q.pop(); string state = t.second; if(state == end)break; if(st[state])continue; st[state] = true; int step = dist[state]; int x, y; for(int i = 0; i &lt; state.size(); i++)&#123; //找到空格 if(state[i] == 'x')&#123; x = i / 3; y = i % 3; break; &#125; &#125; string source = state; for(int i = 0; i &lt; 4; i++)&#123; //4个方向便利 state = source; int a = x + dx[i]; int b = y + dy[i]; if(a &gt;= 0 &amp;&amp; a &lt; 3 &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; 3)&#123; //判断是否合法 swap(state[x * 3 + y], state[a * 3 + b]); //移动 if(!dist[state] || dist[state] &gt; step + 1)&#123; //如果当前状态没有出现过,或者距离更短 dist[state] = step + 1; //更新 prev[state] = &#123;source, op[i]&#125;; //记录 q.push(&#123;dist[state] + f(state),state&#125;); //入队 &#125; &#125; &#125; &#125; string res; while(end != start)&#123; //倒序得到答案 res += prev[end].second; end = prev[end].first; &#125; reverse(res.begin(), res.end()); //翻转 return res;&#125;int main()&#123; string g, c, seq; while(cin &gt;&gt; c)&#123; g += c; if(c != \"x\") seq += c; &#125; int t = 0; for(int i = 0; i &lt; seq.size(); i++) //求逆序对 for(int j = i + 1; j &lt; seq.size(); j++) if(seq[j] &lt; seq[i])t++; if(t % 2 == 1)puts(\"unsolvable\");//如果为奇数,无解 else cout &lt;&lt; bfs(g) &lt;&lt; endl; return 0;&#125;","path":"2019/08/18/搜索/八数码-(Astar + bfs)/","date":"08-18","excerpt":"","tags":[{"name":"A*","slug":"A","permalink":"http://zhumenger.top/tags/A/"},{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"第k短路(Astar + bfs算法)","text":"题目描述给定一张N个点（编号1,2…N），M条边的有向图，求从起点S到终点T的第K短路的长度，路径允许重复经过点或边。 注意： 每条最短路中至少要包含一条边。 输入格式 第一行包含两个整数N和M。 接下来M行，每行包含三个整数A,B和L，表示点A与点B之间存在有向边，且边长为L。 最后一行包含三个整数S,T和K，分别表示起点S，终点T和第K短路。 输出格式 输出占一行，包含一个整数，表示第K短路的长度，如果第K短路不存在，则输出“-1”。 数据范围 1≤S,T≤N≤10000≤M≤1051≤K≤10001≤L≤100 输入样例： 2 21 2 52 1 41 2 2 输出样例： 14 题解： a_star(A *)算法 1.求出预估函数:预处理出各个节点到终点T的最短路的长度—反向求单源最短路得到预估数组f(x),2.建立二叉堆,存储(dist + f(x),(dist, x)), x为节点的编号, dist表示从S到节点x走过的距离,起初堆里只有(0 + f(S), (S, 0));3.每次从二叉堆中取出最小的dist + f(x), 然后沿着从x出发的每条边(x, y)进行扩展, 如果节点y被取出的次数未达到k，则将(dist + length(x, y) + f[y], (y, dist + length(x, y)))入队.4.重复2、3步，直到终点T第K次被取出,这时dist便是我们的答案. 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010, M = 200010;typedef pair&lt;int, int &gt; p;int h[N], rh[N], e[M], ne[M], w[M], idx;int dist[N], f[N], st[N];int S, T, K;int n, m;void add(int *h, int a, int b, int c)&#123; e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;&#125;void dijkstra()//迪杰斯特拉求单源最短路得到预估数组&#123; priority_queue&lt;p, vector&lt;p&gt;, greater&lt;p&gt; &gt; q; memset(dist, 0x3f, sizeof dist); dist[T] = 0; q.push(&#123;0, T&#125;); while(q.size())&#123; p t = q.top(); q.pop(); if(st[t.second])continue; st[t.second] = 1; for(int i = rh[t.second]; i != -1; i = ne[i])&#123; int j = e[i]; if(dist[j] &gt; dist[t.second] + w[i])&#123; dist[j] = dist[t.second] + w[i]; q.push(&#123;dist[j], j&#125;); &#125; &#125; &#125; memcpy(f, dist, sizeof dist);&#125;int a_star()//A*算法,每次取出对重当前花费+预估花费最小的那个&#123; priority_queue&lt;pair&lt;int, p&gt;, vector&lt;pair&lt;int, p&gt;&gt;, greater&lt;pair&lt;int, p&gt;&gt; &gt; q; q.push(&#123;f[S], &#123;0, S&#125;&#125;); memset(st, 0, sizeof st); while(q.size())&#123; auto t = q.top(); q.pop(); int ver = t.second.second; int d = t.second.first; if(st[ver] &gt;= K)continue; st[ver]++; if(ver == T &amp;&amp; st[ver] == K)return d; for(int i = h[ver]; i != -1; i = ne[i])&#123; int j = e[i]; if(st[j] &lt; K)&#123; q.push(&#123;d + w[i] + f[j], &#123;d + w[i], j&#125;&#125;); &#125; &#125; &#125; return -1;&#125;int main()&#123; memset(h, -1, sizeof h); memset(rh, -1, sizeof rh); cin &gt;&gt; n &gt;&gt; m; while(m--)&#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(h, a, b, c); add(rh, b, a, c);//建立反向图 &#125; cin &gt;&gt; S &gt;&gt; T &gt;&gt; K; if(S == T)K++;//题目要求每条最短路至少有一条边,如果起点和终点重合,那么求得便是第k + 1 条路, dijkstra(); printf(\"%d\\n\", a_star()); return 0;&#125;","path":"2019/08/18/搜索/第k短路-(Astar + bfs)算法/","date":"08-18","excerpt":"","tags":[{"name":"A*","slug":"A","permalink":"http://zhumenger.top/tags/A/"}]},{"title":"噩梦(双向BFS)","text":"题目描述给定一张N*M的地图，地图中有1个男孩，1个女孩和2个鬼。 字符“.”表示道路，字符“X”表示墙，字符“M”表示男孩的位置，字符“G”表示女孩的位置，字符“Z”表示鬼的位置。 男孩每秒可以移动3个单位距离，女孩每秒可以移动1个单位距离，男孩和女孩只能朝上下左右四个方向移动。 每个鬼占据的区域每秒可以向四周扩张2个单位距离，并且无视墙的阻挡，也就是在第k秒后所有与鬼的曼哈顿距离不超过2k的位置都会被鬼占领。 注意： 每一秒鬼会先扩展，扩展完毕后男孩和女孩才可以移动。 求在不进入鬼的占领区的前提下，男孩和女孩能否会合，若能会合，求出最短会合时间。 输入格式 第一行包含整数T，表示共有T组测试用例。 每组测试用例第一行包含两个整数N和M，表示地图的尺寸。 接下来N行每行M个字符，用来描绘整张地图的状况。（注意：地图中一定有且仅有1个男孩，1个女孩和2个鬼） 输出格式 每个测试用例输出一个整数S，表示最短会合时间 如果无法会合则输出-1。 每个结果占一行。 数据范围 1&lt;n,m&lt;800 输入样例： 3 5 6XXXXXXXZ..ZXXXXXXXM.G………5 6XXXXXXXZZ..XXXXXXXM…....G…10 10………...X……...M.X…X.X……….X..X.X.X.………X..XX….X.X….G…X…ZX.X……Z..X..X 输出样例： 1 1-1 题解： 双向bfs问题:1.用俩个队列分别从男孩的起始位置和女孩的起始位置开始进行bfs;2.每一轮中，男孩bfs3次,女孩bfs1次;3.使用数组d来记录男孩和女孩的可达性;4.在bfs时,计算新状态与鬼之间的曼哈顿距离是否合法;5.最后便可以得到我们想要的答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int N = 810;typedef pair&lt;int, int&gt; p;int n, m;char g[N][N];int st[N][N];//记录三种状态st = 0表示没有人经过该点,st = 1表示男孩经过该点,st = 2表示女孩经过改点int dx[] = &#123;0, 0, 1, -1&#125;;int dy[] = &#123;1, -1, 0, 0&#125;;p boy, girl, ghost[2];//记录男孩、女孩和鬼的位置bool check(int x, int y, int step)//判断该点是否合格&#123; if(x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || g[x][y] == 'X')return false; for(int i = 0;i &lt; 2; i++)&#123; if(abs(x - ghost[i].first) + abs(y - ghost[i].second) &lt;= 2 *step)return false; &#125; return true;&#125;int bfs()&#123; int cnt = 0; memset(st, 0, sizeof st); for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++)&#123; if(g[i][j] == 'M')boy = &#123;i, j&#125;; if(g[i][j] == 'G')girl = &#123;i, j&#125;; if(g[i][j] == 'Z')ghost[cnt++] = &#123;i, j&#125;; &#125; int step = 0; queue&lt;p&gt; qb, qg; qb.push(boy), qg.push(girl); while(qb.size() || qg.size())&#123; step++;//时间 for(int i = 0; i &lt; 3; i++)&#123; //每一秒男孩走3次 for(int j = 0, len = qb.size(); j &lt; len; j++)&#123; p t = qb.front(); qb.pop(); int x = t.first, y = t.second; if(!check(x, y, step))continue;//如果不合格 for(int k = 0; k &lt; 4; k++)&#123; int a = x + dx[k]; int b = y + dy[k]; if(check(a, b, step))&#123; if(st[a][b] == 2)return step; //如果女孩在该点 if(!st[a][b])&#123; st[a][b] = 1; qb.push(&#123;a, b&#125;); &#125; &#125; &#125; &#125; &#125; for(int i = 0; i &lt; 1; i++)&#123; //女孩走一次 for(int j = 0, len = qg.size(); j &lt; len; j++)&#123; p t = qg.front(); qg.pop(); int x = t.first, y = t.second; if(!check(x, y, step))continue; for(int k = 0; k &lt; 4; k++)&#123; int a = x + dx[k]; int b = y + dy[k]; if(check(a, b, step))&#123; if(st[a][b] == 1)return step; //如果男孩在该点 if(!st[a][b])&#123; st[a][b] = 2; qg.push(&#123;a, b&#125;); &#125; &#125; &#125; &#125; &#125; &#125; return -1;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) scanf(\"%s\", g[i]); printf(\"%d\\n\", bfs()); &#125; return 0;&#125;","path":"2019/08/18/搜索/噩梦-双向BFS/","date":"08-18","excerpt":"","tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"矩阵(二维数组哈希)","text":"题目描述 给定一个M行N列的01矩阵（只包含数字0或1的矩阵），再执行Q次询问，每次询问给出一个A行B列的01矩阵，求该矩阵是否在原矩阵中出现过。 输入格式 第一行四个整数M,N,A,B。 接下来一个M行N列的01矩阵，数字之间没有空格。 接下来一个整数Q。 接下来Q个A行B列的01矩阵，数字之间没有空格。 输出格式 对于每个询问，输出1表示出现过，0表示没有出现过。 数据范围 A≤100，M,N,B≤1000，Q≤1000 输入样例： 3 3 2 21110001113 110011110011 输出样例： 1 01 题解： 二维数组哈希 1.先预处理出每一行的哈希值，这样可以在O(1)的时间内获得任意子段的哈希值 2.二维数组哈希的进制位数从子矩阵的右下角开始，比如长和宽都为2子矩阵的哈希值为:h = a[0] [0] * p^3 + a[0] [1] * p^2 + a[1] [0] * p^1 + a[1] [1] * p^0 3.假设要求一个a行b列的子矩阵是否出现过，用S来表示子矩阵的哈希值；先枚举每一列，维护一个长度为b的矩阵，再枚举每一行，获得每一行长度为b的哈希值，那么原先子矩阵的所有位数都要扩大P^b, 那么此时的子矩阵的哈希值S = S * p ^ b + hash(i, l, r) 4.如果矩阵的行数大于a行，还需要减去最上面的那一行，此时子矩阵的哈希值S = S - hash(i - a + 1, l, r) * p ^ (a*b) 5.获得每个子矩阵的hash值后，用哈希表来存储即可 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;unordered_map&gt;using namespace std;typedef unsigned long long ULL;const int N = 1010, base = 131;int n, m, a, b;ULL h[N][N], p[N * N];char s[N];ULL get(ULL f[], int l, int r)&#123; return f[r] - f[l - 1] * p[r - l + 1];&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b; p[0] = 1; for(int i = 1; i &lt;= n * m; i++) p[i] =p[i - 1] * base; for(int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; (s + 1); //预处理每一行的哈希值 for(int j = 1; j &lt;= m; j++)h[i][j] = h[i][j - 1] * base + s[j] - '0'; &#125; unordered_map&lt;ULL, int&gt; S; for(int i = b; i &lt;= m; i++)&#123; ULL ans = 0; int l = i - b + 1, r = i; for(int j = 1; j &lt;= n; j++)&#123; //每处理一行，前面的数的位数都要提升b位,再加上本行的哈希值 //便是这个矩阵的哈希值 ans = ans * p[b] + get(h[j], l, r); //如果j &gt; a, 还需要减去之前的一行，保证这个矩阵是a * b的 //也就是减去之前一行的哈希值乘以它的位数，即h[j - a]这一行 //在l到r这个区间的a * b位 if(j &gt; a)ans -= get(h[j - a], l, r) * p[a * b]; if(j &gt;= a)S[ans]++; &#125; &#125; int k; cin &gt;&gt; k; while(k--)&#123; ULL ans = 0; for(int i = 0; i &lt; a; i++)&#123; cin &gt;&gt; s; for(int j = 0; j &lt; b; j++)ans = ans * base + s[j] - '0'; &#125; if(S[ans])puts(\"1\"); else puts(\"0\"); &#125; return 0;&#125;","path":"2019/08/02/数据结构基础/矩阵-二维数组哈希/","date":"08-02","excerpt":"","tags":[{"name":"哈希","slug":"哈希","permalink":"http://zhumenger.top/tags/哈希/"}]},{"title":"装满的油箱(bfs)","text":"题目描述有N个城市（编号0、1…N-1）和M条道路，构成一张无向图。 在每个城市里边都有一个加油站，不同的加油站的单位油价不一样。 现在你需要回答不超过100个问题，在每个问题中，请计算出一架油箱容量为C的车子，从起点城市S开到终点城市E至少要花多少油钱？ 输入格式 第一行包含两个整数N和M。 第二行包含N个整数，代表N个城市的单位油价，第i个数即为第i个城市的油价pi。 接下来M行，每行包括三个整数u,v,d，表示城市u与城市v之间存在道路，且车子从u到v需要消耗的油量为d。接下来一行包含一个整数q，代表问题数量。 接下来q行，每行包含三个整数C、S、E，分别表示车子油箱容量、起点城市S、终点城市E。 输出格式 对于每个问题，输出一个整数，表示所需的最少油钱。 如果无法从起点城市开到终点城市，则输出”impossible”。 每个结果占一行。 数据范围 1≤N≤10001≤M≤100001≤pi≤1001≤d≤1001≤C≤100 输入样例： 5 510 10 20 12 130 1 90 2 81 2 11 3 112 3 72 10 0 320 1 4 输出样例： 170impossible 题解： 广搜+dp:使用二元组(city, fuel)来表示每个状态,city为城市编号,fuel为油箱中剩余的汽油量,并使用数组d[city] [fuel]储存最少花费起始状态为(S, 0),对于每个状态:1.如果fuel &lt; C,可以加1升油,扩展到新状态(city, fuel + 1), 花费在城市city增加1升油的钱,用数组d[city] [fuel + 1]维护花费的较小值;2.对于每条从city出发的边(city, next),若边权大小w不超过fuel,可以开往城市next,用数组d[next] [fuel - w]维护花费的较小值;我们不断取出队列中花费最少的状态,并用该状态不断的去更新其他的状态,利用BFS()的性质,只要到达终点的某一状态第一次被取出,即可停止BFS,输出答案,时间复杂度为O(NClogN) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N = 1010, M = 10010, INF = 0x3f3f3f3f;struct p&#123; int city; //城市 int fuel; //油量 int cost; //花费&#125;;int h[N], e[2 * M], ne[2 * M], w[2 * M], idx;//邻接表int d[N][110], a[N];bool vis[N][110];int n, m, c, st, ed; void add(int a, int b, int c)//建图&#123; e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;&#125;bool operator &lt; (const p &amp;a, const p &amp;b)//按照花费从小到大排序 &#123; //优先队列中的是从大到小排序的,重载的时候也从大到小排排序,这样便反了过来 return a.cost &gt; b.cost;&#125;int bfs()&#123; p now, next; priority_queue&lt;p&gt; q; memset(d, INF, sizeof d); memset(vis, false, sizeof vis); d[st][0] = 0; q.push(&#123;st, 0, 0&#125;);//st表示起点的城市 while(q.size())&#123; now = q.top(); q.pop(); int city = now.city; int fuel = now.fuel; int cost = now.cost; vis[city][fuel] = true;//该状态已经出现过了 if(city == ed) return cost;//如果到达终点,直接返回 //如果剩余的fuel油量小于C, 且下一个状态没有出现过,花费更少 if(fuel &lt; c &amp;&amp; !vis[city][fuel + 1] &amp;&amp; d[city][fuel + 1] &gt; d[city][fuel] + a[city])&#123; d[city][fuel + 1] = d[city][fuel] + a[city];//更新花费,加一升油的钱 //下一状态 next.city = city; next.fuel = fuel + 1; next.cost = d[city][fuel + 1]; q.push(next);//添加到队列中去 &#125; for(int i = h[city]; i != -1; i = ne[i])&#123;//遍历可以到达的所有边 int j = e[i]; //如果fuel &lt; 边权w, 且该状态没有被遍历过, 花费更少 if(fuel &gt;= w[i] &amp;&amp; !vis[j][fuel - w[i]] &amp;&amp; d[j][fuel - w[i]] &gt; d[city][fuel])&#123; d[j][fuel - w[i]] = d[city][fuel];//更新花费,并开往下一个城市 next.city = j;//下一个状态 next.fuel = fuel - w[i]; next.cost = d[j][fuel - w[i]]; q.push(next);//添加到队列中去 &#125; &#125; &#125; return -1;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof h); for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; while(m--)&#123; int a, b ,c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); add(b, a, c); &#125; int q; cin &gt;&gt; q; while(q--)&#123; cin &gt;&gt; c &gt;&gt; st &gt;&gt; ed; int ans = bfs(); if(ans == -1)cout &lt;&lt; \"impossible\" &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/08/02/搜索/装满的油箱/","date":"08-02","excerpt":"","tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"电路维修(双端队列)","text":"题目描述达达是来自异世界的魔女，她在漫无目的地四处漂流的时候，遇到了善良的少女翰翰，从而被收留在地球上。 翰翰的家里有一辆飞行车。 有一天飞行车的电路板突然出现了故障，导致无法启动。 电路板的整体结构是一个R行C列的网格（R,C≤500），如下图所示。 每个格点都是电线的接点，每个格子都包含一个电子元件。 电子元件的主要部分是一个可旋转的、连接一条对角线上的两个接点的短电缆。 在旋转之后，它就可以连接另一条对角线的两个接点。 电路板左上角的接点接入直流电源，右下角的接点接入飞行车的发动装置。 达达发现因为某些元件的方向不小心发生了改变，电路板可能处于断路的状态。 她准备通过计算，旋转最少数量的元件，使电源与发动装置通过若干条短缆相连。 不过，电路的规模实在是太大了，达达并不擅长编程，希望你能够帮她解决这个问题。 输入格式 输入文件包含多组测试数据。 第一行包含一个整数T，表示测试数据的数目。 对于每组测试数据，第一行包含正整数R和C，表示电路板的行数和列数。 之后R行，每行C个字符，字符是&quot;/&quot;和&quot;\\&quot;中的一个，表示标准件的方向。 输出格式 对于每组测试数据，在单独的一行输出一个正整数，表示所需的缩小旋转次数。 如果无论怎样都不能使得电源和发动机之间连通，输出NO SOLUTION。 数据范围 1≤R,C≤500,1≤T≤5 输入样例： 1 3 5\\/\\\\////\\\\ 输出样例： 1 题解： 广搜+双端队列运用最短路的做法,把每个坐标看成无向图中的一个节点, 若当前位于(x, y)这个节点,枚举这个节点可以到达的4个对角的坐标,连成对角线,如果该对角线和给出的标准件的线段重合,则边权值为0,如果垂直,则需要转动一次,边权值为1. 可以通过双端队列来从小到大储存权值,如果权值为0,则添加到队头,如果权值为1,则添加到队尾,每次弹出队头,运用广搜的性质,就可以求出我们想要的答案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;deque&gt;#include&lt;cstring&gt;using namespace std;const int N = 510, INF = 0x3f3f3f3f;struct p&#123; int x; int y;&#125;;char s[N][N];int d[N][N];int n, m;//节点坐标向4个方向连线的对角线的坐标int dx[] = &#123;-1, -1, 1, 1&#125;;int dy[] = &#123;-1, 1, 1, -1&#125;;//给出的标准件,所对应的的下标int ix[] = &#123;-1, -1, 0, 0&#125;;int iy[] = &#123;-1, 0, 0, -1&#125;;//与4个方向相连的对角线,\"\\\\\"表示转义字符char cs[] = \"\\\\/\\\\/\";int bfs()&#123; memset(d, INF, sizeof d); deque&lt;p&gt; q; q.push_back(&#123;0, 0&#125;); d[0][0] = 0; while(q.size())&#123; p t = q.front(); q.pop_front(); for(int i = 0; i &lt; 4; i++)&#123;//4个方向遍历 int x1 = t.x + dx[i]; int y1 = t.y + dy[i]; int x2 = t.x + ix[i]; int y2 = t.y + iy[i]; char str = cs[i]; int w = 0; if(x1 &gt;= 0 &amp;&amp; x1 &lt;= n &amp;&amp; y1 &gt;= 0 &amp;&amp; y1 &lt;= m)&#123; if(str != s[x2][y2])w = 1;//如果不重合,边权值为1 if(d[x1][y1] &gt; d[t.x][t.y] + w)&#123; //更新最小值 d[x1][y1] = d[t.x][t.y] + w; if(w)q.push_back(&#123;x1, y1&#125;);//添加到队尾 else q.push_front(&#123;x1, y1&#125;);//添加到队头 &#125; &#125; &#125; &#125; if(d[n][m] == INF) return -1; else return d[n][m];&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) cin &gt;&gt; s[i]; int t = bfs(); if(t == -1)cout &lt;&lt; \"NO SOLUTION\" &lt;&lt; endl; else cout &lt;&lt; t &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/08/02/搜索/电路维修-双端队列/","date":"08-02","excerpt":"","tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"矩阵距离(曼哈顿距离)","text":"给定一个N行M列的01矩阵A，A[i] [j] 与 A[k] [l] 之间的曼哈顿距离定义为： dist(A[i] [j],A[k] [l])=|i−k|+|j−l| 输出一个N行M列的整数矩阵B，其中： B[i] [j]=min(1 ≤ x ≤ N,1 ≤ y ≤ M, A[x] [y] = 1)dist(A[i] [j], A[x] [y]) 输入格式 第一行两个整数n,m。 接下来一个N行M列的01矩阵，数字之间没有空格。 输出格式 一个N行M列的矩阵B，相邻两个整数之间用一个空格隔开。 数据范围 1≤N,M≤1000 输入样例： 3 4000100110110 输出样例： 3 2 1 02 1 0 01 0 0 1 题解： 求最短距离, 利用广搜的性质，将所有为1的点放入到队列中去，不断更新到其他点的距离即可 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int N = 1010, INF = 0x3f3f3f3f;struct p&#123; int x, y;&#125;;char a[N][N];int d[N][N];int dx[] = &#123;0, 1, 0, -1&#125;;int dy[] = &#123;1, 0, -1, 0&#125;;int n, m;queue&lt;p&gt; q;void bfs()&#123; while(q.size())&#123; p t = q.front(); q.pop(); for(int i = 0; i &lt; 4; i++)&#123; int x = t.x + dx[i]; int y = t.y + dy[i]; if(x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; d[x][y] == INF)&#123; d[x][y] = d[t.x][t.y] + 1; q.push(&#123;x, y&#125;); &#125; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; memset(d, INF, sizeof d); for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt;m; j++)&#123; cin &gt;&gt; a[i][j]; if(a[i][j] == '1')&#123; q.push(&#123;i, j&#125;); d[i][j] = 0; &#125; &#125; bfs(); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++) cout &lt;&lt; d[i][j] &lt;&lt; ' '; cout &lt;&lt; endl; &#125; return 0; &#125;","path":"2019/07/31/搜索/矩阵距离-曼哈顿距离/","date":"07-31","excerpt":"","tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"立体推箱子(复杂迷宫问题)","text":"题目描述立体推箱子是一个风靡世界的小游戏。 游戏地图是一个N行M列的矩阵，每个位置可能是硬地（用”.”表示）、易碎地面（用”E”表示）、禁地（用”#”表示）、起点（用”X”表示）或终点（用”O”表示）。 你的任务是操作一个1×1×2的长方体。 这个长方体在地面上有两种放置形式，“立”在地面上（1×1的面接触地面）或者“躺”在地面上（1×2的面接触地面）。 在每一步操作中，可以按上下左右四个键之一。 按下按键之后，长方体向对应的方向沿着棱滚动90度。 任意时刻，长方体不能有任何部位接触禁地，并且不能立在易碎地面上。 字符”X”标识长方体的起始位置，地图上可能有一个”X”或者两个相邻的”X”。 地图上唯一的一个字符”O”标识目标位置。 求把长方体移动到目标位置（即立在”O”上）所需要的最少步数。 在移动过程中，”X”和”O”标识的位置都可以看作是硬地被利用。 输入格式 输入包含多组测试用例。 对于每个测试用例，第一行包括两个整数N和M。 接下来N行用来描述地图，每行包括M个字符，每个字符表示一块地面的具体状态。 当输入用例N=0，M=0时，表示输入终止，且该用例无需考虑。 输出格式 每个用例输出一个整数表示所需的最少步数，如果无解则输出”Impossible”。 每个结果占一行。 数据范围 3≤N,M≤500 输入样例： 7 7 ####### #..X### #..##O# #….E# #….E# #…..# #######0 0 输出样例： 10 题解： 广度优先搜索：迷宫问题的变形版,处理情况比较复杂,变化的量有长方体的坐标以及状态,我们可以用一个三元组(x, y, lie)代表一个状态： 1.lie = 0表示长方体立在(x, y)处； 2.lie = 1表示长方体横着躺着,左半部分位置在(x, y); 3.lie = 2, 表示长方体纵着躺着,上半部分位置在(x, y)。 并用d[x] [y] [lie]记录从起始状态到达每一个状态的最小步数,然后广搜就行 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;const int N = 510;struct p&#123; //状态 int x; int y; int lie;&#125;;p st, ed;//记录起点和终点的状态char a[N][N]; //地图int n, m, d[N][N][3];//记录最小步数的数组//4个方向遍历int dx[] = &#123;0, 0, 1, -1&#125;;int dy[] = &#123;1, -1, 0, 0&#125;;//状态为lie(0, 1, 2),向4个方向(左右上下)转动时,x, y坐标的变化以及lie状态的变化int next_x[3][4] = &#123;&#123;0, 0, -2, 1&#125;, &#123;0, 0, -1, 1&#125;, &#123;0, 0, -1, 2&#125;&#125;;int next_y[3][4] = &#123;&#123;-2, 1, 0, 0&#125;, &#123;-1, 2, 0, 0&#125;, &#123;-1, 1, 0, 0&#125;&#125;;int next_lie[3][4] =&#123;&#123;1, 1, 2, 2&#125;, &#123;0, 0, 1, 1&#125;, &#123;2, 2, 0, 0&#125;&#125;;//判断坐标是否合法bool hefa(int x, int y)&#123; return (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m);&#125;//处理起点和终点void parse_st_ed()&#123; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; if(a[i][j] == 'O')&#123; //记录终点的坐标 ed.x = i; ed.y = j; ed.lie = 0; a[i][j] = '.'; &#125; if(a[i][j] == 'X')&#123;//找到起点的坐标 for(int k = 0; k &lt; 4; k++)&#123; //4个方向遍历,判断长方体的状态 int x = i + dx[k]; int y = j + dy[k]; if(hefa(x, y) &amp;&amp; a[x][y] == 'X')&#123; st.x = min(i, x), st.y = min(j, y); st.lie = k &lt; 2 ? 1 : 2; a[i][j] = a[x][y] = '.'; break; &#125; &#125; if(a[i][j] == 'X')st.x = i, st.y = j, st.lie = 0;//如果周围没有'X',说明长方体是立着的,记录当前的起点坐标, &#125; &#125; &#125;&#125;//判断滚动时的状态是否合法bool hefa_2(p next)&#123; if(!hefa(next.x, next.y))return false;//坐标合法 if(a[next.x][next.y] == '#')return false;//判断是否能走 //判断长方体3个状态时是否合法 if(next.lie == 0 &amp;&amp; a[next.x][next.y] != '.')return false; if(next.lie == 1 &amp;&amp; a[next.x][next.y + 1] == '#')return false; if(next.lie == 2 &amp;&amp; a[next.x + 1][next.y] == '#')return false; return true;&#125;int bfs()//广搜&#123; queue&lt;p &gt; q; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) for(int k = 0; k &lt; 3; k++) d[i][j][k] = -1; //初始化 d[st.x][st.y][st.lie] = 0; q.push(st); while(q.size())&#123; p t = q.front(); q.pop(); if(t.x == ed.x &amp;&amp; t.y == ed.y &amp;&amp; t.lie == ed.lie)&#123;//判断是否走到了终点 return d[t.x][t.y][t.lie]; break; &#125; for(int i = 0; i &lt; 4; i++)&#123;//4个方向翻滚 p next; next.x = t.x + next_x[t.lie][i]; next.y = t.y + next_y[t.lie][i]; next.lie = next_lie[t.lie][i]; if(!hefa_2(next))continue; if(d[next.x][next.y][next.lie] == -1)&#123;//如果没有访问过 d[next.x][next.y][next.lie] = d[t.x][t.y][t.lie] + 1; q.push(next); &#125; &#125; &#125; return -1;&#125;int main()&#123; while(cin &gt;&gt; n &gt;&gt; m)&#123; if(n == 0 &amp;&amp; m == 0)break; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) cin &gt;&gt; a[i][j]; parse_st_ed(); int ans = bfs(); if(ans == -1)cout &lt;&lt; \"Impossible\" &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/07/31/搜索/立体推箱子-复杂迷宫问题/","date":"07-31","excerpt":"","tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"送礼物(双向搜索)","text":"题目描述达达帮翰翰给女生送礼物，翰翰一共准备了N个礼物，其中第i个礼物的重量是G[i]。 达达的力气很大，他一次可以搬动重量之和不超过W的任意多个物品。 达达希望一次搬掉尽量重的一些物品，请你告诉达达在他的力气范围内一次性能搬动的最大重量是多少。 输入格式 第一行两个整数，分别代表W和N。 以后N行，每行一个正整数表示G[i]。 输出格式 仅一个整数，表示达达在他的力气范围内一次性能搬动的最大重量。 数据范围 1≤N≤45,1≤W,G[i]≤2^31−1 输入样例： 20 57 54 181 输出样例： 19 题解: 双向搜索:如果直接进行指数型搜索的话,复杂度是O(2 ^ N),对于这道题2^45复杂度过大,这时我们就可以利用双向搜索的思想,把礼物分半 首先,我们从前一半礼物选出若干个,可能达到的0~w的之间的所有重量值，存放到一个数组里,排序并去重然后,我们进行第二次搜索,尝试从后一半礼物中选择一些,对于每一个选出的重量t,在第一部分得到的数组中进行二分查找 &lt;= w - t的数值最大的的那个,用俩者的和更新答案即可如何优化：1.优化搜索顺序:把礼物按照从大到小的顺序排序后在分半,搜索2.选取恰当的这班划分点:一般取k = n / 2 + 2的位置进行二分的效率会高一些 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N = 50;typedef long long ll;bool vis[N];int n, m, a[N], k;int w[1 &lt;&lt; 24], cnt;int ans;//u表示前u种礼物的选取,s表示前u种礼物选取的总重量void dfs_1(int u, int s)&#123; if(u == k)&#123; w[cnt ++ ] = s; return ; &#125; if((ll)s + a[u] &lt;= m)dfs_1(u + 1, s + a[u]); dfs_1(u + 1, s);&#125;void dfs_2(int u, int s)&#123; if(u == n)&#123; //二分查找,一下俩种方法都行 //int l = 0, r = cnt - 1; //while(l &lt; r)&#123; // int mid = l + r + 1 &gt;&gt; 1; // if((ll)s + w[mid] &lt;= m)l = mid; /// else r = mid - 1; // &#125; int r = upper_bound(w, w + cnt, m - s) - w; if((ll)w[r - 1] + s &lt;= m)ans = max(ans, w[r - 1] + s);//更新答案 return ; &#125; if((ll)s + a[u] &lt;= m)dfs_2(u + 1, s + a[u]); dfs_2(u + 1, s);&#125;int main()&#123; cin &gt;&gt; m &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; sort(a, a + n); reverse(a, a + n); k = n / 2 + 2; dfs_1(0, 0); sort(w, w + cnt); cnt = unique(w, w + cnt) - w;//返回去重之后元素的个数 dfs_2(k, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","path":"2019/07/31/搜索/送礼物-双向搜索/","date":"07-31","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"加成序列(迭代加深)","text":"题目描述满足如下条件的序列X（序列中元素被标号为1、2、3…m）被称为“加成序列”： 1、X[1]=1 2、X[m]=n 3、X[1]&lt;X[2]&lt;…&lt;X[m-1]&lt;X[m] 4、对于每个 kk（2≤k≤m2≤k≤m）都存在两个整数 ii 和 jj （1≤i,j≤k−11≤i,j≤k−1，ii 和 jj 可相等），使得X[k]=X[i]+X[j]。 你的任务是：给定一个整数n，找出符合上述条件的长度m最小的“加成序列”。 如果有多个满足要求的答案，只需要找出任意一个可行解。 输入格式输入包含多组测试用例。 每组测试用例占据一行，包含一个整数n。 当输入为单行的0时，表示输入结束。 输出格式对于每个测试用例，输出一个满足需求的整数序列，数字之间用空格隔开。 每个输出占一行。 数据范围1≤n≤100 输入样例： 5 71215770 输出样例： 1 2 4 51 2 4 6 71 2 4 8 121 2 4 5 10 151 2 4 8 9 17 34 68 77 迭代加深搜索:如果我们想要的答案在一个比较浅的节点上,而树的深度比较深，那么我们进行深度优先搜索的时候便会浪费大量的时间此时，我们可以限制搜索的深度,如果在当前深度找不到答案,就把深度的限制增加,重新搜索，直到找到答案为止,这道题便是这样的一个思路 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 110;int a[N];bool vis[N];int n, k;bool dfs(int u, int k)&#123; if(u == k)return a[u - 1] == n; //暴力枚举 for(int i = u - 1; i &gt;= 0; i--)&#123; for(int j = i; j &gt;= 0; j--)&#123; int s = a[i] + a[j]; if(vis[s] || s &gt; n || s &lt;= a[u - 1])continue; a[u] = s; if(dfs(u + 1, k))return true; &#125; &#125; return false;&#125;int main()&#123; a[0] = 1; while(cin &gt;&gt; n &amp;&amp; n)&#123; int k = 1; //如果不成功，增加搜索深度的限制 while(!dfs(1, k))&#123; memset(vis, false, sizeof vis); k++; &#125; for(int i = 0; i &lt; k; i++)cout &lt;&lt; a[i] &lt;&lt; ' '; cout &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/07/30/搜索/加成序列/","date":"07-30","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"木棒(学会剪枝)","text":"题目描述乔治拿来一组等长的木棒，将它们随机地砍断，使得每一节木棍的长度都不超过50个长度单位。 然后他又想把这些木棍恢复到为裁截前的状态，但忘记了初始时有多少木棒以及木棒的初始长度。 请你设计一个程序，帮助乔治计算木棒的可能最小长度。 每一节木棍的长度都用大于零的整数表示。 注意: 数据中可能包含长度大于50的木棒，请在处理时忽略这些木棒。 输入格式输入包含多组数据，每组数据包括两行。 第一行是一个不超过64的整数，表示砍断之后共有多少节木棍。 第二行是截断以后，所得到的各节木棍的长度。 在最后一组数据之后，是一个零。 输出格式为每组数据，分别输出原始木棒的可能最小长度，每组数据占一行。 输入样例： 9 5 2 1 5 2 1 5 2 14 1 2 3 40 输出样例： 6 5 题解： 从小到大枚举len, len应该是木棍长度总和sum的约数,并且原始木棍的根数ans = sum / len 搜索的3个状态dfs(int stick, int cnt, int last),stick表示当前正在拼接的原始木棍(前stick - 1个原始木棍已经拼接完成),cnt 表示当前正在拼接的原始木棍的长度,last表示已经拼接到当前原始木棍中的上一个小木棍,暴力枚举就行 如何剪枝，优化时间:一.优化搜索顺序把木棍的长度从大到小排序，优先尝试较长的木棍,减少尝试的次数二.排除等效冗余的情况(1).保证加入到原始木棍中的小木棍的长度是递减的，也就是深搜的时候从当前木棍的下一个木棍开始(2).对于当前的原始木棍，记录当前尝试拼接的小木棍，如果搜索失败,回溯时不再搜索跟其长度相等的木棍(必定也会失败)(3).如果第一次尝试拼入木棍就失败的话,那么这个分治必然也是失败的,因为在拼入这些木棍前,面对的原始木棍都是还没有拼接的,他们都是等效的. 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;const int N = 100;bool vis[N];int n, a[N], len, ans;bool dfs(int stick, int cnt, int last)&#123; if(stick &gt; ans)return true;//全部拼接完毕 if(cnt == len) return dfs(stick + 1, 0, 0);////第stick个原始木棍拼接完毕，拼接下一个 int fail = 0;//用来记录最近一次拼接并且搜索失败的木棍 for(int i = last; i &lt; n; i++)&#123; //没有被访问过，并且可以加上当前小木棍，并且长度和上一次失败的长度不一样 if(!vis[i] &amp;&amp; cnt + a[i] &lt;= len &amp;&amp; fail != a[i])&#123; vis[i] = true;//被访问过 if(dfs(stick, cnt + a[i], i + 1))return true;//如果搜索成功 //搜索失败 vis[i] = 0;//不选这个点 fail = a[i];//记录失败的木棍的长度 ////如果cnt为0,或者相加正好是len,但是失败了,那么一定是失败了 if(cnt == 0 || cnt + a[i] == len)return false; &#125; &#125; return false;&#125;int main()&#123; while(cin &gt;&gt; n &amp;&amp; n)&#123; int sum = 0, val = 0; int k = 0, x; for(int i = 0; i &lt; n; i++)&#123; scanf(\"%d\", &amp;x); if(x &lt;= 50)&#123; a[k++] = x; sum += x;//记录总长度 val = max(val, x); &#125; &#125; n = k; //从大到小排序 sort(a, a + n); reverse(a, a + n); for(len = val; len &lt;= sum; len++)&#123; if(sum % len == 0)&#123; ans = sum / len; memset(vis, false, sizeof vis); if(dfs(1, 0, 0))break; &#125; &#125; printf(\"%d\\n\", len); &#125; return 0;&#125;","path":"2019/07/30/搜索/木棒/","date":"07-30","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"数独(dfs)","text":"题目描述数独是一种传统益智游戏，你需要把一个9 × 9的数独补充完整，使得图中每行、每列、每个3 × 3的九宫格内数字1~9均恰好出现一次。 请编写一个程序填写数独。 输入格式输入包含多组测试用例。 每个测试用例占一行，包含81个字符，代表数独的81个格内数据（顺序总体由上到下，同行由左到右）。 每个字符都是一个数字（1-9）或一个”.”（表示尚未填充）。 您可以假设输入中的每个谜题都只有一个解决方案。 文件结尾处为包含单词“end”的单行，表示输入结束。 输出格式每个测试用例，输出一行数据，代表填充完全后的数独。 输入样例： .2738..1..1…6735…….293.5692.8………..6.1745.364…….9518…7..8..6534.……52..8.4……3…9…5.1…6..2..7……..3…..6…1……….7.4…….3.end 输出样例： 527389416819426735436751829375692184194538267268174593643217958951843672782965341416837529982465371735129468571298643293746185864351297647913852359682714128574936 *题解: * 1.使用二进制初始化行、列和九宫格中能够填入的数有哪些；使用一个数组记录每个数的二进制下都多少个1；2.再使用一个数组记录二进制下1表示的是选的哪个数，使用lowbit运算可以返回能够填入九宫格中的数是哪个3.初始化完毕后，读入字符串，并使用位运算处理出行、列和九宫格中已经填入的数有哪些4.考虑时间的优化，我们每次从九宫格中可以填入的数最少的那个开始，这样我们的选择填入的数就会比较少，减少了时间的复杂度 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;using namespace std;const int N = 9;int r[N], c[N], cell[3][3];//使用位运算来表示行，列和九宫格已经出现了的数char str[100];int ones[1 &lt;&lt; N], map[1 &lt;&lt; N];//ones表示i的二进制中有多少个1inline int lowbit(int x)//lowbit运算，返回最低位的1以及后面的0&#123; return x &amp; (~x + 1);&#125;inline int get(int x, int y)//获得x行y列还有哪些数可以选&#123; return r[x] &amp; c[y] &amp; cell[x / 3][y / 3];//位运算相与&#125;void init()&#123; //预处理，将行，列，九宫格都初始化为二进制111111111，表示1~9都可以填 for(int i = 0; i &lt; 9; i++)r[i] = c[i] = (1 &lt;&lt; N) - 1; for(int i = 0; i &lt; 3; i ++) for(int j = 0; j &lt; 3; j++) cell[i][j] = (1 &lt;&lt; N ) -1; &#125;bool dfs(int cnt)&#123; if(cnt == 0)return true; //找出可选方案数最少的格子 int minv = 10; int x, y; for(int i = 0; i &lt; N; i++)&#123; for(int j = 0; j &lt; N; j++)&#123; if(str[i * 9 + j] == '.')&#123; int t = ones[get(i, j)]; if(t &lt; minv)&#123; minv = t; x = i, y = j; &#125; &#125; &#125; &#125; for(int i = get(x, y); i; i -= lowbit(i))&#123; int t = map[lowbit(i)]; r[x] -= 1 &lt;&lt; t; c[y] -= 1 &lt;&lt; t; cell[x / 3][y / 3] -= 1 &lt;&lt; t; str[x * 9 + y] = '1' + t; if(dfs(cnt - 1))return true; r[x] += 1 &lt;&lt; t; c[y] += 1 &lt;&lt; t; cell[x / 3][y / 3] += 1 &lt;&lt; t; str[x * 9 + y] = '.'; &#125; return false;&#125;int main()&#123; for(int i = 0; i &lt; N; i++)map[1 &lt;&lt; i] = i;//map映射1左移i位对应的是哪个数可以填在九宫格里 //枚举所有的状态，求出i的二进制中有多少个1 for(int i = 0; i &lt; 1 &lt;&lt; N ; i++)&#123; int s = 0; for(int j = i; j != 0; j -=lowbit(j))s++; ones[i] = s;//求出i的二进制中有多少个1 &#125; while(cin &gt;&gt; str &amp;&amp; str[0] != 'e')&#123; init();//初始化 int cnt = 0; for(int i = 0, k = 0; i &lt; 9; i++)&#123; for(int j = 0; j &lt; 9; j++, k++)&#123; if(str[k] != '.')&#123;//如果这个数已经填在了九宫格里，则需要在行，列和九空格中去掉该数 int t = str[k] - '1'; //让该位的二进制为0即可 r[i] -= 1 &lt;&lt; t; c[j] -= 1 &lt;&lt; t; cell[i / 3][j / 3] -= 1 &lt;&lt; t; &#125; else cnt++; &#125; &#125; dfs(cnt); cout &lt;&lt; str &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/07/29/搜索/数独/","date":"07-29","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"},{"name":"搜索","slug":"搜索","permalink":"http://zhumenger.top/tags/搜索/"}]},{"title":"可达性统计","text":"题目描述 给定一张N个点M条边的有向无环图，分别统计从每个点出发能够到达的点的数量。 输入格式 第一行两个整数N,M，接下来M行每行两个整数x,y，表示从x到y的一条有向边。 输出格式 输出共N行，表示每个点能够到达的点的数量。 数据范围 1≤N,M≤30000 输入样例： 10 103 82 32 55 95 92 33 94 82 104 9 输出样例： 1 63 32 11 11 1 题解： x点能到的点的个数等于该点加上它的所有子节点可以达到的点个数，我们可以先拓扑排序，然后从后往前遍历,用位运算求出所有点能够达到的点的数量，位运算我们使用bitset来做： C++ bitset 用法1.C++的 bitset 在 bitset 头文件中，它是一种类似数组的结构，它的每一个元素只能是０或１，每个元素仅用１bit空间。可以用下标的形式对其进行访问 1234567891011bitset&lt;8&gt; foo (&quot;10011011&quot;);cout &lt;&lt; foo.count() &lt;&lt; endl; //5 （count函数用来求bitset中1的位数，foo中共有５个１cout &lt;&lt; foo.size() &lt;&lt; endl; //8 （size函数用来求bitset的大小，一共有８位cout &lt;&lt; foo.test(0) &lt;&lt; endl; //true （test函数用来查下标处的元素是０还是１，并返回false或true，此处foo[0]为１，返回truecout &lt;&lt; foo.test(2) &lt;&lt; endl; //false （同理，foo[2]为０，返回falsecout &lt;&lt; foo.any() &lt;&lt; endl; //true （any函数检查bitset中是否有１cout &lt;&lt; foo.none() &lt;&lt; endl; //false （none函数检查bitset中是否没有１cout &lt;&lt; foo.all() &lt;&lt; endl; //false （all函数检查bitset中是全部为１ 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;bitset&gt;#include&lt;queue&gt;using namespace std;const int N = 3e4 + 10;int n, m;int h[N], e[N], ne[N], idx;int d[N], seq[N];bitset&lt;N&gt; f[N];//bitsetvoid add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;void topsort()&#123; queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i++) if(!d[i])q.push(i); int k = 0; while(q.size())&#123; int t = q.front(); q.pop(); seq[k++] = t; for(int i = h[t]; i != -1; i = ne[i])&#123; int u = e[i]; d[u]--; if(!d[u])q.push(u); &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof h); for(int i = 0; i &lt; m; i++)&#123; int a, b; cin &gt;&gt;a &gt;&gt; b; add(a, b); d[b]++; &#125; topsort(); for(int i = n - 1; i &gt;= 0; i--)&#123; int u = seq[i]; f[u][u] = 1; for(int j = h[u]; j != -1; j = ne[j])&#123; f[u] |= f[e[j]]; &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; cout &lt;&lt; f[i].count() &lt;&lt; endl;//求f[i]中1的个数 &#125;&#125;","path":"2019/07/28/搜索/可达性统计/","date":"07-28","excerpt":"","tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"生日礼物","text":"生日礼物题目描述 翰翰18岁生日的时候，达达给她看了一个神奇的序列 A1,A2,…,ANA1,A2,…,AN。 她被允许从中选择不超过 M 个连续的部分作为自己的生日礼物。 翰翰想要知道选择元素之和的最大值。 你能帮助她吗？ 输入格式 第一行包含两个整数N,M。 第二行包含N个整数A1A1~ANAN。 输出格式 输出一个整数，表示答案。 数据范围 1≤N,M≤105|Ai|≤104 输入样例： 5 22 -3 2 -1 2 输出样例： 5 题解： 1.将整个序列分为正负交替的序: 如果数x与前面的符号相同，就加起来，否则新开一个空间存储当前的数x2.统计正数的个数cnt，如果cnt &lt;= m,把所有正数加起来，输出便是我们的答案3.如果cnt &gt; m, 必须减少正数的个数，有俩种做法 1.直接删去最小的正数,2.将俩个正数合并为1个连续子序列，中间必有一个负数，还需要加上负数的值 4.删去正数,或者加上负数，都可以看成减去他们的绝对值，可以用堆来存储他们 的绝对值，以及他们的下标5.如果删除的是正数，正数的俩边都是负数，需要将俩边的负数合并，重新放到堆中。 并删除左右节点，6.如果删除的是负数，负数的俩边都是正数，需要将俩边的正数合并，重新放到堆中。 并删除左右节点， 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#include&lt;queue&gt;#include&lt;vector&gt;const int N = 1e5 + 10;int n, m;int a[N], l[N], r[N];bool vis[N];typedef pair&lt;int, int&gt; p;void remove(int x)&#123; l[r[x]] = l[x]; r[l[x]] = r[x]; vis[x] = true;&#125;int main()&#123; int k = 0; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)&#123; int x; cin &gt;&gt; x; if(x == 0)continue; if(a[k] * x &gt; 0)a[k] += x; else a[++k] = x; &#125; int cnt = 0, res = 0; priority_queue&lt;p, vector&lt;p&gt;, greater&lt;p&gt; &gt; q; for(int i = 1; i &lt;= k; i++)&#123; if(a[i] &gt; 0)&#123; cnt++; res += a[i]; &#125; l[i] = i - 1; r[i] = i + 1; q.push(&#123;abs(a[i]), i&#125;); &#125; while(cnt &gt; m)&#123; while(vis[q.top().second])q.pop(); p t = q.top(); q.pop(); int v = t.first, point = t.second; if(l[point] != 0 &amp;&amp; r[point] != k + 1 || a[point] &gt; 0)&#123; res -= v; cnt--; int left = l[point], right = r[point]; a[point] += a[left] + a[right]; q.push(&#123;abs(a[point]), point&#125;); remove(left); remove(right); &#125; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;","path":"2019/07/27/数据结构基础/生日礼物/","date":"07-27","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"链表","slug":"链表","permalink":"http://zhumenger.top/tags/链表/"},{"name":"二叉堆","slug":"二叉堆","permalink":"http://zhumenger.top/tags/二叉堆/"}]},{"title":"黑盒子(堆)","text":"题目描述 黑盒子代表一个原始的数据库。 它可以用来储存整数数组，并且它拥有一个特殊变量i。 在最开始，黑盒子是空的，并且i=0。 现在对黑盒子进行一系列的操作处理，操作包括以下两种： 1、ADD(x)：表示将x加入到黑盒子中。2、GET：使i增加1，输出黑盒子中第i小的数值（即将所有数按升序排序后的第i个数）。 1、A(1),A(2),…,A(M)：这个序列由加入到黑盒子内的所有元素按加入顺序排列后得到， 2、u(1),u(2),…,u(N): 这个序列的第i项表示的是第i次GET操作时，盒子内元素的数量。 现在请你根据给出的序列A和u求出操作过程中输出的所有数值。 输入格式 输入包括三行。 第一行包含两个整数M和N，表示A序列和u序列的长度。 第二行包含M个整数，表示A序列的每一个元素。 第三行包含N个整数，表示u序列的每一个元素。 同行每个数之间用空格隔开。 输出格式 输出操作过程中所有GET操作输出的数值。 每个数值占一行。 数据范围 |A(i)|&lt;=2∗1091≤N≤M≤30000,对于所有p（1≤p≤N）, p≤u(p)≤M成立 输入样例： 7 43 1 -4 2 8 -1000 21 2 6 6 输出样例： 3 31 2 题解： 输出序列中第i小的数，我们可以用堆来做： 1.首先定义俩个堆，一个大根堆，一个小根堆，大根堆用来存储前x - 1小的数，小根堆用来存剩下的数 2.俩个堆满足：大根堆中的最大值一定是小于小根堆中的最小值的，这样我们输出第x小的数时，直接输出小根堆的堆顶即可 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int N = 30010;int a[N];int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; priority_queue&lt;int&gt; q1;//大根堆,维护前x - 1个最小值， priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q2;//小根堆，堆顶是第x个最小值 int k = 1; for(int i = 1; i &lt;= m; i++)&#123; int x; cin &gt;&gt; x; while(k &lt;= x)&#123; //如果盒子内的元素个数小于get时的元素个数时 q2.push(a[k]); //大根堆的最大值一定是小于小根堆中的最小值，如果不是，则交换 //这样可以用大根堆维护前x - 1个最小值 if(!q1.empty() &amp;&amp; q1.top() &gt; q2.top())&#123; int u = q1.top(); q1.pop(); q2.push(u); int t = q2.top(); q2.pop(); q1.push(t); &#125; k++; &#125; cout &lt;&lt; q2.top() &lt;&lt; endl; q1.push(q2.top()); q2.pop(); &#125; return 0;&#125;","path":"2019/07/27/数据结构基础/黑盒子-堆/","date":"07-27","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"堆","slug":"堆","permalink":"http://zhumenger.top/tags/堆/"}]},{"title":"奶牛矩阵（二维KMP）","text":"题目描述 每天早上，农夫约翰的奶牛们被挤奶的时候，都会站成一个R行C列的方阵。 现在在每个奶牛的身上标注表示其品种的大写字母，则所有奶牛共同构成了一个R行C列的字符矩阵。 现在给定由所有奶牛构成的矩阵，求它的最小覆盖子矩阵的面积是多少。 如果一个子矩阵无限复制扩张之后得到的矩阵能包含原来的矩阵，则称该子矩阵为覆盖子矩阵。 输入格式 第1行：输入两个用空格隔开的整数，R和C。 第2..R+1行：描绘由奶牛构成的R行C列的矩阵，每行C个字符，字符之间没有空格。 输出格式 输出最小覆盖子矩阵的面积。（每个字符的面积为1） 数据范围 1≤R≤10000,1≤C≤75 输入样例： 2 5ABABAABABA 输出样例： 2 提示 样例中给出的矩阵的最小覆盖子矩阵为AB，面积为2。 题解：KMP中Next数组的应用，如果n是n - Next[n]的倍数，那么n - Next[n]便是该字符串的循环节 1.可以把每一行看成一个字符，求出行的Next数组,并求出循环节 2.把每一列看做一个字符，求出列的Next数组，并求出循环节 3.俩个循环节的乘积便是该矩阵循环节的面积的大小 代码如下： 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 10010, M = 80;int Next[N];char s1[N][M], s2[M][N];int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; s1[i]; for(int i = 1; i &lt;= n; i++) for(int j = 0; j &lt; m; j++) s2[j + 1][i - 1] = s1[i][j];//将数组翻转，用来求列的Next数组 for(int i = 2, j = 0; i &lt;= n; i++)&#123;//求出行的Next数组 while(j &amp;&amp; strcmp(s1[i], s1[j + 1]))j = Next[j]; if(!strcmp(s1[i], s1[j + 1]))j++; Next[i] = j; &#125; int a = n - Next[n]; Next[1] = 0; for(int i = 2, j = 0; i &lt;= m; i++)&#123;//求出列的Next数组 while(j &amp;&amp; strcmp(s2[i], s2[j + 1]))j = Next[j]; if(!strcmp(s2[i], s2[j + 1]))j++; Next[i] = j; &#125; int b = m - Next[m]; cout &lt;&lt; a * b &lt;&lt; endl; return 0;&#125;","path":"2019/07/27/数据结构基础/奶牛矩阵（二维KMP）/","date":"07-27","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"kmp","slug":"kmp","permalink":"http://zhumenger.top/tags/kmp/"}]},{"title":"树的最小表示","text":"树的最小表示题目描述 给你两个字符串，字符串由01组成，0表示向远离起点并且没有走过的一条路走去，1表示原路返回 请你求出这俩个字符串是否是一个线路图 输入格式 第一行输入一个正整数n，代表测试用例数量。 每个测试用例由两行组成，每行输入一个由字符“0”和“1”构成的字符串，长度最多为3000， 两个字符串都描述了一种线路图的探索路线。 输出格式 对于每个测试用例，如果两个字符串描述的线路图可以视为同一个线路图，则输出same。 否则，输出different。 每行输出一个结果。 输入样例： 2 0010011101001011010001101100101101001011001001110011000111010101 输出样例： samedifferent 题解： 树的最小表示，将所有子节点的dfs序从小到大排序，并连接起来，比较他们的最小表示是否相同即可 代码如下： 123456789101112131415161718192021222324252627282930313233// 树的最小表示可以递归实现，求出所有子树的dfs序，然后从小到大排序拼接起来#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;string dfs(string seq, int &amp;u)//防止内存超限&#123; vector&lt;string &gt; seqs; u++; while(seq[u] == '0')seqs.push_back(dfs(seq, u)); u++; sort(seqs.begin(), seqs.end()); string s= \"0\"; for( auto res : seqs)s += res; s += \"1\"; return s;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; string a, b; cin &gt;&gt; a &gt;&gt; b; a = '0' + a + '1'; b = '0' + b + '1'; int ua = 0, ub = 0; if(dfs(a, ua) == dfs(b, ub))puts(\"same\"); else puts(\"different\"); &#125; return 0;&#125;","path":"2019/07/27/数据结构基础/树的最小表示/","date":"07-27","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"树的最小表示","slug":"树的最小表示","permalink":"http://zhumenger.top/tags/树的最小表示/"}]},{"title":"城市游戏","text":"题目描述 有一天，小猫rainbow和freda来到了湘西张家界的天门山玉蟾宫，玉蟾宫宫主蓝兔盛情地款待了它们，并赐予它们一片土地。 这片土地被分成N*M个格子，每个格子里写着’R’或者’F’，R代表这块土地被赐予了rainbow，F代表这块土地被赐予了freda。 现在freda要在这里卖萌。。。它要找一块矩形土地，要求这片土地都标着’F’并且面积最大。 但是rainbow和freda的OI水平都弱爆了，找不出这块土地，而蓝兔也想看freda卖萌（她显然是不会编程的……），所以它们决定，如果你找到的土地面积为S，它们将给你3*S两银子。 输入格式 第一行包括两个整数N,M，表示矩形土地有N行M列。 接下来N行，每行M个用空格隔开的字符’F’或’R’，描述了矩形土地。 每行末尾没有多余空格。 输出格式 输出一个整数，表示你能得到多少银子，即(3*最大’F’矩形土地面积)的值。 数据范围 1≤N,M≤1000 输入样例： 5 6R F F F F FF F F F F FR R R F F FF F F F F FF F F F F F 输出样例： 45 题解： 二维数组单调栈问题，这个可以参考Acwing131.直方图中最大的矩形，俩个题的解题思路大致一样，只不过这里需要转化为Acwing131题的形式： 1.首先预处理出每一列连续的F的个数 2.枚举每一行，表示以该行为底，以H(i, j)为高的矩阵可以求得的面积最大值 时间复杂度为O(n * m) 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int h[N][N], l[N], r[N], q[N], t;char a[N][N];int n, m;void get(int h[], int l[])&#123; int t = 0; for(int i = 1; i &lt;= m; i++)&#123; while(t &gt; 0 &amp;&amp; h[q[t]] &gt;= h[i])t--; l[i] = q[t] + 1; q[++t] = i; &#125;&#125;int work(int h[])&#123; get(h, l); reverse(h + 1, h + 1 + m); get(h, r); reverse(h + 1, h + 1 + m); int res = 0; for(int i = 1; i &lt;= m; i++)&#123; res = max(res, h[i] * (m + 1 - r[m + 1 - i] - l[i] + 1)); &#125; return res;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; cin &gt;&gt; a[i][j]; if(a[i][j] == 'F') h[i][j] = 1 + h[i - 1][j]; &#125; &#125; int ans = 0; for(int i = 1; i &lt;= n; i++) ans = max(ans, work(h[i])); cout &lt;&lt; ans * 3 &lt;&lt; endl;&#125;","path":"2019/07/27/数据结构基础/城市游戏(二维单调栈)/","date":"07-27","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"栈","slug":"栈","permalink":"http://zhumenger.top/tags/栈/"}]},{"title":"括号配对问题","text":"一.括号配对问题问题描述 现在，有一行括号序列，请你检查这行括号是否配对。 输入格式 第一行输入一个数N（0&lt;N&lt;=100）,表示有N组测试数据。后面的N行输入多组输入数据 每组输入数据都是一个字符串S(S的长度小于10000，且S不是空串）， 测试数据组数少于5组。数据保证S中只含有”[“, “]”, “(“, “)” 四种字符 输出格式 每组输入数据的输出占一行，如果该字符串中所含的括号是配对的，则输出Yes,如果不配对则输出No 输入样例 3 [(])(])([[] ()]) 输出样例 NoNoYes 题解： 栈的应用，如果栈顶与当前的元素匹配，则弹出栈，否则就入栈，最后看看栈中的元素是否为空即可 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e5 + 10;char st[N];int t;string s;int main()&#123; int n; cin &gt;&gt; n; while(n--)&#123; t = 0; cin &gt;&gt; s; int len = s.size(); for(int i = 0; i &lt; len; i++)&#123; if(t &gt; 0 &amp;&amp; s[i] == ')' &amp;&amp; st[t] == '(')t--; else if(t &gt; 0 &amp;&amp; s[i] == '&#125;' &amp;&amp; st[t] == '&#123;')t--; else if(t &gt; 0 &amp;&amp; s[i] == ']' &amp;&amp; st[t] == '[')t--; else st[++t] = s[i]; &#125; if(t &gt; 0)cout &lt;&lt; \"No\" &lt;&lt; endl; else cout &lt;&lt; \"Yes\" &lt;&lt; endl; &#125; return 0;&#125; 二.括号最长匹配长度题目描述 达达是一名漫画家，她有一个奇特的爱好，就是在纸上画括号。 这一天，刚刚起床的达达画了一排括号序列，其中包含小括号( )、中括号[ ]和大括号{ }，总长度为N。 这排随意绘制的括号序列显得杂乱无章，于是达达定义了什么样的括号序列是美观的： (1) 空的括号序列是美观的； (2) 若括号序列A是美观的，则括号序列 (A)、[A]、{A} 也是美观的； (3) 若括号序列A、B都是美观的，则括号序列AB也是美观的。 例如 [(){}]() 是美观的括号序列，而)({)[}]( 则不是。 现在达达想在她绘制的括号序列中，找出其中连续的一段，满足这段子序列是美观的，并且长度尽量大。 你能帮帮她吗？ 输入格式 输入一行由括号组成的字符串。 输出格式 输出一个整数，表示最长的美观的子段的长度。 数据范围 字符串长度不超过100000。 输入样例：1(&#123;(&#123;((&#123;()&#125;&#125;)&#125;&#123;())&#125;)&#125;)[)&#123;&#123;&#123;([)()((()]]&#125;])[&#123;)]&#125;&#123;[&#125;&#123;) 输出样例： 4 题解： 栈的应用：如果栈顶的与当前的元素能匹配，则出栈，并记录当前能匹配的最长长度，如果不能匹配，则出栈，重新记录长度，找到最大值即可 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e5 + 10;char s[N];stack&lt;int&gt; st;int main()&#123; cin &gt;&gt; s; int ans = 0; int len =strlen(s); for(int i = 0; i &lt; len; i++)&#123; if(s[i] == ')' &amp;&amp; st.size() &amp;&amp; s[st.top()] == '(')st.pop(); else if(s[i] == ']' &amp;&amp; st.size() &amp;&amp; s[st.top()] == '[')st.pop(); else if(s[i] == '&#125;' &amp;&amp; st.size() &amp;&amp; s[st.top()] == '&#123;')st.pop(); else st.push(i); if(st.size())ans = max(ans, i - st.top()); else ans = max(ans, i + 1); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125;","path":"2019/07/27/数据结构基础/括号配对问题/","date":"07-27","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"栈","slug":"栈","permalink":"http://zhumenger.top/tags/栈/"}]},{"title":"表达式计算","text":"表达式计算4题目描述 给出一个表达式,其中运算符仅包含+,-,*,/,^（加 减 乘 整除 乘方）要求求出表达式的最终值。 数据可能会出现括号情况，还有可能出现多余括号情况。 数据保证不会出现大于或等于231231的答案。 数据可能会出现负数情况。 输入格式 输入仅一行，即为表达式。 输出格式 输出仅一行，既为表达式算出的结果。 输入样例： (2+2)^(1+1) 输出样例： 16 题解： 栈的应用：用俩个栈分别存数字和运算符 1.因为有多余括号的情况，所以所限要在字符串前加上字符串长度大小的‘（’进行预处理 2.如果当前字符为数字，则直接存进nums栈中 3.如果当前字符为加或减，首先判断减是否为负号，如果不是，其他运算符的优先级都是大于等于加或减的，所以就可以把括号中所有的元素进行一次操作，直到遇到’(‘为止 4.如果当前字符为乘或除，加、减的优先级都是低于乘除的，所以不能进运算，能进行运算的是乘除和乘方 5.当前运算符为乘方，只有栈顶为乘方才能进行运算 6.如果当前字符为‘(’,直接添加到栈中 7.如果当前元素为’)’，则将括号中所有的元素进行运算，并弹出’(‘ 8.最后输出栈顶元素即可 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;stack&lt;int&gt; nums;stack&lt;char&gt; ops;int qmi(int a, int k)&#123; int res = 1; while (k -- ) res *= a; return res;&#125;void cal()&#123; int a = nums.top(); nums.pop(); int b = nums.top(); nums.pop(); char c = ops.top(); ops.pop(); int d; if (c == '+') d = b + a; else if (c == '-') d = b - a; else if (c == '*') d = b * a; else if (c == '/') d = b / a; else d = qmi(b, a); nums.push(d);&#125;int main()&#123; string str; cin &gt;&gt; str; string left; for (int i = 0; i &lt; str.size(); i ++ ) left += '('; str = left + str + ')'; for (int i = 0; i &lt; str.size(); i ++ ) &#123; if (str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9')//如果是数字 &#123; int j = i, t = 0; while (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')//可能有多位 &#123; t = t * 10 + str[j] - '0'; j ++ ; &#125; nums.push(t); i = j - 1; &#125; else//如果是运算符 &#123; char c = str[i]; if (c == '(') ops.push(c); else if (c == '+' || c == '-') &#123; if (c == '-' &amp;&amp; i &amp;&amp; !(str[i - 1] &gt;= '0' &amp;&amp; str[i - 1] &lt;= '9') &amp;&amp; str[i - 1] != ')')//如果是负号的话 &#123; int j = i + 1, t = 0; while (str[j] &gt;= '0' &amp;&amp; str[j] &lt;= '9')//可能有多位 &#123; t = t * 10 + str[j] - '0'; j ++ ; &#125; nums.push(-t);//添加-t i = j - 1; &#125; else &#123; while (ops.top() != '(') cal(); ops.push(c); &#125; &#125; else if (c == '*' || c == '/') &#123; while (ops.top() == '*' || ops.top() == '/' || ops.top() == '^') cal(); ops.push(c); &#125; else if (c == '^') &#123; while (ops.top() == '^') cal(); ops.push(c); &#125; else if (c == ')') &#123; while (ops.top() != '(') cal(); ops.pop(); &#125; else cout &lt;&lt; \"invalid operator!\" &lt;&lt; endl; &#125; &#125; cout &lt;&lt; nums.top() &lt;&lt; endl; return 0;&#125;","path":"2019/07/23/数据结构基础/表达式计算/","date":"07-23","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"栈","slug":"栈","permalink":"http://zhumenger.top/tags/栈/"}]},{"title":"没有上司的舞会","text":"题目描述 Ural大学有N名职员，编号为1~N。 他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。 每个职员有一个快乐指数，用整数 HiHi 给出，其中 1≤i≤N。 现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。 在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。 输入格式 第一行一个整数N。 接下来N行，第 i 行表示 i 号职员的快乐指数Hi。 接下来N-1行，每行输入一对整数L, K,表示K是L的直接上司。 最后一行输入0,0。 输出格式输出最大的快乐指数。 数据范围1≤N≤6000−128≤Hi≤127 输入样例： 7 11 11 11 11 32 36 47 44 53 50 0 输出样例： 5 *树形DP: * 就是在树或图上的一种DP，一般是某个父节点或子节点有特殊要求的时候用的一种DP 首先是建图，在图上遍历的时候进行DP操作，对于这道题来说我们用F(i, j)来表示i这个节点，状态为 j (用0来表示不选，用1来表示选)值的最大值，对于每个节点我们有俩种操作： 1.选当前这个节点，j 状态为1，它的子节点只能不选，所以f(i, 1) = f(i, 1) + f(u, 0)(u表示 i 的子节点) 2.不选当前这个节点，j 的状态为0，它的子节点可以选，也可以不选，取俩者的最大值 所以f(i, 0) = f(i, 0) + max(f(u, 1), f(u, 0))(u表示 i 的子节点) 3.从任意一个跟节点开始搜索，所以还需要一个数组来储存哪些节点有父节点 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 6010;int n;int happy[N];int h[N], e[N], ne[N], idx;//邻接表建图int f[N][2];bool vis[N];void add(int a, int b)//添加边&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;void dfs(int cur)//搜索，树形DP&#123; f[cur][1] = happy[cur]; for(int i = h[cur]; i != -1; i = ne[i])&#123;//遍历子节点 int j = e[i]; dfs(j); f[cur][0] += max(f[j][0], f[j][1]); f[cur][1] += f[j][0]; &#125;&#125;int main()&#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++)cin &gt;&gt; happy[i];//输入 memset(h, -1, sizeof h); for(int i = 0; i &lt; n - 1; i++)&#123; int a, b; cin &gt;&gt; a &gt;&gt; b; vis[a] = true; //表示a有父节点 add(b, a); &#125; int root = 1; while(vis[root])root++;///找到一个根节点 dfs(root); cout &lt;&lt; max(f[root][0], f[root][1]); return 0;&#125;","path":"2019/07/22/动态规划/没有上司的舞会/","date":"07-22","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"树形DP","slug":"树形DP","permalink":"http://zhumenger.top/tags/树形DP/"}]},{"title":"滑雪","text":"滑雪题目描述 给定一个R行C列的矩阵，表示一个矩形网格滑雪场。 矩阵中第 i 行第 j 列的点表示滑雪场的第 i 行第 j 列区域的高度。 一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。 当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。 下面给出一个矩阵作为例子： 1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9 在给定矩阵中，一条可行的滑行轨迹为24-17-2-1。 在给定矩阵中，最长的滑行轨迹为25-24-23-…-3-2-1，沿途共经过25个区域。 现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。 输入格式 第一行包含两个整数R和C。 接下来R行，每行包含C个整数，表示完整的二维矩阵。 输出格式 输出一个整数，表示可完成的最长滑雪长度。 数据范围 1≤R,C≤3000≤矩阵中整数≤10000 输入样例： 5 51 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9 输出样例： 25 题解： 所谓记忆化搜索是指在搜索过程中，用一个数组来储存已经得到的结果，当我们再次经过这一状态时，直接返回该结果即可，不必再次深度搜索，大大的节省了时间 *代码如下： * 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 310, INF = 0x3f3f3f3f;int a[N][N], f[N][N];int n, m;int dx[]= &#123;0, 1, 0, -1&#125;;int dy[] = &#123;1, 0, -1, 0&#125;;int dfs(int x, int y)&#123; if(f[x][y])return f[x][y]; f[x][y] = 1; //最小是1 for(int k = 0; k &lt; 4; k++)&#123; int i = x + dx[k]; int j = y + dy[k]; if(a[i][j] &lt; a[x][y] &amp;&amp; i &gt;= 1 &amp;&amp; j &gt;= 1 &amp;&amp; i &lt;= n &amp;&amp; j &lt;= m) f[x][y] = max(f[x][y], dfs(i, j) + 1); &#125; return f[x][y];&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; memset(a, INF, sizeof a); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) cin &gt;&gt; a[i][j]; int ans = 0; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) ans = max(ans, dfs(i, j)); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","path":"2019/07/22/搜索/滑雪/","date":"07-22","excerpt":"","tags":[{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"http://zhumenger.top/tags/记忆化搜索/"}]},{"title":"动态规划之子序列问题","text":"一.最长递增子序列I题目描述 给定一个长度为N的数列，求数值严格单调递增的子序列的长度最长是多少。 输入格式 第一行包含整数N。 第二行包含N个整数，表示完整序列。 输出格式 输出一个整数，表示最大长度。 数据范围 1≤N≤1000，−109≤数列中的数≤109 输入样例： 7 3 1 2 1 8 5 6 输出样例： 4 思路： 采用动态规划的思想，用dp[ i ]来表示序列中第i个元素结尾的最长上升子序列的长度那么状态转移方程为： if (a[i] &gt; a[j]) dp[i] = MAX (dp[i], dp[j] + 1); 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;const int N = 1010;int d[N], a[N];int main()&#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; int ans = 0; for(int i = 0; i &lt; n; i++)&#123; d[i] = 1; for(int j = 0; j &lt; i; j++)&#123; if(a[i] &gt; a[j]) d[i] = max(d[i], d[j] + 1); &#125; ans = max(ans, d[i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 二. 最长递增子序列II给定一个长度为N的数列，求数值严格单调递增的子序列的长度最长是多少。 输入格式第一行包含整数N。 第二行包含N个整数，表示完整序列。 输出格式输出一个整数，表示最大长度。 数据范围1≤N≤100000 −109≤数列中的数≤109 输入样例： 7 3 1 2 1 8 5 6 输出样例： 4 题解： 这里的数据范围很大,不能再用上面的那个方法来做这道题 nlgn做法 定义：a[1..n]为原始序列，d[k]表示长度为k的不下降子序列末尾元素的最小值，len表示当前已知的最长子序列的长度 考虑两个数a[x]和a[y]，x&lt;y且a[x]&lt;a[y],且dp[x]=dp[y]，当a[t]要选择时，到底取哪一个构成最优的呢？显然选取a[x]更有潜力，因为可能存在a[x]&lt;a[z]&lt;a[y]，这样a[t]可以获得更优的值。在这里给我们一个启示，当dp[t]一样时，尽量选择更小的a[x]. ​ 按dp[t]=k来分类，只需保留dp[t]=k的所有a[t]中的最小值，设d[k]记录这个值，d[k]=min{a[t],dp[t]=k}。 ​ 这时注意到d的两个特点（重要）： *1. d[k]在计算过程中单调不升； * 2. d数组是有序的，d[1]&lt;d[2]&lt;..d[n]。 ** 利用这两个性质，可以很方便的求解：** 1.设当前已求出的最长上升子序列的长度为len（初始时为1），每次读入一个新元素x： 2.若x&gt;d[len]，则直接加入到d的末尾，且len++；（利用性质2） 3.否则，在d中二分查找，找到第一个比x小的数d[k]，并d[k+1]=x，在这里x&lt;=d[k+1]一定成立（性质1,2）。 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;const int N = 1e5 +10;int a[N], q[N];int main()&#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt;n; i++) cin &gt;&gt; a[i]; int len = 0; for(int i = 0; i &lt; n; i++)&#123; int l = 0, r = len; while(l &lt; r)&#123; int mid = l + r + 1 &gt;&gt; 1; if(q[mid] &lt; a[i])l = mid; //找到小于a[i]的第一个数 else r = mid - 1; &#125; //r + 1 表示大于等于a[i]的的第一个数,并将该数替换掉 len = max(len, r + 1); q[r + 1] = a[i]; &#125; cout &lt;&lt; len &lt;&lt; endl; &#125; 二.数字和最大的递增子序列 题目描述：给定你一个数字序列，找出数字和最大的递增子序列 思路：跟前一个思路一样采用dp的思想，现在dp【i】的含义表示为序列中第i个元素结尾的数字和的最大值 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;#define maxn 100000int max(int a,int b)&#123; if(a&gt;b)return a; else return b;&#125;int a[maxn+5];int dp[maxn+5];int main()&#123; int n,Max=0; scanf(\"%d\",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;a[i]); dp[i]=a[i]; &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;i;j++)&#123; if(a[i]&gt;a[j])dp[i] = max(dp[j]+a[i], dp[i]);//dp【i】表示以第i个元素结尾的数字和的最大值 &#125; Max=max(Max,dp[i]); //记录最大的数字和 &#125; printf(\"%d\\n\",Max); return 0;&#125; 三.连续子数组最大和例题：杭电OJ 1003 问题描述：给你一个数字序列，里面有正数，也有负数，求出这个序列中连续某一段的和的最大值，并求出是从什么地方开始到什么地方结束 思路：dp的思想，dp【i】依然表示的是序列中以第i个元素结尾的连续数组的最大值，从第二项依次遍历，如果前一项&lt;0,则不加，若大于0就加上. 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#define maxn 100000int a[maxn+5];int main()&#123; int t,n,p=1; scanf(\"%d\",&amp;t); while(t--)&#123; a[0]=0; int start=1,end=0,fstart=1,fend=1,Max=-1e9; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++)scanf(\"%d\",&amp;a[i]); for(int i=1;i&lt;=n;i++)&#123; if(a[i-1]&lt;0)&#123; start=i; end=i; &#125; else &#123; a[i]+=a[i-1]; end=i; &#125; if(a[i]&gt;Max)&#123; //Max，fstart，fend分别表示和的最大值以及对应的起始位置 Max=a[i]; fstart=start; fend=end; &#125; &#125; printf(\"Case %d:\\n\",p); printf(\"%d %d %d\\n\",Max,fstart,fend); p++; if(t!=0)printf(\"\\n\"); &#125;&#125;","path":"2019/07/22/动态规划/动态规划之子序列问题/","date":"07-22","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"子序列","slug":"子序列","permalink":"http://zhumenger.top/tags/子序列/"}]},{"title":"Java基础之类的构造方法和this简介","text":"一.构造方法构造方法的本质是将类中的变量通过参数的形式进行赋值 要点： 1.通过new关键字调用 2.构造器有返回值，但是不能定义返回值，不能再构造器中使用return返回某个值 3.如果没有定义构造器，则编译器会自动顶一个无参的构造函数 4.构造器的方法名必须和类名一致 123456789101112131415161718192021222324252627282930public class Main &#123; public static void main(String[] args) &#123; Point p1 = new Point(1, 2); Point p2 = new Point(3, 4); //如果自己添加了构造器，创建对象的时候， //形式一定要和构造器的形式一样，否则会报错 //Point p3 = new Point();报错 System.out.println(p1.sum(p2)); System.out.println(p2.sum(p1)); &#125; &#125;class Point&#123; int x, y; //构造方法的名称必须和类的名称一致 //构造方法的本质是将类中的变量通过参数的形式进行赋值 public Point(int a, int b) &#123; x = a; y = b; &#125; public int sum(Point p) &#123; return p.x + p.y; &#125;&#125; 二.this简介1.this表示“创建好的对象的地址”，在构造方法中也可以使用this代表当前的对象 2.this不能用于static方法中 12345678910111213141516171819202122public class Main &#123; int a, b, c; Main(int a, int b)&#123; //this表示此类 //this.a表示此类中a这个成员变量 this.a = a; this.b = b; &#125; Main(int a, int b, int c)&#123; //调用构造器 //构造器的调用必须放在第一句 this(a, b); this.c = c; &#125; public static void main(String[] args) &#123; &#125; &#125;","path":"2019/07/20/Java/Java基础之类的构造方法和this简介/","date":"07-20","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/tags/Java/"}]},{"title":"Java基础之对象和内存分析","text":"一.Java基础之对象1.什么是对象：是某种类的声明，可以通过该对象调用与之对应的类的属性和属性值，被访问的属性属于成员变量，在类中，又在方法之外的变量 2.对象的创建 通过new运算符来创建一个类的对象，，语法为：类名 变量 = new 类名()； 123456789101112131415161718192021public class Main &#123; int a; int b; //表示一个方法 void play() &#123; System.out.println(\"~~~~~^_^~~~~~\"); &#125; //构造方法，用于创建这个类的对象。无参的构造方法可以 //由系统自动生成，方法名必须和类名一致 //这里可以不写 //Main()&#123; //&#125; public static void main(String[] args) &#123; Main d = new Main();//创建一个对象 d.play();//表示调用d对象中的play函数，输出//~~~~~^_^~~~~~ d.a = 1; d.b = 123; System.out.println(d.a);//输出1 System.out.println(d.b);//输出123 &#125;&#125; 也可以在一个类中，声明另个一个类的对象，并且可以对其进行访问 1234567891011121314public class Main &#123; Computer come = new Computer();//声明一个Computer类的对象 public static void main(String[] args) &#123; Main arr = new Main();//声明一个Main类的对象 arr.come.name = \"孙悟空\"; System.out.println(arr.come.name);//输出\"孙悟空\" &#125; &#125;//另一个类class Computer&#123; String name;&#125; 二.Java基础之内存分析栈1.方法被调用的时候，都会在栈中开辟一块内存，用来存储方法中的东西 2.对象在栈中储存的是该对象在堆中的地址，对象的值并不会直接储存在栈中，而是储存在了堆中 3.局部变量也是储存在了栈内存当中 堆1.是一个不连续的内存空间，用来储存创建好的对象 2.成员变量，即对象中的属性和属性值都是在堆中储存 方法区 用来存放程序中不变或唯一的内容，实际上也是一个特殊的堆， 1234567891011121314151617181920212223public class Main &#123; //以下变量都属于成员变量， //对象又被称为实例，实例变量即对象变量 //不创建对象，成员变量的内存空间是不存在的，只有创建了 //对象，成员变量的内存空间才会被创建 int name; int age; public static void main(String[] args) &#123; //arr表示一个引用,引用即一个变量，储存的是一个Java对象的内存地址 //Java中，不能直接操作堆内存，Java中没有指针 //Java中，只能用过\"引用\"去访问堆内存的成员变量 //读取数据: 引用.变量名 Main arr = new Main(); &#125; &#125;//成员变量没有手动赋值的话，系统赋默认值//byte、short int long:0;// float double: 0.0;// boolean:false","path":"2019/07/20/Java/Java基础之对象和内存分析/","date":"07-20","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/tags/Java/"}]},{"title":"Java基础之方法","text":"java中的方法类似于其他语言中的函数，是完成特定功能的代码片段 12345678910public class Main &#123; public static void main(String[] args) &#123; int a = 2, b = 3; int c = sum(a, b); System.out.println(c); &#125; public static int sum(int a, int b)&#123; return a +b; &#125;&#125; 方法的重载： Java语言中的方法的名称可以相同 构成重载的条件： 1.方法名相同，参数个数不同，构成重载 123456789101112131415public class Main &#123; public static void main(String[] args) &#123; int a = 2, b = 3, d = 4; int c = sum(a, b); int f = sum(a, b, d); System.out.println(c);//输出5 System.out.println(f);//输出9 &#125; public static int sum(int a, int b)&#123; return a +b; &#125; public static int sum(int a, int b, int c)&#123; return a + b + c; &#125;&#125; 2.方法名相同，参数类型不同，构成重载 12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; int a = 2, b = 3; double d = 2.0; int c = sum(a, b); double f = sum(d, b); System.out.println(c);//输出5 System.out.println(f);//5.0 &#125; public static int sum(double a, int b)&#123; return a +b; &#125; public static double sum(int a, double b)&#123; return a + b; &#125;&#125; 方法名相同，参数顺序不同，构成重载 12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; double a = 2.0; int b = 3; double c = sum(a, b); double d = sum(b, a); System.out.println(c);//5.0 System.out.println(d);//5.0 &#125; public static double sum(double a, int b)&#123; return a +b; &#125; public static double sum(int a, double b)&#123; return a + b; &#125;&#125;","path":"2019/07/19/Java/Java基础之方法/","date":"07-19","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/tags/Java/"}]},{"title":"整数划分","text":"题目描述 一个正整数n可以表示成若干个正整数之和，形如：n=n1+n2+…+nk，其中n1≥n2≥…≥nk,k≥1。 我们将这样的一种表示称为正整数n的一种划分。 现在给定一个正整数n，请你求出n共有多少种不同的划分方法。 输入格式 共一行，包含一个整数n。 输出格式 共一行，包含一个整数，表示总划分数量。 由于答案可能很大，输出结果请对109+7取模。 数据范围 1≤n≤1000 输入样例: 5 输出样例： 7 题解： 类似于完全背包问题，可以把n看成体积，有 n - 1种不能体积的物品，问将这些物品装入背包，容量恰好为n的方法有多少种 状态表示：f(i, j) 表示前 i 个物品恰好能装进容量为 j 的方法总数 如何求f(i, j)？对于每个物品我们可以选择装，也可以选择不装: 1.第 i 个物品不装进背包中，说明前i - 1个物品装进背包的容量恰好为j，所以f(i, j) = f(i - 1, j) 1.第 i 个物品装进背包中，将第 i 个物品装进背包后，背包容量恰好为 j ，则状态转移方程为： *f(i, j) = f(i, j - i) * 所以总的状态转移方程为：f(i, j) = f(i - 1, j ) + f(i, j - 1) 代码如下： 123456789101112131415#include&lt;iostream&gt;using namespace std;const int N = 1010, mod = 1e9 + 7;int f[N];int main()&#123; int n; cin &gt;&gt; n; f[0] = 1; for(int i = 1; i &lt;= n; i++) // 枚举物品 for(int j = i; j &lt;= n; j++)//从小到大枚举体积 f[j] = (f[j] + f[j - i]) % mod; cout &lt;&lt; f[n] &lt;&lt; endl; return 0;&#125;","path":"2019/07/19/动态规划/整数划分/","date":"07-19","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"计数DP","slug":"计数DP","permalink":"http://zhumenger.top/tags/计数DP/"}]},{"title":"石子合并","text":"题目描述 设有N堆石子排成一排，其编号为1，2，3，…，N。 每堆石子有一定的质量，可以用一个整数来描述，现在要将这N堆石子合并成为一堆。 每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。 例如有4堆石子分别为 1 3 5 2， 我们可以先合并1、2堆，代价为4，得到4 5 2， 又合并 1，2堆，代价为9，得到9 2 ，再合并得到11，总代价为4+9+11=24； 如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11=22。 问题是：找出一种合理的方法，使总的代价最小，输出最小代价。 输入格式 第一行一个数N表示石子的堆数N。 第二行N个数，表示每堆石子的质量(均不超过1000)。 输出格式 输出一个整数，表示最小代价。 数据范围 1≤N≤300 输入样例： 4 1 3 5 2 输出样例： 22 题解： 区间DP问题，用动态规划来做： 状态表示：f(i, j) 表示将第 i 堆石子到第 j 堆石子合并成一堆石子的代价的最小值 如何求f(i, j)呢？ 1.假设k为 i ~ j 堆石子的一个分界线，从 i 堆到 k 堆的最小代价已经求出，从 k + 1 堆到 j 堆的最小代价也已经求出，我们要求 i 堆到 j 堆的最小代价，只需要将左右俩堆的最小代价加起来，再加上这次合并的代价，就可以得到我们的f(i, j)了。 2.这次的合并代价为 i ~ j 堆所有石子的重量之和，我们可以用前缀和的方法来得到任意区间的总和 3.状态转移方程为：f(i, j) = min(f(i, j), f(i, k) + f(k + 1, j) + s[j] - s[i - 1]) 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;const int N = 310;int f[N][N], a[N], s[N];int main()&#123; int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= n; i++) s[i] = a[i] + s[i - 1]; for(int i = 2; i &lt;= n; i++)&#123;//枚举长度 for(int j = 1; j + i - 1 &lt;= n; j++)&#123;//枚举这个长度下的起点和终点 int l = j, r = j + i - 1; f[l][r] = 1e9; for(int k = l; k &lt; r; k++)//枚举分界线 f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]); &#125; &#125; cout &lt;&lt; f[1][n] &lt;&lt;endl; return 0;&#125;","path":"2019/07/19/动态规划/石子合并/","date":"07-19","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"区间DP","slug":"区间DP","permalink":"http://zhumenger.top/tags/区间DP/"}]},{"title":"最短编辑距离","text":"题目描述 给定两个字符串A和B，现在要将A经过若干操作变为B，可进行的操作有： 删除–将字符串A中的某个字符删除。 插入–在字符串A的某个位置插入某个字符。 替换–将字符串A中的某个字符替换为另一个字符。 现在请你求出，将A变为B至少需要进行多少次操作。 输入格式 第一行包含整数n，表示字符串A的长度。 第二行包含一个长度为n的字符串A。 第三行包含整数m，表示字符串B的长度。 第四行包含一个长度为m的字符串B。 字符串中均只包含小写字母。 输出格式 输出一个整数，表示最少操作次数。 数据范围 1≤n,m≤1000 输入样例： 10AGTCTGACGC11AGTAAGTAGGC 输出样例： 4 题解： 将一个字符串通过删除、插入、替换变为另一个字符串的最短距离,可以用动态规划来做，用f(i, j)来表示长度为i的字符串变为长度为j的字符串最小的操作次数，那么如何来求f(i, j)呢？对每个字符我们有3种操作: 1.删除：假设删除a[i]后，a[1 ~ i] 与 b[1 ~ j] 匹配，那么说明a[1 ~ i - 1]已经与b[1 ~ j]相等了，那么多出来的a[i]直接删掉即可，状态转移方程为：f(i, j) = f(i - 1, j) + 1 2.插入： 假设插入一个a[i],使a[i] == b[j]后，a[1 ~ i] 与 b[1 ~ j] 匹配,那么说明a[1 ~ i]已经与b[i ~ j - 1]相等了，要使a[1 ~ i]与b[i ~ j]相等,只需再a[1 ~ i]的后面添加一个b[j]即可 状态转移方程为：f(i, j) = f(i, j - 1) + 1 3.替换：假设将a[i]替换成b[j],使得a[1 ~ i] 与 b[1 ~ j] 匹配,那么说明a[1 ~ i - 1]已经与b[i ~ j - 1]相等了，要使a[1 ~ i]与b[i ~ j]相等,只需将a[i]替换为b[j]即可。 如果a[i] = b[j]，则无需替换，状态转移方程为：f(i, j) = f(i - 1, j - 1) 如果a[i] != b[j]，则需要替换，状态转移方程为：f(i, j) = f(i - 1, j - 1) + 1 所以我们得出来总的状态转移方程式为就是上述方程式的最小值 代码如下： 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;const int N = 1010;char s1[N], s2[N];int f[N][N];int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; s1 + 1; cin &gt;&gt; m &gt;&gt; s2 + 1; for(int i = 0; i &lt;= n; i++) //a[i ~ i]变为0，只能删除， 操作数为i f[i][0] = i; for(int i = 0; i &lt;= m; i++)//a[0]变为b[1 ~ i]，只能添加，操作数为i f[0][i] = i; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; //f[i - 1][j] + 1 表示进行删除操作 //f[i][j - 1] + 1 表示进行添加操作 f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1); //下面的表示进行替换操作 if(s1[i] == s2[j])f[i][j] = min(f[i][j], f[i - 1][j - 1]); else f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1); &#125; &#125; cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;&#125;","path":"2019/07/19/动态规划/最短编辑距离/","date":"07-19","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"}]},{"title":"Java基础之运算符","text":"1.二元运算符整数运算 1.如果俩个操作数有一个为long，则结果为long 2.如果没有long时，结果为int，即使操作符全为float或byte，也必须用int类型的变量来保存 浮点运算 3.如果俩个操作符中有一个为double，则结果为double 4.只有当俩个操作符全为float时，结果才为float 取模运算 余数的符号与左边操作符相同，如 7%3 = 1， -7 % 3 = -1， 7 % -3 = 1； 2.自增与自减12345678910public class Main &#123; public static void main(String[] args) &#123; int a = 3; int b = a++;//先赋值在运算,b为3,a为4 int c = ++a;//先运算再赋值,a = 5, c = 5 b = a--;//先赋值在运算,b为5,a为4 b = --a;//先赋值在运算,a = 3,b = 3 System.out.println(); &#125;&#125; 3.字符串运算符1.string型与int型相加,先将int类型转化为字符串类型，在进行拼接 2.运算顺序从左到右，俩个整形相加还是整形，直到与字符串相加才变成字符串类型 12345678910public class Main &#123; public static void main(String[] args) &#123; String a = \"3\"; int b = 4; int c = 5; System.out.println(a + b);//输出34 System.out.println(a + b + c);//345 System.out.println(b + c + a);//93 &#125;&#125; 4.强制类型转换语法：type var = (type)value 12345678910public class Main &#123; public static void main(String[] args) &#123; double x = 3.14; int a = (int)x; char a = 'a'; int d = c + 1; System.out.println(a);//输出3 Syetem.out.println((char)d);//输出'b' &#125;&#125;","path":"2019/07/18/Java/Java基础之运算符/","date":"07-18","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/tags/Java/"}]},{"title":"Java基础之基本类型","text":"1.常量定义：指固定的值，不能随意改变，如：1， 2， “hello world”等 在java语言中，利用final关键字来定义一个常量，常量一旦被初始化后便不能再更改其值 声明格式: 1final type varname = value; 例： 123456public class Main&#123; public static void main(String[] args)&#123; final double PI = 3.14; System.out.println(PI); &#125;&#125; 2.基本数据类型数值型： byte(1个字节)、short(2个字节)、int(4个字节)、long(8个字节)、float(4个字节)、double(8个字节) 字符型： char(2个字节) 布尔型： boolean(1个字节) 整形的4种表示方式 1.十进制：如，99 2.八进制：以0开头 如：015 3.十六进制：以0x 或0X开头，如： 0xab 0x15 4.二进制： 以0b 或 0B开头 如：0b011010 1234567891011public class Main&#123; public static void main(String[] args)&#123; byte a = 5;//a的范围不能超过一个字节，否则会报错 int b = 015//8进制 int c = 0x15//16进制 int d = 0b1001//2进制 long e = 12345; long f = 10000000L;(后面+L表示这是一个long类型的变量) System.out.println(PI); &#125;&#125; 浮点型 1.表示形式 十进制数形式：3.14、0.1 科学计数法表示：3e5 表示300000.0 300000e-5 表示3.0 float类型数值有一个后缀 F 或 f ,没有后缀F/f的浮点数默认为double类型，也可以在数值后面添加D/d来声明它是一个double类型 浮点型的值不精确： 1234567public class Main&#123; public static void main(String[] args)&#123; float a = 0.1f; double b = 1.0 / 10; System.out.println(a == b);//false &#125;&#125; 字符型字符型占2个字节，用单引号’ ‘ 来表示一个字符，用双引号” “ 来表示一个字符串，Java采用的是Unicode编码，可以处理各种语言的文字 12345678910public class Main&#123; public static void main(String[] args)&#123; char str1 = '1'; char str2 = 'a'; char str3 = '哈'; //也可以用转义字符\\u + 4位16进制的数拉表示一个字符 char a = '\\u0061';// 表示'a' System.out.println(a == b);//false &#125;&#125; boolean类型有俩个常量：true和false","path":"2019/07/18/Java/Java基础之基本类型/","date":"07-18","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/tags/Java/"}]},{"title":"Java基础之-注释、标识符、变量","text":"一.注释单行注释： //内容…. 多行注释： /* 内容…*/ 文档注释： /** 内容 */ 1234567891011121314151617/** * 这里是文档注释 * @author Administrator * */public class Main &#123; //这里是单行注释 public static void main(String[] args) &#123; // TODO Auto-generated method stub System.out.println(\"安装eclipse完成!\"); &#125; /* * 这 * 里 * 是 * 多行注释 */&#125; 二.标识符1.命名规则: 标识符必须以字母、下划线、或者$开头，不能以数字开头 标识符其他部分可以是字母、下划线、$ 和数字的任意组合 Java标识符区分大小写 标识符不可以是Java的关键字 标识符的第一个单词的字母要小写，从第二个单词开始，首字母大写，我们称之为“驼峰原则”如get， getMin Java语言采用的不是ASCII字符集，而是Unicode国际编码，所以字符串中的内容可以是中文 三.变量当你把一个值赋值给一个名字时，它会储存在内存中，把这块内存称为变量, 本质上就是一个可以操作的储存空间 声明变量： 1234double a; //8个字节long b; //8个字节int c; //4个字节int a, b, c;//一行中声明对个变量 局部变量 在代码块内部定义的变量，生命周期从声明位置开始，带方法或代码块执行完毕为止 12345public class Main &#123; public void text&#123; int j = i + 5; &#125;&#125; 成员变量方法外部、类的内部定义的变量, 书与对象，生命周期伴随对象始终，如果不自动初始化，它会自动初始化为默认值(整型为0，浮点型为0.0) 静态变量 使用static定义，从属于类，生命周期始终伴随类，类在，该变量就在","path":"2019/07/17/Java/Java基础之-注释、标识符、变量/","date":"07-17","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/tags/Java/"}]},{"title":"Java基础之-程序详细解析","text":"1.Java区分大小写，大小写拼写错误，程序无法运行 2.关键词class是类的意思。Java所有的代码都要写在类中 3.一个源文件中只能声明一个public的类，其他类的个数不限 4.编写类的时候有俩种方式： (A). public class定义类 ： 1.如果一个类声明的时候使用了public class进行了声明，则类名称必须与文件名称完全一致。 2.被public修饰的类可以被其他包访问 (B). class定义类 1.如果一个类声明的时候使用了class进行了声明，则作为启动类的名称可以与文件名称不一致，但是执行的时候肯定执行的是生成后的名称。 2.没有public修饰的类，该类就拥有了包访问权限，即该类只可以用于该包之中。该类不能被其他包访问 5.Java中每个语句以分号结束 6.main方法是java应用程序的入口方法，它有固定的书写格式：public static void main(String[] args) 1234567891011121314151617//public 表示公开的， 表示其他的类都可以访问这个方法//class表示定义一个类//Main 表示一个类名//下面一句表示定义了一个公开的类，起名为Main,必须和文件名一致public class Main&#123; /* public表示公开的 static表示静态的 void表示空 main是Java程序进入的方法 String[] args： String 类型的数组，名为args，这个名字是可以变化的，但是一般使用args。 */ //下面一句表示定义了 public static void main(String[] args)&#123; System.out.println(\"安装eclipse完成!\"); &#125;&#125;","path":"2019/07/17/Java/Java基础之-程序详细解析/","date":"07-17","excerpt":"","tags":[{"name":"Java","slug":"Java","permalink":"http://zhumenger.top/tags/Java/"}]},{"title":"素数","text":"一.试除法判定质数即暴力枚举它之前的数，如果能整除，说明该数不是素数 1234567891011121314151617181920212223//时间复杂度O(sqrt(n))#include&lt;iostream&gt;using namespace std;int n;bool prime(int n)&#123; if(n &lt; 2)return false; for(int i = 2; i &lt; n / i; i++)//i * i 有溢出风险，所以要把i除过去 if(n % i == 0) return false; return true;&#125;int main()&#123; long long int a; cin &gt;&gt; n; while(n--)&#123; cin &gt;&gt; a; if(prime(a))cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; return 0;&#125; 二.分解质因数 给定n个正整数ai，将每个数分解质因数，并按照质因数从小到大的顺序输出每个质因数的底数和指数。 输入格式 第一行包含整数n。 接下来n行，每行包含一个正整数ai。 输出格式 对于每个正整数ai,按照从小到大的顺序输出其分解质因数后，每个质因数的底数和指数，每个底数和指数占一行。 每个正整数的质因数全部输出完毕后，输出一个空行。 数据范围 1≤n≤1001≤ai≤2∗109 输入样例： 2 68 输出样例： 2 13 1 2 3 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;typedef long long ll;void divide(ll n)&#123; for(ll i = 2; i &lt;= n / i; i++)&#123; //枚举到sqrt(n)，时间复杂度最大为O(sqrt(n)) if(n % i== 0)&#123; int ans = 0; while(n % i == 0)&#123; n /=i; ans++; &#125; printf(\"%d %d\\n\", i, ans); &#125; &#125; if(n &gt; 1)printf(\"%d %d\\n\", n, 1);//大于sqrt(n)的质因子&#125;int main()&#123; int n; ll x; cin &gt;&gt; n; while(n--)&#123; scanf(\"%lld\", &amp;x); divide(x); printf(\"\\n\"); &#125; return 0;&#125; 三.筛质数题目描述 给定一个正整数n，请你求出1~n中质数的个数。 输入格式 共一行，包含整数n。 输出格式 共一行，包含一个整数，表示1~n中质数的个数。 数据范围 1≤n≤106 输入样例： 8 输出样例： 4 埃氏筛法原理 素数的定义：素数就是除了1和本身之外没有其他的约数，所以有约数的都不是素数。 埃氏筛法的思想就是：先去掉2的倍数，再去掉3的倍数，再去掉4的倍数，……依此类推，直到最大数小于最后一个标出的素数的平方，那么剩下的序列中所有的数都是素数。 时间复杂度：O(nloglogn)代码如下： 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;#define maxn 10000000#define INF 0x3f3f3f3fusing namespace std;bool a[maxn+5];int main()&#123; int n,m; scanf(\"%d%d\",&amp;n,&amp;m); memset(a,true,sizeof(a)); for(int i=2;i&lt;=n;i++)&#123; if(a[i])&#123; for(int j=2;i*j&lt;=n;j++) a[i*j]=false; &#125; &#125; a[1]=false; int t; while(m--) &#123; scanf(\"%d\",&amp;t); if(a[t])printf(\"Yes\\n\"); else printf(\"No\\n\"); &#125; return 0;&#125; 欧拉筛法 在埃式筛法中，存在有些数存在重复筛的情况，如：385这个数，385= 5 * 7* 11，会被5的倍数时标记一次，7的倍数时标记一次，11的倍数时标记一次，造成效率达不到最优。而线性筛法基于改进这个不足的基础上，在线性时间内，也就是O(n)，用筛选的方法把素数找出来。 核心原理：对于每个合数，都只由它最小的质因子筛掉。 比如：（假定：ans[]数组中存放着已经确定的素数）合数 i = p（最小素因子）* a; 若 i%ans[j] ==0; 则 i * ans[j+1] = p * a * ans[j+1] 可以被后面的 a * ans[j+1] 再乘以素数 p 筛选出来，(显而p&lt;ans[j+1]） 所以i%ans[j] == 0 时要停止。 代码如下： 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define maxn 10000000#define INF 0x3f3f3f3fusing namespace std;bool a[maxn+5];int b[maxn+5];//存储质数int main()&#123; int n,m; scanf(\"%d%d\",&amp;n,&amp;m); memset(a,true,sizeof(a)); a[1]=false; int k=1; for(int i=2;i&lt;=n;i++)&#123; if(a[i]) //如果i为质数 b[k++]=i;//存上 for(int j=1;j&lt;=k&amp;&amp;i*b[j]&lt;=n;j++)&#123; a[i*b[j]]=false; if(i%b[j]==0)break; &#125; &#125; int t; while(m--)&#123; scanf(\"%d\",&amp;t); if(a[t])printf(\"Yes\\n\"); else printf(\"No\\n\"); &#125; return 0;&#125;","path":"2019/07/17/数论/素数/","date":"07-17","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"素数","slug":"素数","permalink":"http://zhumenger.top/tags/素数/"}]},{"title":"雪花雪花雪花","text":"雪花雪花雪花 有N片雪花，每片雪花由六个角组成，每个角都有长度。 第i片雪花六个角的长度从某个角开始顺时针依次记为ai1,ai2,…,ai6。 因为雪花的形状是封闭的环形，所以从任何一个角开始顺时针或逆时针往后记录长度，得到的六元组都代表形状相同的雪花。 例如ai1,ai2,…,ai6和ai2,ai3,…,ai6，ai1就是形状相同的雪花。 ai1,ai2,…,ai6和ai6,ai5,…,ai1也是形状相同的雪花。 我们称两片雪花形状相同，当且仅当它们各自从某一角开始顺时针或逆时针记录长度，能得到两个相同的六元组。 求这N片雪花中是否存在两片形状相同的雪花。 输入格式 第一行输入一个整数N，代表雪花的数量。 接下来N行，每行描述一片雪花. 每行包含6个整数，分别代表雪花的六个角的长度（这六个数即为从雪花的随机一个角顺时针或逆时针记录长度得到）。 同行数值之间，用空格隔开。 输出格式 如果不存在两片形状相同的雪花，则输出： No two snowflakes are alike. 如果存在两片形状相同的雪花，则输出： Twin snowflakes found. 数据范围 1≤n≤1000000≤ai,j&lt;10000000 输入样例： 2 1 2 3 4 5 64 3 2 1 6 5 输出样例： Twin snowflakes found. 题解： 字符串的最小表示法：每一个字符串都有一个字典序最小的表示，比较这俩个字符串的最小表示是否相等即可 1.用俩个数组分别存取该字符串的正序和逆序表示 2.用最小表示法获得俩种表示方法中字典序最小的那个，并将该结果用数组储存起来 3.我们需要对储存的结果进行排序，这样只需要比较相邻的俩个数是否相等即可，但并不能直接对二维数组进行排序，这里我们需要一个一维数组，来储存每个字符串的下标，该数组通过二维数组字符串的关系对下标进行排序,通过遍历该下标访问二维数组即可 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e5 + 10;int n;int snows[N][6], idx[N];void get_min(int a[])//获得字符串的最小表示法&#123; int b[12]; for(int i = 0; i &lt; 12; i++)b[i] = a[i % 6]; int i = 0, j = 1, k; while(i &lt;= 6 &amp;&amp; j &lt;= 6)&#123; k = 0; while(k &lt; 6 &amp;&amp; b[i + k] == b[j + k])k++; if(k == 6)break; if(b[i + k] &lt; b[j + k])&#123; j += k + 1; if(j == i)j++; &#125; else&#123; i += k + 1; if(i == j)i++; &#125; &#125; k = min(i, j); for(int i = 0; i &lt; 6; i++)&#123; a[i] = b[i + k]; &#125;&#125;bool cmp_array(int a[], int b[])//比较a是否小于b&#123; for(int i = 0; i &lt; 6; i++)&#123; if(a[i] &gt; b[i]) return false; else if(a[i] &lt; b[i]) return true; &#125; return false;&#125;bool cmp(int a, int b)//对二维数组排序&#123; return cmp_array(snows[a], snows[b]);//返回俩个字符串的关系&#125;int main()&#123; cin &gt;&gt; n; int snow[6], isnow[6]; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; 6; j++)&#123; cin &gt;&gt;snow[j]; isnow[5 - j] = snow[j]; &#125; get_min(snow);//获得最小表示 get_min(isnow); if(cmp_array(snow, isnow))memcpy(snows[i], snow, sizeof snow); else memcpy(snows[i], isnow, sizeof isnow); idx[i] = i; &#125; sort(idx, idx + n, cmp);//对下标进行排序 bool flag = false; for(int i = 1; i &lt; n; i++)&#123;//比较相邻的俩个数是否相同 if(!cmp(idx[i - 1], idx[i]) &amp;&amp; !cmp(idx[i], idx[i - 1]))&#123; flag = true; break; &#125; &#125; if(flag)puts(\"Twin snowflakes found.\"); else puts(\"No two snowflakes are alike.\"); return 0;&#125;","path":"2019/07/16/数据结构基础/雪花雪花雪花(最小表示法)/","date":"07-16","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"字符串","slug":"字符串","permalink":"http://zhumenger.top/tags/字符串/"}]},{"title":"邻值查找","text":"题目描述 给定一个长度为 n 的序列 A，A 中的数各不相同。对于 A 中的每一个数 Ai，求： min1≤j&lt;i|Ai−Aj| 以及令上式取到最小值的 j（记为 Pi）。若最小值点不唯一，则选择使 Aj 较小的那个。 输入格式 第一行输入整数n，代表序列长度。 第二行输入n个整数A1…An,代表序列的具体数值，数值之间用空格隔开。 输出格式 输出共n-1行，每行输出两个整数，数值之间用空格隔开。 分别表示当i取2~n时，对应的min1≤j&lt;i|Ai−Aj|和Pi的值。 数据范围 0&lt;n≤10^5,|Ai|≤10^9 输入样例： 3 1 5 3 输出样例： 4 12 1 题解： 1.由题意可知，这道题让我们求的是a[i]之前与a[i]最接近的数,如果我们进行排序，拍完序后与a[i]相邻的俩个肯定有一个是与a[i]最接近的, 2.首先用结构体将a[i]及其对应的下标存起来，从小到大排序 3.将排完序之后的结果用链表存起来,存起来后，我们从a[n]开始倒着遍历查找答案，在链表中它的前驱和后继的下标一定都是小于n的，取俩者与a[n]最接近的数，便是我们的答案 4.找到i的答案后，去掉该节点即可，保证从后往前遍历的时候，与a(i - 1)相邻的节点的下标都是小于i - 1的 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e5 + 10;int e[N], l[N], r[N];typedef pair&lt;int, int&gt; p;p a[N], ans[N];int main()&#123; int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i].first, a[i].second = i; sort(a + 1, a + 1 + n); a[0].first = 1e9, a[n + 1].first = -1e9; for(int i = 1; i &lt;= n; i++)&#123; l[i] = i - 1, r[i] = i + 1; e[a[i].second] = i; &#125; for(int i = n; i &gt; 1; i--)&#123;//从后往前遍历，则a[i]排完序后的前驱和后继的下标都是小于i的, int j = e[i], left = l[j], right = r[j]; int lv = abs(a[j].first - a[left].first); int rv = abs(a[j].first - a[right].first); if(lv &lt;= rv) ans[i] = &#123;lv, a[left].second&#125;; else if(lv &gt; rv) ans[i] = &#123;rv, a[right].second&#125;; r[left] = right, l[right] = left; //找到i的答案后，去掉该节点即可，这样从后往前遍历的 //时，保证了与a(i - 1)相邻的节点的下标都是小于i - 1的 &#125; for(int i = 2; i &lt;= n; i++) cout &lt;&lt; ans[i].first &lt;&lt; ' ' &lt;&lt; ans[i].second &lt;&lt; endl; return 0;&#125;","path":"2019/07/16/数据结构基础/邻值查找/","date":"07-16","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://zhumenger.top/tags/数据结构/"},{"name":"链表","slug":"链表","permalink":"http://zhumenger.top/tags/链表/"}]},{"title":"背包九讲","text":"Acwing背包题库一.01背包问题问题描述 有 N 件物品和一个容量是 VV 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。 输入格式 第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。 接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。 输出格式 输出一个整数，表示最大价值。 数据范围 0&lt;N,V≤10000&lt;vi,wi≤1000 输入样例 4 51 22 43 44 5 输出样例： 8 题解： 首先DP问题分为俩个步骤： 1.状态表示：首先考虑用几维的状态表示，然后考虑集合的含义，以及其属性(求Max, Min,数量等) 2.状态计算：DP问题一般都可以将大问题划分为小问题，从小问题下手，从而得到一般的状态转移方程 对于这道题，我们考虑： 1.首先声明一个数组F(i, j)表示选前 i 件物品，且背包容量为 j 时所能获得的最大价值 。 2.对于每个物品我们有拿或者不拿俩种选择： (1).j &lt; w[i] 的情况，这时候背包容量不足以放下第 i 件物品，只能选择不拿 (2).j &gt;= w[i] 的情况，这时背包容量可以放下第 i 件物品，我们就要考虑拿这件物品是否能获取更大的价值。 如果拿取，则F(i, j) = f(i - 1, j - v[i]) + w[i],即 F(i, j) 表示在上一状态中选了第i件物品， 如果不拿，则F(i, j) = f(i - 1, j) 拿或者不拿，就要看哪种方法得到的价值最大，即 F(i, j) = max(f(i - 1, j), f(i - 1, j - v[i]) + w[i]) 如下图所示： 代码如下： 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;#define maxn 1000using namespace std;int v[maxn + 5], w[maxn + 5];int dp[maxn + 5][maxn + 5];int main()&#123; int n,W; scanf(\"%d%d\",&amp;n,&amp;W); for(int i = 0; i &lt; n; i++) scanf(\"%d%d\",&amp;v[i],&amp;w[i]); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt;= W; j++)&#123; if(v[i] &gt; j)dp[i + 1][j] = dp[i][j]; else dp[i + 1][j] = max(dp[i][j], dp[i][j - v[i]] +w[i]); &#125; &#125; printf(\"%d\\n\",dp[n][W]); return 0;&#125; 01背包问题一维数组实现状态转移方程如果是由上一层的状态得来的话，枚举体积的时候从大到小枚举，这样我们计算体积的时候，可以保证本层所用到的体积还没有被计算过 如果用的是本层的状态，枚举体积的时候就要从小到大枚举，这样我们计算体积的时候，可以保证所用到的体积是本层之前计算好的体积 1234567891011121314151617#include&lt;iostream&gt;using namespace std;const int N = 1010;int d[N];int main()&#123; int n, V; cin &gt;&gt; n &gt;&gt; V; for(int i = 0; i &lt; n; i++)&#123; int v, w; cin &gt;&gt; v &gt;&gt; w; for(int j = V; j &gt;= v; j--) d[j] = max(d[j], d[j - v] + w); &#125; cout &lt;&lt; d[V] &lt;&lt; endl; return 0;&#125; 二.01背包问题2问题描述 有n个重量和价值分别为wi，vi的物品。从这些物品中挑选总重量不超过W的物品，求所有挑选方案中价值总和最大的方案 输入样例 4 52 1 3 23 2 4 2 输出样例 7 取值范围 1&lt;=n&lt;=1001&lt;=wi&lt;=10^71&lt;=vi&lt;=1001&lt;=W&lt;=10 ^9 分析： 这里与背包问题1不同的地方是修改了限制的条件，求解这一问题的复杂度是O（NW），对于这一问题的规模来讲就不够用了，相比较重量来说，价值的范围较小一些，所以可以改变DP的对象，背包问题1用DP来表示不同体积下的最大价值，这次我们不妨用DP来表示不同价值下的最小体积。定义：F(i, j)表示前i个物品挑选出价值总和为j时的最小重量,(不存在是就是一个充分大的数INF)由于前0个物品都挑选不了 所以F(0, 0)=0, F(0, j)=INF 状态转移式为：F(i, j) = min(f(i - 1, j), F(i - 1,j - w[i]) + v[i]) 代码如下： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#define INF 1000000000#define max_n 100#define max_v 100using namespace std;int n,W;int dp[max_n+5][max_n*max_v+5];int w[max_n+5],v[max_n+5];void solve()&#123; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;=max_n*max_v+5;j++)&#123; if(j&lt;v[i])dp[i+1][j]=dp[i][j]; else dp[i+1][j]=min(dp[i][j],dp[i][j-v[i]]+w[i]); &#125; &#125;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;W); for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;w[i]); for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;v[i]); fill(dp[0],dp[0]+max_n*max_v+5,INF); //初始化 dp[0][0]=0; solve(); int res=0; for(int i=0;i&lt;=max_n*max_v;i++)&#123; if(dp[n][i]&lt;=W)res=i; &#125; printf(\"%d\\n\",res); return 0;&#125; 三.完全背包问题 有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。 第 i 种物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。 输入格式 第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。 接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 种物品的体积和价值。 输出格式 输出一个整数，表示最大价值。 数据范围 0&lt;N,V≤10000&lt;vi,wi≤1000 输入样例 4 51 22 43 44 5 输出样例： 10 题解： 完全背包问题，物品有无限个，这里我们来考虑第i个物品选多少个 1.对于每种物品，我们有选和不选俩种选择， 如果不选，F(i + 1 ,j) = F(i , j) 如果选了，我们还要考虑选多少个，即F(i + 1, j) = max(F(i + 1, j - v[i]) + w[i], F(i + 1, j)) 取俩种情况的最大值，变得到了状态转移方程： F(i + 1, j) = max(F(i , j), F(i + 1, j - v[i]) + w[i]) 代码如下： 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;#define maxn 1000using namespace std;int v[maxn + 5], w[maxn + 5];int dp[maxn + 5][maxn + 5];int main()&#123; int n,V; scanf(\"%d%d\",&amp;n,&amp;V); for(int i = 0; i &lt; n; i++) scanf(\"%d%d\",&amp;v[i],&amp;w[i]); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt;= V; j++)&#123; if(v[i] &gt; j)dp[i + 1][j] = dp[i][j]; else dp[i + 1][j] = max(dp[i][j], dp[i + 1][j - v[i]] + w[i]); &#125; &#125; printf(\"%d\\n\",dp[n][V]); return 0;&#125; 一维数组实现 上面我们说到：如果用的是本层的状态，枚举体积的时候就要从小到大枚举即可，这样我们计算体积的时候，可以保证所用到的体积是本层之前计算好的体积 代码如下： 1234567891011121314151617#include&lt;iostream&gt;using namespace std;const int N = 1010;int d[N];int main()&#123; int n,V; cin &gt;&gt; n &gt;&gt; V; for(int i = 0; i &lt; n; i++)&#123; int v, w; cin &gt;&gt; v &gt;&gt; w; for(int j = v; j &lt;= V; j++) d[j] = max(d[j], d[j - v] + w); &#125; cout &lt;&lt; d[V] &lt;&lt; endl; return 0;&#125; 四.多重背包问题 I题目描述 有 N 种物品和一个容量是 V 的背包。 第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。 输入格式 第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。 接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。 输出格式 输出一个整数，表示最大价值。 数据范围 0&lt;N,V≤1000&lt;vi,wi,si≤100 输入样例 4 51 2 32 4 13 4 34 5 2 输出样例： 10 题解： 当成01背包问题来做即可，在枚举体积的时候在枚举一下该物品个数 状态转移方程：F(i, j) = max(F(i - 1, j), F(i - 1, j - k * v[i]) + k * w[i]) 一维数组实现，由于该状态转移用的是上一层的状态，所以枚举体积的时候，我们从大到小枚举，代码如下： 123456789101112131415161718#include&lt;iostream&gt;using namespace std;const int N = 110;int d[N];int main()&#123; int n, V; cin &gt;&gt; n &gt;&gt; V; for(int i = 0; i &lt; n; i++)&#123; int v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; for(int j = V; j &gt;= v; j--) for(int k = 1; k &lt;= s &amp;&amp; k * v &lt;= j; k++) d[j] = max(d[j], d[j - k * v] + k * w); &#125; cout &lt;&lt; d[V] &lt;&lt; endl; return 0;&#125; 五.多重背包问题II题目描述 有 N 种物品和一个容量是 V 的背包 第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。 输入格式 第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。 接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。 输出格式 输出一个整数，表示最大价值。 数据范围 0&lt;N≤10000&lt;V≤20000&lt;vi,wi,si≤2000 提示：本题考查多重背包的二进制优化方法。 输入样例 4 51 2 32 4 13 4 34 5 2 输出样例： 10 题解： 由于这题的数据范围有点大，直接暴力枚举会超时，那么我们就要想一个可以优化的方法，这里主要是对物品的个数进行拆分，将其变为01背包问题 二进制拆分法： 我们知道，从2^0, 2^1, 2^2…2^(k - 1)这k个数中选出任意个相加可以表示出0~2^k之间任何整数，所以我们可以对每一种物品就行二进制拆分，将其转化为01背包问题 代码如下： 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 9;int a[N], b[N], d[N];int main()&#123; int k = 0; int n, V; cin &gt;&gt; n &gt;&gt; V; for(int i = 0; i &lt; n; i++)&#123; int v, w, s; scanf(\"%d%d%d\", &amp;v, &amp;w, &amp;s); for(int j = 1; j &lt;= s; j &lt;&lt;= 1)&#123;//二进制拆分 a[k] = j * v; //用a数组来存体积 b[k++] = j * w; //b数组来存价值 s -= j; &#125; if(s &gt; 0)&#123; a[k] = s * v; b[k++] = s * w; &#125; &#125; for(int i = 0; i &lt; k; i++)//01背包 for(int j = V; j &gt;= a[i]; j--) d[j] = max(d[j], d[j - a[i]] + b[i]); cout &lt;&lt; d[V] &lt;&lt; endl; return 0;&#125; 六.分组背包问题题目描述 有 N 组物品和一个容量是 V 的背包。 每组物品有若干个，同一组内的物品最多只能选一个。每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。 求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。 输出最大价值。 输入格式 第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。 接下来有 N 组数据： 每组数据第一行有一个整数 Si，表示第 i 个物品组的物品数量； 每组数据接下来有 Si 行，每行有两个整数 vij,wij，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值； 输出格式 输出一个整数，表示最大价值。 数据范围 0&lt;N,V≤1000&lt;Si≤1000&lt;vij,wij≤100 输入样例 3 52 1 22 41 3 41 4 5 输出样例 8 题解： 跟完全背包问题类似 用F(i, j)来表示选前i组物品且体积为j时的价值最大值，我们先枚举每一组，由于F(i, j)的状态用的是上一层的状态，所以我们枚举体积的时候从大到小来枚举，再依次枚举每一组里的物品，找到体积为j时，选取i组中哪个物品的价值最大 代码如下： 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;const int N = 110;int v[N][N], w[N][N];int d[N], s[N];int main()&#123; int n, V; cin &gt;&gt; n &gt;&gt; V; for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; s[i]; for(int j = 0; j &lt; s[i]; j++)&#123; cin &gt;&gt; v[i][j] &gt;&gt; w[i][j]; &#125; &#125; for(int i = 0; i &lt; n; i++) //枚举每一组 for(int j = V; j &gt;= 0; j--) //枚举体积 for(int k = 0; k &lt; s[i]; k++)//枚举第i组体积为j时，选取哪个物品价值最大 if(v[i][k] &lt;= j) d[j] = max(d[j], d[j - v[i][k]] + w[i][k]); cout &lt;&lt; d[V] &lt;&lt; endl; return 0;&#125; 七.背包问题求方案数有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出 最优选法的方案数。注意答案可能很大，请输出答案模 109+7 的结果。 输入格式第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。 接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。 输出格式输出一个整数，表示 方案数 模 109+7 的结果。 数据范围0&lt;N,V≤10000&lt;vi,wi≤1000 输入样例 4 51 22 43 44 6 输出样例： 2 题解：在01背包问题的基础上，添加一个num数组用来记录方案数即可 代码如下： 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3 + 10, mod = 1000000007;int w[N], v[N], dp[N], num[N];int main()&#123; int n, V; scanf(\"%d%d\", &amp;n, &amp;V); for(int i = 0; i &lt; n; i++)&#123; scanf(\"%d%d\", &amp;v[i], &amp;w[i]); num[i] = 1; &#125; for(int i = 0; i &lt; n; i++)&#123; for(int j = V; j &gt;= v[i]; j--)&#123; if(dp[j] &lt; dp[j - v[i]] + w[i])&#123;//更新最大价值 dp[j] = dp[j - v[i]] + w[i]; num[j] = num[j - v[i]] % mod;//num数组记录更新方案数 &#125; else if(dp[j] == dp[j - v[i]] + w[i])&#123;//如果相等 num[j] = (num[j] + num[j - v[i]]) % mod;//方案数相加 &#125; &#125; &#125; cout &lt;&lt; num[V] &lt;&lt; endl; return 0;&#125;","path":"2019/07/15/动态规划/背包九讲/","date":"07-15","excerpt":"","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://zhumenger.top/tags/动态规划/"},{"name":"背包问题","slug":"背包问题","permalink":"http://zhumenger.top/tags/背包问题/"}]},{"title":"博弈论","text":"博弈论一.NIM博弈给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。 我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。NIM博弈不存在平局，只有先手必胜和先手必败两种情况。 定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An != 0 代码如下： 123456789101112131415#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int a[N];int main()&#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++)cin &gt;&gt; a[i]; int ans = 0; for(int i = 0; i &lt; n; i++)ans ^= a[i]; if(ans != 0)cout &lt;&lt; \"Yes\" &lt;&lt; endl; else puts(\"No\"); return 0;&#125; 二.SG函数Mex运算： 设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：mex(S) = min{x}, x属于自然数，且x不属于S SG函数 在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达子节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即：SG(x) = mex({SG(y1), SG(y2), …, SG(yk)}) 特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。 有向图游戏的和 设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即： SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm) 定理有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。 例题：集合-Nim游戏 给定n堆石子以及一个由k个不同正整数构成的数字集合S。 现在有两位玩家轮流操作，每次操作可以从任意一堆石子中拿取石子，每次拿取的石子数量必须包含于集合S，最后无法进行操作的人视为失败。 问如果两人都采用最优策略，先手是否必胜。 输入格式 第一行包含整数k，表示数字集合S中数字的个数。 第二行包含k个整数，其中第i个整数表示数字集合S中的第i个数si。 第三行包含整数n。 第四行包含n个整数，其中第ii个整数表示第i堆石子的数量hi。 输出格式 如果先手方必胜，则输出“Yes”。 否则，输出“No”。 数据范围1≤n,k≤1001≤si,hi≤10000 输入样例： 2 2 53 2 4 7 输出样例： Yes 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 110, M = 10010;int n, m;int f[N], SG[M], s[M];void getSG(int n)//SG函数模板&#123; memset(SG, 0, sizeof SG); for(int i = 1; i &lt;= n; i++)&#123; memset(s, 0, sizeof s); for(int j = 0; f[j] &lt;= i &amp;&amp; j &lt; m; j++)&#123; s[SG[i - f[j]]] = 1;//记录i的子节点的SG函数 &#125; for(int j = 0;; j++)&#123; if(!s[j])&#123; SG[i] = j; break; &#125; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; m; for(int i = 0; i &lt; m; i++)cin &gt;&gt; f[i]; sort(f, f + m); getSG(10000); cin &gt;&gt; n; int ans = 0; for(int i = 0; i &lt; n; i++)&#123; int x; cin &gt;&gt; x; ans ^= SG[x]; &#125; if(ans)puts(\"Yes\"); else puts(\"No\"); return 0;&#125;","path":"2019/07/11/数论/博弈论/","date":"07-11","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"博弈论","slug":"博弈论","permalink":"http://zhumenger.top/tags/博弈论/"}]},{"title":"容斥原理","text":"容斥原理什么是容斥原理 在计数时，必须注意没有重复，没有遗漏。为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。 1.假设有俩个圆相交，要你求它的面积，便可得到 两个集合的容斥关系：S1∪S2 =|S1∪S2| = |S1|+|S2| - |S1∩S2 | *2.假设有3个圆相交，要你求它的面积: * 那么三个集合的容斥关系S = s1 + s2 + s3 - (s1 ∩ s2) - (s1 ∩ s3) - (s2 ∩ s3) + (s1 ∩ s2 ∩ s3) 在这个基础上加以推广便可得到我们的容斥原理公式： 题目描述给定一个整数n和m个不同的质数p1,p2,…,pm。 请你求出1~n中能被p1,p2,…,pm中的至少一个数整除的整数有多少个。 输入格式第一行包含整数n和m。 第二行包含m个质数。 输出格式输出一个整数，表示满足条件的整数的个数。 数据范围1≤m≤161≤n,pi≤109 输入样例： 10 22 3 输出样例： 7 代码如下： 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;const int N = 20;typedef long long int ll;int a[N];int main()&#123; int n,m; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i++) cin &gt;&gt; a[i]; int ans = 0; for(int i = 1; i &lt; 1 &lt;&lt; m; i++)&#123;//用位运算来表示哪些数被选过 int t = 1, cnt = 0; //t表示所有被选的数的乘积，cnt表示选中数的个数 for(int j = 0; j &lt; m; j++)&#123; if(i &gt;&gt; j &amp; 1)&#123; cnt++; if((ll)t * a[j] &gt; n)&#123; //如果乘积大于n, 则这种方法不行 t = -1; break; &#125; t *= a[j]; &#125; &#125; if(t != -1)&#123; //奇+ 偶- if(cnt % 2)ans += n / t; //n里面有多少个t else ans -= n / t; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","path":"2019/07/11/数论/容斥原理/","date":"07-11","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"容斥原理","slug":"容斥原理","permalink":"http://zhumenger.top/tags/容斥原理/"}]},{"title":"JS基础之强制类型转换","text":"强制类型转换将一个数据类型转化为另一个数据类型，如：String Number Boolean 1.转化为String类型123456789101112131415161718192021222324252627282930313233343536373839&lt;script type=\"text/javascript\"&gt; /* *方式一： * -调用被转换数据类型的toString()的方法 * -该方法不会影响到原变量，它会将转换的结果返回 * -注意：null和undefined这俩个值没有toString()方法 * 如果调用他们，会报错 */ var a = 123; var b = a.toString(); console.log(typeof a);//输出number console.log(typeof b)//输出string //给自己赋值 a = a.toString(); a = null; //a = a.toString();//报错 a = undefined; //a = a.toString();//报错 /*方式二： * -调用String()函数，并将被转换的数据作为参数传递给函数 * -调用String()函数做强制类型转换时， * 对于Number和boolean实际上就是调用的toString()方法 * 对于null和undefined不会调用toString()方法 * 它会直接转化为字符串 */ a = 123; a = String(a); a = null; a = String(a);//输出字符串\"null\" a = undefined; a = String(a);//输出字符串\"undefined\" &lt;/script&gt; 2.转化为number类型1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;script type=\"text/javascript\"&gt; /* *方式一: * -使用Number()函数 * -字符 --&gt; 数字 * 1.如果是纯数字的字符串，直接转化为相应的数字 * 2.如果字符串中有只要有非数字的内容，则转换为NaN * 3.如果字符串为空串或者全是空格，则转化为0 * -布尔 --&gt; 数字 * true 转为1 * false 转为0 * -Null --&gt; 数字 0 * -undefined --&gt; 数字 NaN */ var a = \"123\"; a = Number(a); a = true; a = Number(a);//值为1 a = false; a = Number(a);//值为0 a = null; a = Number(a);//值为0 a = undefined; a = Number();//值为NaN /* *转化方式二： * -专门用来对付字符串的 * -parseInt();//把字符串转化为一个整数 * -parseFloat();//把一个字符串转化为浮点数 * -可以将字符串中有效的数字转化为Number * -只要遇到非数字内容，后面的即使有整数也不再读取 * -如果对非String使用parseInt() * 它会先将其转化为String,然后在操作 */ a = \"123px\"; a = parseInt(a);//输出123 a = true; a = parseInt(a);//输出NaN&lt;/script&gt;","path":"2019/07/10/JavaScirpt/JS基础之强制类型转换/","date":"07-10","excerpt":"","tags":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/tags/JavaScirpt/"}]},{"title":"满足条件的01序列","text":"题目描述 给定n个0和n个1，它们将按照某种顺序排成长度为2n的序列，求它们能排列成的所有序列中，能够满足任意前缀序列中0的个数都不少于1的个数的序列有多少个。 输出的答案对109+7取模。 输出格式 共一行，包含整数n。 输出格式 共一行，包含一个整数，表示答案。 数据范围 1≤n≤105 输入样例： 3 输出样例： 5 题解： 可以将这道题转化为表格的形式，0表示向左走一格，1表示向上走一格，要想满足前缀序列中0的个数始终不少于1的个数，只需满足x &gt;= y即可，如下图所示 即到(n, n)的路径中不能越过红线，越过红线的路径皆为违法的路径,如下图所示： 任意一条违法的路径都能通过 y = x 这条线从(n, n)映射到(n - 1, n + 1) 所以违法的路径我们是可以求出来的，即C(2n, n - 1), 那么用总路径减去违法的路径便是我们想要求出的答案 即answer = C(2n, n) - C(2n, n - 1), 化简可得answer = (2n)! /(n! * n!)/(1 + n) = C(2n, n) / (1 + n) 代码如下： 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;typedef long long ll;const int mod = 1e9 + 7;int ksm(int a, int b)//快速幂求乘法逆元&#123; ll ans = 1; while(b)&#123; if(b &amp; 1)ans = (ll)ans * a % mod; b &gt;&gt;= 1; a = (ll)a * a % mod; &#125; return ans;&#125;int main()&#123; int n; cin &gt;&gt; n; int a = 2 * n, b = n; int ans = 1; for(int i = a; i &gt; a - b; i--) ans = (ll)ans * i % mod; for(int i = 1; i &lt;= b; i++) ans = (ll)ans * ksm(i, mod - 2) % mod; ans = (ll)ans * ksm(n + 1, mod - 2) % mod; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","path":"2019/07/10/数论/满足条件的01序列/","date":"07-10","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"}]},{"title":"组合数IV之高精度","text":"题目描述 输入a,b，求C(a, b)的值。 注意结果可能很大，需要使用高精度计算。 输入格式 共一行，包含两个整数a和b。 输出格式 共一行，输出C(a, b)的值。 数据范围 1≤b≤a≤5000 输入样例： 5 3 输出样例： 10 题解： 可以用公式C(a, b) = a! / (b! * (a - b)!) 来做，如果直接用for循环求阶乘的话，时间复杂度很大，我们求除法运算的时候，一般都是将他们分解质因数，然后用分子分解质因数的个数减去分母分解质因数的个数，最后将质因数乘起来便是最后的答案 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N = 5010;int primes[N], cnt;int sum[N];bool st[N];void get_primes(int n) //线性筛法得到质因数&#123; for(int i = 2; i &lt;= n; i++)&#123; if(!st[i]) primes[cnt++] = i; for(int j = 0; j &lt; cnt &amp;&amp; primes[j] &lt;= n / i; j++)&#123; st[primes[j] * i] = true; if(i % primes[j] == 0)break; &#125; &#125;&#125;int get(int n, int p)//得到p这个质因数的个数&#123; int res = 0; while(n)&#123; res += n / p; n /= p; &#125; return res;&#125;vector&lt;int&gt; mul(vector&lt;int&gt; a, int b)//高精度乘法&#123; vector&lt;int&gt; ans; int t = 0; for(int i = 0; i &lt; a.size(); i++)&#123; t += a[i] * b; ans.push_back(t % 10); t /= 10; &#125; while(t)&#123; ans.push_back(t % 10); t /= 10; &#125; return ans;&#125;int main()&#123; int a, b; cin &gt;&gt; a &gt;&gt; b; get_primes(a); for(int i = 0; i &lt; cnt; i++)&#123; int p = primes[i]; sum[i] = get(a, p) - get(b, p) - get(a - b, p);//获取除法运算中每个质因数的个数 &#125; vector&lt;int&gt;res; res.push_back(1); for(int i = 0; i &lt; cnt; i++)&#123;//枚举每个质因数 for(int j = 0; j &lt; sum[i]; j++)&#123;//枚举个数 res = mul(res, primes[i]);//高精度乘法 &#125; &#125; for(int i = res.size() - 1; i &gt;= 0; i--)&#123;//倒序输出 cout &lt;&lt; res[i]; &#125; return 0;&#125;","path":"2019/07/10/数论/组合数IV之高精度/","date":"07-10","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"组合数","slug":"组合数","permalink":"http://zhumenger.top/tags/组合数/"}]},{"title":"高斯消元解线性方程组","text":"一.高斯消元解线性方程组题目描述输入一个包含n个方程n个未知数的线性方程组。 方程组中的系数为实数。 求解这个方程组。 下图为一个包含m个方程n个未知数的线性方程组示例： 输入格式 第一行包含整数n。 接下来n行，每行包含n+1个实数，表示一个方程的n个系数以及等号右侧的常数。 输出格式 如果给定线性方程组存在唯一解，则输出共n行，其中第i行输出第i个未知数的解，结果保留两位小数。 如果给定线性方程组存在无数解，则输出“Infinite group solutions”。 如果给定线性方程组无解，则输出“No solution”。 数据范围 1≤n≤100,所有输入系数以及常数均保留两位小数，绝对值均不超过100。 输入样例： 3 1.00 2.00 -1.00 -6.002.00 1.00 -3.00 -9.00-1.00 -1.00 2.00 7.00 输出样例： 1.00-2.003.00 题解： 高斯消元，即线性代数的知识，将方程组系数矩阵转化为三角矩阵: 1.枚举每一列，在每一列中找到绝对值最大的一行 2.将改行放到最上面，并将该行首非零元素化为1 3.将下面的所有行的第c列化为0， 4.最终得到三角矩阵，倒叙遍历，不断减去前面的解乘以系数，便可得到所有的解 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int N = 110;const double eps = 1e-6;int n;double a[N][N];int gauss()&#123; int c, r; for(c = 0, r = 0; c &lt; n; c++)&#123;//枚举每一列 int t = r; for(int i = r; i &lt; n; i++) if(fabs(a[i][c]) &gt; fabs(a[t][c]))//找到这一列绝对值最大的一行 t = i; if(fabs(a[t][c]) &lt; eps)continue; //如果全为0，则略过 for(int i = c; i &lt; n + 1; i++)swap(a[t][i], a[r][i]);//将第t行与第r行交换 for(int i = n; i &gt;= c; i--)a[r][i] /= a[r][c];//将首元素系数化为1 for(int i = r + 1; i &lt; n; i++) //将第r + 1行以下的第c列的元素化为0 if(fabs(a[i][c]) &gt; eps) for(int j = n; j &gt;= c; j--) //每一列都要相减 a[i][j] -= a[r][j] * a[i][c]; r++; &#125; if(r &lt; n)&#123; //如果r &lt; n, r + 1 行一下的系数都为0 for(int i = r; i &lt; n; i++) if(fabs(a[i][n]) &gt; eps) //a[i][n]不为0，说明0 = a[i][n]，无解 return 2; return 1; //否则有无穷多解 &#125; for(int i = n - 1 ; i &gt;= 0; i--) //否则有唯一解 for(int j = i + 1; j &lt; n; j++) //倒叙遍历，减去xi之前的x(i + j) * 系数，变得到了xi的解 a[i][n] -= a[j][n] * a[i][j]; return 0;&#125;int main()&#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt;= n; j++) cin &gt;&gt; a[i][j]; int t = gauss(); if(t == 0)&#123; for(int i = 0; i &lt; n; i++)printf(\"%.2lf\\n\", a[i][n]); &#125; else if(t == 1)puts(\"Infinite group solutions\"); else puts(\"No solution\"); return 0;&#125; 二.高斯消元解异或线性方程组题目描述 输入一个包含n个方程n个未知数的异或线性方程组。 方程组中的系数和常数为0或1，每个未知数的取值也为0或1。 求解这个方程组. 异或线性方程组示例如下： 1234M[1][1]x[1] ^ M[1][2]x[2] ^ … ^ M[1][n]x[n] = B[1]M[2][1]x[1] ^ M[2][2]x[2] ^ … ^ M[2][n]x[n] = B[2]…M[n][1]x[1] ^ M[n][2]x[2] ^ … ^ M[n][n]x[n] = B[n] 其中“^”表示异或(XOR)，M[i][j]表示第i个式子中x[j]的系数，B[i]是第i个方程右端的常数，取值均为0或1。 输入格式 第一行包含整数n。 接下来n行，每行包含n+1个整数0或1，表示一个方程的n个系数以及等号右侧的常数。 输出格式 如果给定线性方程组存在唯一解，则输出共n行，其中第i行输出第i个未知数的解。 如果给定线性方程组存在无数解，则输出“Infinite group solutions”。 如果给定线性方程组无解，则输出“No solution”。 数据范围 1≤n≤100 输入样例： 3 1 1 0 10 1 1 01 0 0 1 输出样例： 1 00 题解： 思路跟第一题一样，代码稍微改改就行 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int N = 110;int n;int a[N][N];int gauss()&#123; int c, r; for(c = 0, r = 0; c &lt; n; c++)&#123;//枚举每一列 int t = r; for(int i = r; i &lt; n; i++) if(a[i][c] &gt; a[t][c])//找到这一列绝对值最大的一行 t = i; if(!a[t][c])continue; //如果全为0，则略过 for(int i = c; i &lt; n + 1; i++)swap(a[t][i], a[r][i]);//将第t行与第r行交换 for(int i = r + 1; i &lt; n; i++) //将第r + 1行以下的第c列的元素化为0 if(a[i][c]) for(int j = n; j &gt;= c; j--) //每一列都要异或 a[i][j] ^= a[r][j]; r++; &#125; if(r &lt; n)&#123; //如果r &lt; n, r + 1 行一下的系数都为0 for(int i = r; i &lt; n; i++) if(a[i][n]) //a[i][n]不为0，说明0 = a[i][n]，无解 return 2; return 1; //否则有无穷多解 &#125; for(int i = n - 1 ; i &gt;= 0; i--) for(int j = i + 1; j &lt; n; j++) a[i][n] ^= a[j][n] * a[i][j]; return 0;&#125;int main()&#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt;= n; j++) cin &gt;&gt; a[i][j]; int t = gauss(); if(t == 0)&#123; for(int i = 0; i &lt; n; i++)printf(\"%d\\n\", a[i][n]); &#125; else if(t == 1)puts(\"Infinite group solutions\"); else puts(\"No solution\"); return 0;&#125;","path":"2019/07/09/数论/高斯消元解线性方程组/","date":"07-09","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"高斯消元","slug":"高斯消元","permalink":"http://zhumenger.top/tags/高斯消元/"}]},{"title":"JS基础之标识符、数据类型","text":"一.标识符1.在JS中所有的可以由我们自主命名的都可以称为标识符 2.命名规则： 1.标识符中可以含有字母、数字、下划线和$。2.标识符不能以数字开头3.标识符不能是关键字 4.标识符一般采用驼峰命名法： 首字母小写，每个单词的开头字母大写，其余字母小写 如: var helloWorld = 123； 二.数据类型数据类型指的是字面量的类型，一共有6种 String 字符串 Number 数值 Boolean 布尔值 Null 空值 Undefined 未定义 Object 对象 前5个为基本数据类型，Object属于引用数据类型 1.字符串声明: 1234567&lt;script type=\"text/javascript\"&gt; var str = \"hello\"; //输出字面量 字符串str alert(\"str\"); //输出变量str alert(str);&lt;/script&gt; 1&gt;.单引号，双引号都可以，但必须配对，不能混淆 2&gt;.引号不能嵌套，双引号里不能放双引号，单引号里不能放单引号 3&gt;.双引号里可以嵌套单引号 4&gt;.如果想要任意嵌套，必须加入转义字符 转义字符： 在字符串中可以用\\作为转义字符 如\\ “表示 单引号， \\ n 表示换行， \\ \\ 表示斜杠 2.数值1&gt;.声明 123&lt;script type=\"text/javascript\"&gt; var a = 123;&lt;/script&gt; 2&gt;.可以用 typeof 来检查一个变量的类型 123456&lt;script type=\"text/javascript\"&gt; var a = 123; console.log(typeof a);//输出“number”类型 var b = \"123\" console.log(typeof b);//输出“string”类型&lt;/script&gt; 3&gt;.输出数字的最大值、最小值 1234567&lt;script type=\"text/javascript\"&gt; //输出最大值 console.log(Number.MAX_VALUE); //输出最小值 console.log(Number.MIN_VALUE); //如果使用的Number表示的数字超过了最大值,则会返回一个Infinity表示无穷&lt;/script&gt; 4&gt;.NAN 是一个特殊的数字， 表示Not A Number 1234567&lt;script type=\"text/javascript\"&gt; var a = \"abc\" * \"abc\"; console.log(a); //输出NAN， console.log(typeof a); //输出number&lt;/script&gt; 5&gt;.如果JS进行浮点元素，可能得到一个不确定的结果 12345&lt;script type=\"text/javascript\"&gt; var a = 0.1 + 0.2; comsole.log(a); //输出0.3000000000000004&lt;/script&gt; 3.布尔值 Boolean1234567891011&lt;script type=\"text/javascript\"&gt; /* *Boolean 布尔值 * 布尔值只有俩个 * true -表示真 * false -表示假 */ var bool = false; console.log(bool)//输出false console.log(typeof bool)//输出boolean&lt;/script&gt; 4.Null12345678910&lt;script type=\"text/javascript\"&gt; /* * Null类型只有一个,就是null * null表示一个为空的对象 * 使用typeof检查null值时，返回object */ var a = null; console.log(a);//输出null console.log(typeof a);//输出//object &lt;/script&gt; 5.Undefined12345678&lt;script type=\"text/javascript\"&gt; /* * Undefined的类型只有一个，就是undefined * 当声明一个变量未赋值时，就是undefined */ var a; console.log(a)//输出undefined &lt;/script&gt;","path":"2019/07/08/JavaScirpt/JS基础之标识符、数据类型/","date":"07-08","excerpt":"","tags":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/tags/JavaScirpt/"}]},{"title":"扩展欧几里得算法","text":"一.扩展欧几里得算法裴蜀定理 对于任意的整数a, b，存在一对整数 x，y，满足ax + by = gcd(a, b). 题目描述 给定n对正整数ai,bi，对于每对数，求出一组xi,yi，使其满足ai∗xi+bi∗yi=gcd(ai,bi)。 输入格式 第一行包含整数n。 接下来n行，每行包含两个整数ai,bi。 输出格式 输出共n行，对于每组ai,bi，求出一组满足条件的xi,yi，每组结果占一行。 本题答案不唯一，输出任意满足条件的xi,yi均可。 数据范围 1≤n≤1051≤ai,bi≤2∗109 输入样例： 2 4 68 18 输出样例： -1 1-2 1 代码如下： 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;typedef long long int ll;ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y)&#123; if(b == 0)&#123; x = 1; y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x ; //y表示b的系数 return d;&#125;int main()&#123; int n; ll a, b, x, y; cin &gt;&gt; n; while(n--)&#123; scanf(\"%lld%lld\", &amp;a, &amp;b); ll d = exgcd(a, b, x, y); printf(\"%lld %lld\\n\", x, y); &#125; return 0;&#125; 二.线性同余方程题目描述给定n组数据ai,bi,mi，对于每组数求出一个xi，使其满足ai∗xi≡bi(mod mi)，如果无解则输出impossible。 输入格式第一行包含整数n。 接下来n行，每行包含一组数据ai,bi,mi。 输出格式输出共n行，每组数据输出一个整数表示一个满足条件的xi，如果无解则输出impossible。 每组数据结果占一行，结果可能不唯一，输出任意一个满足条件的结果均可。 输出答案必须在int范围之内。 数据范围1≤n≤10^51≤ai,bi,mi≤2∗10^9 输入样例： 2 2 3 64 3 5 输出样例： impossible7 题解： 对于a * x % m = b 等价于 a * x - b 是m的倍数，不妨设为 -y 倍。于是，该方程可以改写为 a * x + m * y = b。 这样就变成了欧几里得算法，只有 b 为 gcd(a, m) 的倍数的时候，方程才有解，带公式即可 代码如下： 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;typedef long long int ll;ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y)&#123; if(b == 0)&#123; x = 1; y = 0; return a; &#125; ll d = exgcd(b, a % b, y ,x); y -= a / b * x; return d;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; ll a, b, c; ll x, y; scanf(\"%lld %lld %lld\", &amp;a, &amp;b, &amp;c); ll d = exgcd(a, c, x, y); if(b % d == 0) printf(\"%lld\\n\", x *(b / d) % c); //x 乘以倍数 % c else puts(\"impossible\"); &#125; return 0;&#125;","path":"2019/07/08/数论/扩展欧几里得算法/","date":"07-08","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"http://zhumenger.top/tags/扩展欧几里得/"}]},{"title":"JS基础之基本语法、字面量和变量","text":"一.基本语法1.注释 123456&lt;script type=\"text/javascript\"&gt; //单行注释 /* 多行注释，注释中的内容不会被执行 */&lt;/script&gt; 2.JS中严格区分大小写 12alert(\"hello world\");//可以执行Alert(\"hello world\")；//会报错 3.分号表示一个语句的结束. 如果不写分号，浏览器会自动添加，但是会消耗一些系统资源 而且有点时候，浏览器会加错分号，所以在开发中分号必须写 4.JS会忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化 二.字面量和变量1.字面量 都是一些不可改变的值，比如：1 2 3 4 5 字面量可以直接使用，但是我们一般都不会直接使用字面量 2.变量 可以用来保存字面量，而且变量的值可以任意改变 所以在开发中都是通过变量取保存一个字面量，而很少直接用到字面量 3.变量的使用 123456//在JS中使用var关键字来声明一个变量var a;//为变量赋值a = 123；//向页面输出adocument.write(a)","path":"2019/07/07/JavaScirpt/JS基础之基本语法、字面量和变量/","date":"07-07","excerpt":"","tags":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/tags/JavaScirpt/"}]},{"title":"JS基础之编写位置","text":"1.可以将JS的代码写到标签的属性中，当点击按钮时执行 1&lt;button onclick = \"alert('讨厌，你点我干嘛');\"&gt;点我一下&lt;/button&gt; 2.可以将JS代码写在href属性中，这样点击超链接时，会执行JS代码 1&lt;a href=\"javascript:alert('让你点你就点');\"&gt;你也点我一下&lt;/a&gt; 虽然可以写在标签的属性中，但是他们属于结构与行为耦合不方便维护，不推荐使用 3.可以将JS写在script标签中,打开网页时直接运行 123&lt;script type=\"text/javascript\"&gt; alert(\"我是script标签中的代码\");&lt;/script&gt; 4.可以将JS代码写到外部JS文件中，然后通过script标签引入,用src引入路径 1&lt;script type=\"text/javascript\" src=\"script.js\"&gt;&lt;/script&gt; script标签一旦引入外部文件，就不能编写代码了，即使编写了代码，编译器也会忽略","path":"2019/07/07/JavaScirpt/JS基础之编写位置/","date":"07-07","excerpt":"","tags":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/tags/JavaScirpt/"}]},{"title":"JS基础之Hello World","text":"输出语句1.所有的JS代码都要放到script标签里 2.alert(）：可以控制浏览器发出一个警告框 123&lt;script type=\"text/javascript\"&gt; alert(\"这是我的第一行JS代码\");&lt;/script&gt; 效果如下： 3.document.write()可以向body中输出一个内容 123&lt;script type=\"text/javascript\"&gt; document.write(\"看我出不出来\");&lt;/script&gt; 4.console.log()可以向控制台输出一个内容 123&lt;script type=\"text/javascript\"&gt; console.log(\"你猜猜我在哪\");&lt;/script&gt; 效果如下：","path":"2019/07/07/JavaScirpt/JS基础之Hello-World/","date":"07-07","excerpt":"","tags":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://zhumenger.top/tags/JavaScirpt/"}]},{"title":"快速幂","text":"一.快速幂快速幂问题（求a^b）: 1.我们都知道当指数为偶数的时候，对于a ^b，可以变为(a ^ 2) ^ (b/2)。2.而当指数为奇数的时候，对于a ^ b，可以化简为a * (a ^ (b-1))，然后即可以化简为a * ((a ^ 2) ^ ((b-1)/2))3.如此我们便可知道 如果b为奇数，则将b减一除二，将一个a取到外面，同时对里面的a平方。4.如果b为偶数，则直接除二，同时对a平方。 若b为7，a为2。则a变为4，b变为3，ans变为2 * (2 ^ 2) ^ 3。然后继续向后运，(注意此时a为4)，a变为16，b变为1，ans变为2* 4*(2 ^ 2 ^ 2) ^ 1。结果为128。 若b为10，a为2。则a变为4，b变为5，ans变(2 ^ 2) ^ 5。然后继续向后运，(注意此时a为4)，a变为16，b变为2，ans变为4(2 ^ 2 ^ 2) ^2。再之后(注意此时a为16)，a变为256，b变为1，ans变为4(2 ^ 2 ^ 2 ^ 2) ^ 1。结果为1024 快速幂取余 代码如下： 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;typedef long long int ll;ll a, b, c;void solve()&#123; ll ans = 1; while(b)&#123; if(b &amp; 1)ans = ans * a % c; //如果b为奇数 b &gt;&gt;= 1; //b除以2 a = a * a % c; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; solve(); &#125; return 0;&#125; 二.快速幂求逆元题目描述 给定n组ai,pi，其中pipi是质数,求ai模pi的乘法逆元，若逆元不存在则输出impossible。 输入格式 第一行包含整数n。 接下来n行，每行包含一个数组ai,pi，数据保证pi是质数。 输出格式 输出共n行，每组数据输出一个结果，每个结果占一行。 若ai模pi的乘法逆元存在，则输出一个整数，表示逆元，否则输出impossible。 数据范围 1≤n≤10^51≤ai,pi≤2∗10^9 输入样例： 3 4 38 56 3 输出样例： 1 2impossible 什么是逆元** 若b与m互质，对于a/b(a是b的倍数) % m，可以找到一个数x使得ax % m = a/b % m,那么我们称x为b%m的逆元 费马定理： 若p为质数，则b^(p - 1) % p == 1。 题解： 这道题用到了费马定理，b * b^(p - 2) % p == 1,所以只需求b^(p - 2) % p即可，那么这道题便转化为了一道快速幂的问题 代码如下： 12345678910111213141516171819202122232425//费马定理：若p为质数，则a^(p -1)% p == 1,可得a * a^(p - 2) % p == 1，这道题求a^(p - 2) % p 便是a的逆元#include&lt;iostream&gt;using namespace std;typedef long long int ll;ll ksm(ll a, ll b, ll c)&#123; ll ans = 1; while(b)&#123; if(b &amp; 1)ans = ans * a % c; b &gt;&gt;= 1; a =a * a % c; &#125; return ans;&#125;int main()&#123; ll t, a, b; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; a &gt;&gt; b; if(a % b == 0)cout &lt;&lt; \"impossible\" &lt;&lt; endl;//若a是p的倍数，则不存在逆元 else cout &lt;&lt; ksm(a, b - 2, b) &lt;&lt;endl; &#125; return 0;&#125;","path":"2019/07/07/数论/快速幂/","date":"07-07","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"快速幂","slug":"快速幂","permalink":"http://zhumenger.top/tags/快速幂/"}]},{"title":"欧拉函数","text":"一.欧拉函数什么是欧拉函数： 1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)。 欧拉函数的通式： φ(n)=n(1-1/p1)(1-1/p2)(1-1/p3)(1-1/p4)…..(1-1/pn),其中p1, p2……pn为n的所有质因数，n是不为0的整数。φ(1)=1（唯一和1互质的数就是1本身）。 欧拉定理： 若a与n互质，则a^φ(n) % n == 1 求欧拉函数的代码如下： 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;typedef long long int ll;void solve(ll n)&#123; ll ans = n; for(int i = 2; i &lt;= n / i; i++)&#123; if(n % i == 0)&#123; ans = ans / i * (i - 1);//如果i为n的质因数，则带入公式 while(n % i == 0)n /= i;//分解质因数 &#125; &#125; if(n &gt; 1)ans = ans / n * (n - 1); cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; ll n, t; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; n; solve(n); &#125; return 0;&#125; 二.. 筛法求欧拉函数 给定一个正整数n，求1~n中每个数的欧拉函数之和。 输入格式 共一行，包含一个整数n。 输出格式 共一行，包含一个整数，表示1~n中每个数的欧拉函数之和。 数据范围 1≤n≤10^6 输入样例： 6 输出样例： 12 思路： 在线性筛法的过程得到每个数的欧拉函数 1.如果i为质数，则i之前的数都与i互质,所以φ(i) = i - 1, 2.如果i % prime[j] == 0,φ(prime[j] * i) = prime[j] * ouler[i]; 3.若果i % prime[j] != 0, φ(prime[j] * i) = ouler[i] * (prime[j] - 1) 代码如下： 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int prime[N], ouler[N], cnt;typedef long long int ll;bool vis[N];void get_ouler(int n)&#123; ouler[1] = 1; //φ(1) = 1,与1互质的数为1 for(int i = 2; i &lt;= n; i++)&#123; if(!vis[i])&#123; //如果是质数 prime[cnt++] = i; ouler[i] = i - 1;//φ(i) = i - 1 &#125; for(int j = 0; j &lt; cnt &amp;&amp; prime[j] &lt;= n / i; j++)&#123; vis[prime[j] * i] = true; if(i % prime[j] == 0)&#123; ouler[prime[j] * i] = prime[j] * ouler[i]; break; &#125; ouler[prime[j] * i] = ouler[i] * (prime[j] - 1); &#125; &#125; ll ans = 0; for(int i = 1; i &lt;= n; i++) ans += ouler[i]; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; int n; cin &gt;&gt; n; get_ouler(n); return 0;&#125;","path":"2019/07/07/数论/欧拉函数/","date":"07-07","excerpt":"","tags":[{"name":"数论","slug":"数论","permalink":"http://zhumenger.top/tags/数论/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"http://zhumenger.top/tags/欧拉函数/"}]},{"title":"约数","text":"算术基本定理任何一个大于1的自然数 N ，如果N不为质数，都可以唯一分解成有限个质数的乘积 N = P1^a1 * P2^a2 ….Pn^an , 这里 P1&lt;P2&lt;….&lt;Pn均为质数，其诸指数 ai 是正整数。 定理应用（1）一个大于1的正整数N，如果它的标准分解式为： N = P1^a1 * P2^a2 ….Pn^an ，那么它的正因数个数为 φ(N) = (1 + a1)(1 + a2)(1 +a3)。 （2） 它的全体正因数之和为φ(N) = (1 + p1 + p1^2 + …+ p1^a1)(1 + p2 + p2^2 + … + p2^a2)…(1 + pn + pn^2 + … + pn^an). 一.约数个数题目描述 给定n个正整数ai，请你输出这些数的乘积的约数个数，答案对109+7取模。 输入格式 第一行包含整数n。 接下来n行，每行包含一个整数ai。 输出格式 输出一个整数，表示所给正整数的乘积的约数个数，答案需对109+7109+7取模。 数据范围 1≤n≤1001≤ai≤2∗10^9 输入样例： 3 26 8 输出样例： 12 求n个数乘积的约数的个数，用到了定理（1）的知识，代码如下： 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;unordered_map&gt;using namespace std;unordered_map&lt;int, int&gt; mp;typedef long long int ll;const int mod = 1e9 + 7;void solve(ll n)&#123; for(int i = 2; i &lt;= n / i; i++)&#123; while(n % i == 0)&#123; n /= i; mp[i]++; &#125; &#125; if(n &gt; 1)mp[n]++;//先分解所有的质因子&#125;int main()&#123; ll n, t; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt;n; solve(n); &#125; ll ans = 1; for(auto mps : mp)&#123; ans = ans * (mps.second + 1) % mod;//代公式即可 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 二.约数之和 给定n个正整数ai，请你输出这些数的乘积的约数之和，答案对109+7取模。 输入格式 第一行包含整数n。 接下来n行，每行包含一个整数ai。 输出格式 输出一个整数，表示所给正整数的乘积的约数之和，答案需对109+7取模。 数据范围 1≤n≤1001≤ai≤2∗10^9 输入样例： 3 26 8 输出样例： 252 求n个数乘积的约数之和，用到了定理（2）的知识，代码如下： 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;unordered_map&gt;using namespace std;const int mod = 1e9 + 7;typedef long long int ll;unordered_map&lt;int, int &gt;mp;void solve(ll n)&#123; for(ll i = 2; i &lt;= n / i; i++)&#123; while(n % i == 0)&#123; n /= i; mp[i]++; &#125; &#125; if(n &gt; 1)mp[n]++;//分解所有的质因数&#125;int main()&#123; int t; ll n; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; n; solve(n); &#125; ll ans = 1; for(auto mps : mp)&#123; ll t= 1; ll x = mps.first, a = mps.second; while(a--)t = (t * x + 1) % mod; //带公式即可 ans = ans * t % mod; &#125; cout &lt;&lt;ans &lt;&lt; endl;&#125;","path":"2019/07/07/数论/约数/","date":"07-07","excerpt":"","tags":[{"name":"数论，约数","slug":"数论，约数","permalink":"http://zhumenger.top/tags/数论，约数/"}]},{"title":"二分图","text":"二分图1.定义： 二分图是指将图中的点分为俩个集合X和Y，满足所有的边仅在俩个集合之间，并且俩个集合中没有边，即X中的点只与Y中的点相连，如下图所示，这样的图称为二分图。 2.性质： 当且仅当图中不含奇数环，即所有的环的边数为偶数。这样的图一定是二分图。 3.判定： 染色法判定二分图原理： 首先任意取出一个顶点进行染色,和该节点相邻的点有三种情况: 1.未染色 那么继续染色此节点(染色为另一种颜色) 2.已染色但和当前节点颜色不同 跳过该点 3.已染色并且和当前节点颜色相同 返回失败(该图不是二分图) 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int h[N], e[N], ne[N], idx;int n, m, color[N];//color表示哪些点已经被染了色void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;bool dfs(int x, int c)//c表示染色的种类&#123; color[x] = c; for(int i = h[x]; i != -1; i = ne[i])&#123; int j = e[i]; if(color[j] == c)return false;//如果与i相连的点与i染成了相同的颜色，返回false else if(color[j] == 0 &amp;&amp; !dfs(j, -c))return false; //如果该点还没有被染色，并且染成相反的染色失败了的话，返回false &#125; return true;&#125;int main()&#123; scanf(\"%d%d\", &amp;n, &amp;m); memset(h, -1, sizeof h); while(m--)&#123; int a, b; scanf(\"%d%d\", &amp;a, &amp;b); add(a, b); add(b, a); &#125; bool flag = false; for(int i = 1; i &lt;= n; i++)&#123;//遍历每一个点 if(color[i] == 0)&#123;//如果没有被染色 if(!dfs(i, 1))&#123;// 判断是否能被染色 flag = true; break; &#125; &#125; &#125; if(flag)puts(\"No\"); else puts(\"Yes\"); return 0;&#125; 二分图的最大匹配什么是匹配： 给定一个二分图G，在G的一个子图M中， M的边集{E}中的任意两条边都不交汇于同一个结点，则称M是一个匹配。 图中加粗的边是数量为2的匹配。 二分图的最大匹配 ：选择匹配边数最多的一个子图称为图的最大匹配 如下图所示，加粗的边数最多为3，所以该子图为二分图的最大匹配 如何求二分图的最大匹配： 匈牙利算法 假设左边的集合都为男生，右边的集合都为女生，让我们求出最多有多少对情侣能够配对成功。 对于每个男生，遍历他所有有好感度的女生，有俩种情况： 1.如果该女生是单身，则匹配成功 2.否则我们寻找与该女生的配对的那个男生，看看这个男生是否能和其他的女生配对，如果可以的话，让这个男与其备胎匹配，空出来的这个女生便可以与当前的这个男生配对成功。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e5 + 10;int h[N], e[N], ne[N], idx;int match[N];//一个映射关系:表示妹子与谁配了对bool vis[N];//表示哪些妹子已经遍历过了int n1, n2, m;void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;bool Find(int x)&#123; for(int i = h[x]; i != -1; i = ne[i])&#123;//遍历该男生所有有好感度的女生 int j = e[i]; if(!vis[j])&#123;//如果该女生还没有被当前男生询问过 vis[j] = true;//已经被询问过 if(match[j] == 0 || Find(match[j]))&#123;//如果该女生还没有配对或者与该女生配对的那个男生可以跟另 match[j] = x; //一个女生配对的话，该女生便可以与当前的这个男生配对。 return true;//返回true &#125; &#125; &#125; return false;//否则，返回false&#125;int main()&#123; cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m; memset(h, -1, sizeof h); while(m--)&#123; int a, b; cin &gt;&gt; a &gt;&gt; b; add(a, b); &#125; int ans = 0;//表示成功匹配了对少对 for(int i = 1; i &lt;= n1; i++)&#123; memset(vis, false, sizeof vis);//对于每一个男生，所有的妹子还没有询问过，所以这里要初始化 if(Find(i))ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","path":"2019/06/24/图论/二分图/二分图/","date":"06-24","excerpt":"","tags":[{"name":"图论","slug":"图论","permalink":"http://zhumenger.top/tags/图论/"},{"name":"二分图","slug":"二分图","permalink":"http://zhumenger.top/tags/二分图/"}]},{"title":"最小生成树","text":"最小生成树题目描述 给出无向图中M个节点间N条边的权值。求一个使得所有点连通的子图,要求图内的边权和最小 输入格式 第一行包含两个整数n和m。 接下来m行，每行包含三个整数u，v，w，表示点u和点v之间存在一条权值为w的边。 输出格式 共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出impossible。 数据范围 1≤n≤5001≤n≤500,1≤m≤1051≤m≤105,图中涉及边的边权的绝对值均不超过10000。 输入样例： 4 51 2 11 3 21 4 32 3 23 4 4 输出样例： 6 一.克鲁斯卡尔算法(kruskal)算法定义： 假设 WN=(V,{E}) 是一个含有 n 个顶点的连通图，那么我们把它定义为含有 n 棵树的一个森林。每次从图的边集 E 中选取一条权值最小的边，若该条边的两个顶点分属不同的树，就将这两个顶点分别所在的两棵树合成一棵树，表示这俩个点已经连通；若该条边的两个顶点已落在同一棵树上，则直接跳过，因为前面已经选了一个更小的权值的边使得俩个点连在了一起。然后继续选择下一条最小的边加入到集合里面。依次类推，直至森林中只有一棵树，也即子图中含有 n-1条边为止。 kruskal算法流程: 1.建立并查集，每个点各自构成一个集合2.把所有的边按照权值从小到大排序，一次扫描每一条边3.若x，y属于同一个集合，则忽略这条边，继续扫描下一条边4.否则，合并x，y所在的集合，并将边权值累加到答案中 时间复杂度：O(mlogm) 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e6 + 10, INF = 0x3f3f3f3f;int f[N];struct p&#123; //存储所有的边 int a, b, c;&#125;arr[N];int n, m;bool cmp(p a, p b) //按照边权值从小到达排序&#123; return a.c &lt; b.c;&#125;int Find(int x) //找到x的根节点&#123; if(x != f[x])f[x] = Find(f[x]); return f[x];&#125;int main()&#123; int cnt = 0, ans = 0; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++)f[i] = i; //初始化为n个集合 for(int i = 0; i &lt; m; i++) cin &gt;&gt; arr[i].a &gt;&gt; arr[i].b &gt;&gt; arr[i].c; sort(arr, arr + m, cmp); for(int i = 0; i &lt; m; i++)&#123; int x = Find(arr[i].a); int y = Find(arr[i].b); if(x != y)&#123; //如果不属于同一个集合 f[x] = y; cnt++; //边数++ ans += arr[i].c; //累加边权值 &#125; if(cnt == n - 1)break; &#125; if(cnt == n - 1)cout &lt;&lt; ans &lt;&lt; endl; else cout &lt;&lt; \"impossible\" &lt;&lt;endl; return 0;&#125; 二.prime算法算法简介： 首先维护一个集合，找到集合之外的距离这个集合最近的点，将这个点加入集合，并用这个点去更新其他点到集合的距离，这样得出来的生成树一定是最小的。算法思想跟dijstra算法类似。 时间复杂度：O(n^2) 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 510, INF = 0x3f3f3f3f;int n, m;int arr[N][N], dis[N];bool vis[N];void prime()&#123; memset(dis, INF, sizeof dis); int ans = 0; for(int i = 0; i &lt; n; i++)&#123; int t = -1; for(int j = 1; j &lt;= n; j++) if(!vis[j] &amp;&amp; (t == -1 || dis[t] &gt; dis[j]))//找到集合外的点到该集合距离最短的点 t = j; //用t记录该下标 if(i &amp;&amp; dis[t] == INF)&#123; //如果没有找到距离集合最短的点，说明这个图是不连通的 puts(\"impossible\"); return ; &#125; if(i)ans += dis[t]; //不断的加上该边权值 vis[t] = true; //表示该点已经加入到集合里了 //用t不断更新其他的点到集合的距离 for(int j = 1; j &lt;= n; j++)dis[j] = min(dis[j], arr[t][j]); &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; memset(vis, false, sizeof vis); cin &gt;&gt; n &gt;&gt; m; int a, b, c; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) arr[i][j] = i == j ? 0 : INF; while(m--)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; arr[a][b] = arr[b][a] = min(arr[a][b], c); &#125; prime(); return 0;&#125; 2.prime算法堆优化 跟dijstra算法一样，再找集合外的点到该集合距离最小的点时用堆做了一个优化。时间复杂度为：O(mlogn) 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;int arr[505][505];int dis[505];bool vis[505];typedef pair&lt;int ,int &gt; p;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt;= n; i++) for(int j = 0; j &lt;= n; j++) arr[i][j] = i == j ? 0 : INF; memset(dis, INF, sizeof dis); memset(vis, false, sizeof vis); int a, b, c; for(int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; arr[a][b] = arr[b][a] = min(arr[a][b], c); &#125; priority_queue&lt;p, vector&lt;p&gt;, greater&lt;p&gt; &gt; q; int ans = 0, sum = 0; dis[1] = 0; q.push(&#123;0, 1&#125;); while(q.size()) &#123; p cur = q.top(); q.pop(); int u = cur.second; if(vis[u])continue; vis[u] = true; sum++; //表示该点已经加入到集合当中 ans += dis[u];//加上该边权值 for(int i = 1; i &lt;= n; i++)&#123; //用该点不断更新集合外的点到集合的距离 if(!vis[i] &amp;&amp; dis[i] &gt; arr[u][i])&#123; dis[i] = arr[u][i]; q.push(&#123;dis[i], i&#125;); //如果该点被更新过，就加入到队列中去 &#125; &#125; &#125; if(sum == n)cout &lt;&lt; ans &lt;&lt; endl; //判断是否连通 else cout &lt;&lt; \"impossible\" &lt;&lt; endl; return 0;&#125;","path":"2019/06/24/图论/最小生成树/最小生成树/","date":"06-24","excerpt":"","tags":[{"name":"图论","slug":"图论","permalink":"http://zhumenger.top/tags/图论/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://zhumenger.top/tags/最小生成树/"}]},{"title":"编程俱乐部6月常规赛二题解","text":"编程俱乐部6月常规赛二题解一.魔法雪花 ** **题解： 字符串的最小表示法：每一个字符串都有一个字典序最小的表示，比较这俩个字符串的最小表示是否相等即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;stdio.h&gt;using namespace std;string s1, s2;int n;int get(string s) //获得最小字典序的起始下标&#123; int i = 0, j = 1; while(i &lt;= n &amp;&amp; j &lt;= n) &#123; int k = 0; while(k &lt; n &amp;&amp; s[i + k] == s[j + k])k++; if(k == n)break; if(s[i + k] &lt; s[j + k])&#123; j = j + k + 1; if(i == j)j++; &#125; else &#123; i = i + k + 1; if(i == j)i++; &#125; &#125; return min(i, j);&#125;bool cmp(int i, int j) //比较字符串是否相同&#123; for(int k = 0; k &lt; n; k++)&#123; if(s1[i + k] != s2[j + k])return false; &#125; return true;&#125;int main()&#123; cin &gt;&gt; s1 &gt;&gt; s2; n = s1.size(); s1 += s1; //长度增加2倍 s2 += s2; int l = get(s1); int r = get(s2); if(cmp(l, r))&#123; cout &lt;&lt; \"Yes\" &lt;&lt; endl; for(int i = l; i &lt; l + n; i++) printf(\"%c\", s1[i]); &#125; else cout &lt;&lt; \"No\" &lt;&lt; endl; return 0;&#125; 二.魔仙彩石 题解：单调栈的运用，如果栈首的元素与a[i]相加&gt;m，就不断的弹出元素，直到a[i]与栈首的和&lt;=m或栈中的元素为空，让ans+=q[t]求出答案。 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int a[20010], q[20010], t = 0;int main()&#123; int n, m; long long int ans =0; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; sort(a, a + n); for(int i = 0; i &lt; n; i++)&#123; while(t &gt; 0 &amp;&amp; a[i] + a[q[t]] &gt;m)t--; if(t &gt; 0)ans += q[t] + 1; //单调栈的性质，该下标之前的元素与a[i]相加都小于等于m q[++t] = i; //单调栈记录下标 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; *三黑暗法阵 * 题解：经典的水池问题，如果该点为1，则让它等于0，继续往上下左右遍历，记录最大的ans即可 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;const int N = 110;int a[N][N];int dx[] = &#123;1, 0, -1, 0&#125;;int dy[] = &#123;0, 1, 0, -1&#125;;int n, m, res;void dfs(int x, int y)&#123; res++; a[x][y] = 0; for(int i = 0; i &lt; 4; i++)&#123; int xx = x + dx[i]; int yy = y + dy[i]; if(xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; m &amp;&amp; a[xx][yy] == 1) dfs(xx, yy); &#125;&#125;int main()&#123; while(cin &gt;&gt; n &gt;&gt; m)&#123; if(n == 0 &amp;&amp; m == 0)break; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) cin &gt;&gt; a[i][j]; int ans = 0; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j ++)&#123; if(a[i][j] == 1)&#123; res = 0; dfs(i, j); ans = max(ans, res); &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 四.女王搬水泥 题解： 最小生成树的题，将每条路的建造的时间从小到大排个序，依次遍历，如果都联通了输出当前的时间，break;如果遍历完一遍还没有全部联通，则输出-1 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e6 + 10;int f[N];struct p&#123; int a; int b; int c;&#125;arr[N];int Find(int x)&#123; if(x != f[x])f[x] = Find(f[x]); return f[x];&#125;bool cmp(p a, p b)&#123; return a.c &lt; b.c;&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) f[i] = i; for(int i = 0; i &lt; m; i++) cin &gt;&gt; arr[i].a &gt;&gt; arr[i].b &gt;&gt; arr[i].c; sort(arr, arr + m, cmp); int ans = 0, res = 1; for(int i = 0; i &lt; m; i++)&#123; int x = Find(arr[i].a); int y = Find(arr[i].b); if(x != y)&#123; res++; //记录联通了几个点 f[x] = y; &#125; if(res == n)&#123; //全部联通就输出当前的时间 ans = arr[i].c; break; &#125; &#125; if(res == n)cout &lt;&lt; ans &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; return 0;&#125; 五.游ne娃子的取石子游戏 题解: 取三个最大的互质的数，得到的最小公倍数一定是最大的。如果n为奇数，三个最大的互质的数就是n, n - 1, n- 2。如果n为偶数， 需要判断一下n是否为3的倍数，如果不是，那么三个最大的互质的数就是n, n - 1, n - 3，如果是,那么三个最大的互质的数就是n - 1, n- 2， n - 3. 12345678910111213#include&lt;iostream&gt;using namespace std;int main()&#123; long long int n, ans; cin &gt;&gt; n; if(n % 2)cout &lt;&lt; n &lt;&lt; ' ' &lt;&lt; n - 1 &lt;&lt; ' ' &lt;&lt; n - 2 &lt;&lt; endl; else &#123; if(n % 3)cout &lt;&lt; n &lt;&lt; ' ' &lt;&lt; n - 1 &lt;&lt; ' ' &lt;&lt; n - 3 &lt;&lt; endl; else cout &lt;&lt; n - 1 &lt;&lt; ' ' &lt;&lt; n - 2 &lt;&lt; ' ' &lt;&lt; n - 3 &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/06/23/题解/编程俱乐部6月常规赛二题解/","date":"06-23","excerpt":"","tags":[{"name":"题解","slug":"题解","permalink":"http://zhumenger.top/tags/题解/"}]},{"title":"图论之最短路问题","text":"图论之最短路问题1.什么是最短路： 从某顶点出发，沿图的边到达另一顶点所经过的路径中，各边上权值之和最小的一条路径 2.常用的最短路算法： Dijkstra算法，Bellman-Ford算法，Floyd算法和SPFA算法 3.最短路所有算法的适用情况以及时间复杂度，如下表所示。 算法详解一.Dijkstra算法1.朴素版的Dijkstra 简介： 每次找到已知的能够到达的一条最短的路径，并用这条路径更新它能够到达的所有的点，这样得到的路径一定是最短的，假设有n个点，那么我们就需要遍历n - 1次找到n - 1个边，每次用得到的最短的边依次更新其他可以到达的点。所以时间复杂度为O(n^2) 适用条件： 求单源最短路，并且所有的边都为正数。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1010, INF = 0x3f3f3f3f;int arr[N][N], n, m; //arr用来存边bool vis[N]; //判断边是否已经被选过int d[N]; //存储到每个点的距离void dijstra()&#123; d[1] = 0;//起点距离为1 for(int i = 0; i &lt;n - 1; i++)&#123; //遍历n - 1次，找到至少n -1 条边 int t = -1; for(int j = 1; j &lt;= n; j++)&#123; if(!vis[j] &amp;&amp; (t == -1 || d[t] &gt; d[j])) //找到已知的距离起点最短的一条路 t = j; &#125; for(int j = 1; j &lt;= n; j++) //用这条路径不断的更新到其他的点 d[j] = min(d[j], d[t] + arr[t][j]); //取最小值 vis[t] = true; //表示该点已经被选过了 &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; memset(arr, INF, sizeof arr); //初始化 memset(vis, false, sizeof vis); memset(d, INF, sizeof d); int a, b, c; for(int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; arr[a][b] = min(arr[a][b], c); //有可能给你多条相同的，所以要取最短的那条 &#125; dijstra(); if(d[n] == INF)cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; d[n] &lt;&lt; endl; return 0;&#125; 2.堆优化的Dijkstra： 主要是针对朴素版找到距离最小的一条路径用堆做了一个优化，我们可以用堆来储存已经更新过的点，每次取出堆中的最小的一条边即可，堆的时间复杂度为O(1)，所以在时间上要优化不少。 存图方式： 如果n和m非常大的话，比如1 &lt;= n, m &lt;= 1000000.用数组的方式肯定是存不下的，所以我们一般要用到邻接表的存图方式。也有很多人用vector动态数组来存，但当数据非常大时，vector动态数组开拓空间花费的时间也是非常大的，有的题就专门卡vector，所以邻接表最常用的一种存图方式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N = 1e5 + 10, INF = 0x3f3f3f3f;typedef pair&lt;int, int &gt; p;int h[N], e[N], ne[N], idx, w[N];//邻接表，由n个单链表组成，w[idx]用来存边权值int dis[N], n, m;bool vis[N];//判断这条边是否被选过void add(int a, int b, int c) //建图&#123; e[idx] = b, w[idx] = c, ne[idx]= h[a], h[a] = idx++;&#125;void dijstra()&#123; dis[1] = 0;//起点的距离为0 priority_queue&lt;p, vector&lt;p&gt;, greater&lt;p&gt; &gt; q; //优先队列 q.push(&#123;0, 1&#125;); while(q.size())&#123; p t = q.top(); q.pop(); int u = t.second, d = t.first; if(vis[u])continue; vis[u] = true; for(int i = h[u]; i != -1; i = ne[i])&#123;//遍历每一条边 int j = e[i]; if(dis[j] &gt; d + w[i])&#123;//不断更新为最短距离 dis[j] = d + w[i]; q.push(&#123;dis[j], j&#125;);//放入到队列中 &#125; &#125; &#125;&#125;int main()&#123; memset(dis, INF, sizeof dis);//初始化 memset(vis, false, sizeof vis); memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m; int a, b, c; while(m--)&#123; cin &gt;&gt; a&gt;&gt; b &gt;&gt; c; add(a, b, c); &#125; dijstra(); if(dis[n] == INF)cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; dis[n] &lt;&lt;endl; return 0;&#125; 二.bellman-ford算法简介： 循环n次，每次遍历所有的边，遍历的同时，不断更新a到b的最短距离即dis[b] = min(dis[b], backup[a] + w)，循环完一遍后，得到的所有路径一定满足dis[b] &lt;= dis[a] + w[i] 适用条件： 可以用来判断是否存在负边，时间复杂度为O(nm)，一般情况下不会用到这个算法，常用来求有边数限制的最短路问题，用结构体存储所有的边即可， 代码如下： 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10, INF = 0x3f3f3f3f;int n, m, k;int dis[N], backup[N];struct p&#123; //结构体存边 int a, b, c;&#125;arr[N];void bellman_ford()&#123; memset(dis, INF, sizeof dis); dis[1] = 0; for(int i = 0; i &lt; k; i++)&#123; //限制条件为k条边 memcpy(backup, dis, sizeof dis); //防止出现连锁反应，所以这里的用backup将上一次的最 //短路备份一下 for(int j = 0; j &lt; m; j++)&#123;//遍历所有的边 int a = arr[j].a, b = arr[j].b, w = arr[j].c; dis[b] = min(dis[b], backup[a] + w);//更新 &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 0; i &lt; m; i++) cin &gt;&gt; arr[i].a &gt;&gt; arr[i].b &gt;&gt; arr[i].c; bellman_ford(); if(dis[n] &gt; INF / 2)cout &lt;&lt; \"impossible\" &lt;&lt; endl; //有可能有负权边，所以要大于INF/2 else cout &lt;&lt; dis[n] &lt;&lt; endl; return 0;&#125; 三.spfa算法简介： spfa算法是对bellman-ford算法的一个优化，要想dis[b]变小，前提一定是dis[a]变小了，所以我们用队列来存储已经更新过的点，再用该点不断去更新其他的点，原理跟dijstra算法类似 如何判断负环 用一个变量cnt[i]表示到达 i 这个点的最短路径中经过了多少条边，如果cnt[i] &gt;= n表示有至少经过了n条边，那么就说明至少多走了一条边，那么这条边一定是一个负环。 适用条件： 用来求最短路以及判断是否存在负环，时间复杂度为O(m) 1.spaf算法求最短路 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N = 1e6 + 10, INF = 0x3f3f3f3f;int h[N], e[N], ne[N], w[N], idx;//邻接表存图int n, m;int dis[N];bool vis[N]; //vis含义跟dijstra算法中的不太一样，在这里表示当前这个点是否在队列当中void add(int a, int b, int c)//建边&#123; e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;&#125;void spfa()&#123; memset(dis, INF, sizeof dis); dis[1] = 0; //起点距离为0 queue&lt;int&gt; q; q.push(1); //将1放入队列 while(q.size())&#123; int u = q.front(); q.pop(); vis[u] = false; //表示u不在这个队列中 for(int i = h[u]; i != -1; i = ne[i])&#123; //遍历所有能够到达的点 int v = e[i]; if(dis[v] &gt; dis[u] + w[i])&#123; //更新距离 dis[v] = dis[u] + w[i]; if(!vis[v])&#123; //如果不在队列中 q.push(v); //放入队列 vis[v] = true;//表示v已经在队列当中 &#125; &#125; &#125; &#125;&#125;int main()&#123; memset(h, -1, sizeof h);//初始化 memset(vis, false, sizeof vis); cin &gt;&gt; n &gt;&gt; m; int a, b, c; while(m--)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); &#125; spfa(); if(dis[n] == INF)cout &lt;&lt; \"impossible\" &lt;&lt; endl; else cout &lt;&lt; dis[n] &lt;&lt; endl;&#125; 2.spfa判断是否存在负环 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N = 1e6 + 10, INF = 0x3f3f3f3f;int h[N], e[N], ne[N], w[N], idx;int dis[N], cnt[N]; //cnt[i]表示到达i这个点经过了多少条边bool vis[N];int n, m;void add(int a, int b, int c)&#123; e[idx] = b, w[idx]= c, ne[idx] = h[a], h[a] = idx++;&#125;bool spfa()&#123; queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i++)&#123;//因为不知道负环出现在哪一个起点，所以要将所有的点放入到队列中 vis[i] = true; q.push(i); &#125; while(q.size())&#123; int u = q.front(); q.pop(); vis[u] = false; for(int i = h[u]; i != -1; i = ne[i])&#123; int v = e[i]; if(dis[v] &gt; dis[u] + w[i])&#123; dis[v] = dis[u] +w[i]; cnt[v] = cnt[u] + 1; //边数+1 if(cnt[v] &gt;= n)return true; //如果大于n说明一定存在负环 if(!vis[v])&#123; q.push(v); vis[v] = true; &#125; &#125; &#125; &#125; return false;&#125;int main()&#123; memset(dis, INF, sizeof dis); memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m; int a, b, c; while(m--)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); &#125; if(spfa())puts(\"Yes\"); else puts(\"No\"); return 0;&#125; 四.floyd算法简介： 从任意节点A到任意节点B的最短路径不外乎2种可能，1是直接从A到B，2是从A经过若干个节点到B，所以，我们假设dist(AB)为节点A到节点B的最短路径的距离，对于每一个节点K，我们检查dist(AK) + dist(KB) &lt; dist(AB)是否成立，如果成立，证明从A到K再到B的路径比A直接到B的路径短，我们便设置 dist(AB) = dist(AK) + dist(KB)，这样一来，当我们遍历完所有节点K，dist(AB)中记录的便是A到B的最短路径的距离。 适用条件 能求出任意俩条边的最短路，时间复杂度为O(n^3) 代码如下： 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;const int N = 210, INF = 0x3f3f3f3f;int arr[N][N];int main()&#123; int n ,m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) arr[i][j] = i == j ? 0 : INF; //初始化 int a, b, c; for(int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; arr[a][b] = min(arr[a][b], c); &#125; //floyd算法核心 for(int k = 1; k &lt;= n; k++) for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) arr[i][j] = min(arr[i][j], arr[i][k] + arr[k][j]); while(k--)&#123; cin &gt;&gt; a &gt;&gt; b; if(arr[a][b] &gt; INF / 2)puts(\"impossible\");//可能有负环，所以这里是大于INF/2 else cout &lt;&lt; arr[a][b] &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/06/23/图论/最短路/图论之最短路问题/","date":"06-23","excerpt":"","tags":[{"name":"图论","slug":"图论","permalink":"http://zhumenger.top/tags/图论/"},{"name":"最短路问题","slug":"最短路问题","permalink":"http://zhumenger.top/tags/最短路问题/"}]},{"title":"八数码(bfs)","text":"在一个3×3的网格中，1~8这8个数字和一个“X”恰好不重不漏地分布在这3×3的网格中。 例如： 1 2 3X 4 67 5 8 在游戏过程中，可以把“X”与其上、下、左、右四个方向之一的数字交换（如果存在）。 我们的目的是通过交换，使得网格变为如下排列（称为正确排列）： 1 2 34 5 67 8 X 例如，示例中图形就可以通过让“X”先后与右、下、右三个方向的数字交换成功得到正确排列。 交换过程如下： 1 2 3 1 2 3 1 2 3 1 2 3X 4 6 4 X 6 4 5 6 4 5 67 5 8 7 5 8 7 X 8 7 8 X 现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换。 输入格式输入占一行，将3×3的初始网格描绘出来。 例如，如果初始网格如下所示：1 2 3 x 4 6 7 5 8 则输入为：1 2 3 x 4 6 7 5 8 输出格式输出占一行，包含一个整数，表示最少交换次数。 如果不存在解决方案，则输出”-1”。 输入样例： 2 3 4 1 5 x 7 6 8 输出样例 19 题解：图的最短路问题，肯定要用到bfs, 可以将这个图转化为一个字符串,终点状态就是到达特定字符串”12345678x”，最先到达的一定是最短的 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;unordered_map&gt;using namespace std;unordered_map&lt;string, int &gt; d; //字符串哈希来表示到达该字串的距离string End, cur;int dx[] = &#123;0, 1, 0, -1&#125;;int dy[] = &#123;1, 0, -1, 0&#125;;int bfs()&#123; End = \"12345678x\"; d[cur] = 0; queue&lt;string &gt;q; q.push(cur); while(q.size())&#123; string u = q.front(); if(u == End)return d[u];//如果找到了，返回距离 int distance = d[u]; q.pop(); int x = u.find('x'); //在字符串里找到x int i = x / 3, j = x % 3; //得到x在图里的行和列 for(int k = 0; k &lt; 4; k++)&#123; //上下左右4个方向交换 int xx = i + dx[k]; int yy = j + dy[k]; if(xx &gt;= 0 &amp;&amp; xx &lt; 3 &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; 3)&#123; swap(u[x], u[xx * 3 + yy]);//交换 if(!d.count(u))&#123; //如果该字符串没有出现过，放入到队列中 d[u] = distance + 1; q.push(u); &#125; swap(u[x], u[xx * 3 + yy]); //恢复 &#125; &#125; &#125; return -1;&#125;int main()&#123; char ch; for(int i = 0; i &lt; 9; i++)&#123; cin &gt;&gt; ch; cur += ch; &#125; cout &lt;&lt; bfs() &lt;&lt; endl; return 0;&#125;","path":"2019/06/21/搜索/八数码/","date":"06-21","excerpt":"","tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"dfs和bfs简介","text":"dfs和bfs简介一.深度优先遍历(dfs)本质： 通过递归的方式遍历图中的每一个点。 遍历流程： 从起点开始，在其一条分支上一条路走到黑，走不通了就开始往回走，只要当前有分支就继续往下走，直到将所有的点遍历一遍。 剪枝： 如果已经确定这条路没有我们想要的答案，那么就不用继续在这条路上走下去了，于是我们就开始走其他的分支或者往回走，这样节省时间的方法称之为剪枝。 回溯： 当我们一条路走到头，往回走时，就叫做回溯。 恢复现场： 当我们回溯的时候，原来这个图是什么样的，我们还要变回什么样。这是一个好习惯，我们用了什么东西，就需要还回什么东西。这样做的目的： 当我们遍历完这条分支，去遍历下一条分支的时候，我们需要保证当前图其他条件的一致性，也就是遍历每一条分支的时候，当前图的状态都是一样的。保证遍历每一条分支的时候都是公平的。 下面是流程图： 二.广度优先遍历(bfs)遍历流程： 逐层逐层的遍历，先遍历第一层，再遍历第二层…，也就是遍历当前节点所能到达的所有子节点。直到遍历所有的点。不存在剪枝，回溯和恢复现场的操作。 流程图如下： 三.对比dfs和bfs时间复杂度： dfs: 因为我们需要枚举没一个点，以及每一条边，所示它的时间复杂度为O(n + e) 即点的个数+边的个数 bfs:跟dfs时间复杂度一样，都为O(n + e) 不同的是对每个点的访问顺序是不一样的 用到的数据结构： dfs: stack bfs: queue 空间复杂度： dfs: O(h) h为树的深度 bfs: O(2^h) 特性： dfs: 不具有最短性 bfs: 具有最短性","path":"2019/06/16/搜索/dfs和bfs简介/","date":"06-16","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"},{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"有向图的拓扑排序(bfs)","text":"题目描述 给定一个n个点m条边的有向图，图中可能存在重边和自环。 请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出-1。 若一个由图中所有点构成的序列A满足：对于图中的每条边(x, y)，x在A中都出现在y之前，则称A是该图的一个拓扑序列。 输入格式 第一行包含两个整数n和m 接下来m行，每行包含两个整数x和y，表示点x和点y之间存在一条有向边(x, y)。 输出格式 共一行，如果存在拓扑序列，则输出拓扑序列。 否则输出-1。 数据范围 1≤n,m≤10^5, 1≤n,m≤10^5 输入样例： 3 31 22 31 3 输出样例： 1 2 3 拓扑序列简介： 若一个由图中所有点构成的序列A满足：对于图中的每条边(x, y)，x在A中都出现在y之前，则称A是该图的一个拓扑序列。范围是有向图， 无向图是没有拓扑排序的。 入度： 有多少个点指向该元素，就表示该元素的入度是多少。 初出度： 该元素指向了多少个点，就表示该元素的出度是多少、 拓扑序列的起点： ​ 因为入度为0的点，没有其他的点指向它，所以它一定是一个起点，如果入度为0的点有多个，那么该拓扑序列不唯一，如果没有入度为0的点，也就是这个图是一个环，那么它没有拓扑排序。所以我们要求拓扑序列，那么该图一定是一个有向无环图 如何求拓扑序列： ​ 将入度为0的点加入队列当中，每次从入度为0的点开始遍历它的每一个子节点，不断删去前一个点，并且该节点的入度–，如果入度为0,则加入队列当中，在删去节点的同时用一个数组来存储该拓扑排序的顺序，最后输出答案即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int h[N], e[N], ne[N], idx;//邻接表int d[N], n ,m;//入度vector&lt;int &gt; ans;void add(int a, int b)//邻接表建图&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;int bfs()&#123; queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i++) if(!d[i])q.push(i); //将入度为0的点入队 while(q.size())&#123; int u = q.front(); q.pop(); ans.push_back(u); //储存该拓扑排序 for(int i = h[u]; i != -1; i = ne[i])&#123; int s = e[i]; d[s]--; if(!d[s])q.push(s); &#125; &#125; return (ans.size() == n); //判断是否所有的点都已经入队&#125;int main()&#123; int a, b; memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; a &gt;&gt; b; add(a, b); d[b]++; //入度++ &#125; if(bfs())&#123; for(int i = 0; i &lt; ans.size(); i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; cout &lt;&lt; endl; &#125; else cout &lt;&lt; -1 &lt;&lt; endl; return 0;&#125;","path":"2019/06/15/搜索/有向图的拓扑排序/","date":"06-15","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"树与图的广度优先遍历(bfs)","text":"题目描述 给定一个n个点m条边的有向图，图中可能存在重边和自环。 所有边的长度都是1，点的编号为1~n。 请你求出1号点到n号点的最短距离，如果从1号点无法走到n号点，输出-1。 输入格式 第一行包含两个整数n和m。 接下来m行，每行包含两个整数a和b，表示存在一条从a走到b的长度为1的边。 输出格式 输出一个整数，表示1号点到n号点的最短距离。 数据范围 1≤n,m≤10^5, 输入样例： 4 51 22 33 41 31 4 输出样例： 1 题解： 找图的最短路，所以用到的一定是bfs,首先将起点入队，然后不断的弹出队列元素，让该元素的所有没有走过的叶子节点的距离+1, 然后让子节点入队，直到弹出队首元素为n，这样最先得到的距离一定是最短的。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 +10;int e[N], h[N], ne[N], idx;int d[N], n, m;queue&lt;int&gt; q;void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;void bfs()&#123; d[1] = 0; q.push(1); while(q.size())&#123; int u = q.front(); q.pop(); if(u == n)break; for(int i = h[u]; i != -1; i = ne[i])&#123; int s = e[i]; if(d[s] == -1)&#123; d[s] = d[u] + 1; q.push(s); &#125; &#125; &#125;&#125;int main()&#123; int a, b; memset(d, -1, sizeof d); memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; a &gt;&gt; b; add(a, b); &#125; bfs(); cout &lt;&lt; d[n] &lt;&lt; endl; return 0;&#125;","path":"2019/06/15/搜索/树与图的广度优先遍历/","date":"06-15","excerpt":"","tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"迷宫问题(bfs)","text":"题目描述给定一个n*m的二维整数数组，用来表示一个迷宫，数组中只包含0或1，其中0表示可以走的路，1表示不可通过的墙壁。 最初，有一个人位于左上角(1, 1)处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。 请问，该人从左上角移动至右下角(n, m)处，至少需要移动多少次。 数据保证(1, 1)处和(n, m)处的数字为0，且一定至少存在一条通路。 输入格式 第一行包含两个整数n和m。 接下来n行，每行包含m个整数（0或1），表示完整的二维数组迷宫。 输出格式 输出一个整数，表示从左上角移动至右下角的最少移动次数。 数据范围 1≤n,m≤1001≤n,m≤100 输入样例： 5 50 1 0 0 00 1 0 1 00 0 0 0 00 1 1 1 00 0 0 1 0 输出样例： 8 题解： 经典的bfs问题：bfs有最短路的性质，如果每条边的边权值都是1的话，bfs最先遍历到的点离起点的距离一定是最短的，所以我们可以用bfs来做这道题，用队列的方法是bfs的主要特征。 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int N = 1000, INF = 0x3f3f3f3f;int a[N][N], d[N][N]; //a数组用来存图， d数组表示距离int dx[] = &#123;0, 1, 0, -1&#125;;//往上下左右4个方向遍历int dy[] = &#123;1, 0, -1, 0&#125;; int n ,m;typedef pair&lt;int ,int &gt;P;queue&lt;P&gt; q;void bfs()&#123; memset(d, INF, sizeof d); //将开始的距离都初始化为最大值， d[1][1] = 0; //起点的距离为0 q.push(&#123;1, 1&#125;); while(q.size())&#123; P cur = q.front(); q.pop(); if(cur.first == n &amp;&amp; cur.second == m)&#123; cout &lt;&lt; d[n][m] &lt;&lt; endl; break; &#125; //4个方向遍历 for(int i = 0; i &lt; 4; i++)&#123; int x = cur.first + dx[i]; int y = cur.second + dy[i]; if(x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m &amp;&amp; d[x][y] == INF &amp;&amp; a[x][y] == 0)&#123;//x，y一定是合法的 &amp;&amp; 判断这条路是否可通 &amp;&amp; 判断这条路是否已经走过了 d[x][y] = d[cur.first][cur.second] +1; //距离+1 q.push(&#123;x, y&#125;);//放入到队列中 &#125; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) cin &gt;&gt; a[i][j]; bfs(); return 0;&#125;","path":"2019/06/14/搜索/迷宫问题/","date":"06-14","excerpt":"","tags":[{"name":"bfs","slug":"bfs","permalink":"http://zhumenger.top/tags/bfs/"}]},{"title":"n-皇后问题(dfs)","text":"题目描述n-皇后问题是指将 n 个皇后放在 n∗n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。 现在给定整数n，请你输出所有的满足条件的棋子摆法。 输入格式 共一行，包含整数n。 输出格式 每个解决方案占n行，每行输出一个长度为n的字符串，用来表示完整的棋盘状态。其中”.”表示某一个位置的方格状态为空，”Q”表示某一个位置的方格上摆着皇后。每个方案输出完成后，输出一个空行。 数据范围 1≤n≤9 输入样例： 4 输出样例： .Q..…QQ…..Q. ..Q.Q……Q.Q.. 题解： 经典的n皇后问题:dfs深搜每一行，用col[J]， dg[J], udg[J]数组分别来标记第J列， 正对角线， 反对角线是否有皇后，如果有我们就剪掉， 否则就把皇后放到该位置。代码如下： 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;const int N = 20;int arr[N][N], col[N], dg[N], udg[N], n; void dfs(int cur)&#123; if(cur == n)&#123; //如果放了n个皇后，直接输出 for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(arr[i][j])cout &lt;&lt; 'Q'; else cout &lt;&lt; '.'; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl; return ; &#125; for(int i = 0; i &lt; n; i++)&#123; if(col[i] || dg[cur + i] ||udg[n - cur + i])continue; //如果有了皇后，剪枝 arr[cur][i] = col[i] = dg[cur + i] = udg[n - cur + i] = 1; dfs(cur + 1); arr[cur][i] = col[i] = dg[cur + i] = udg[n - cur + i] = 0; //恢复现场 &#125;&#125;int main()&#123; cin &gt;&gt; n; dfs(0); return 0;&#125;","path":"2019/06/14/搜索/n-皇后问题/","date":"06-14","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"树的重心(dfs)","text":"题目描述 给定一颗树，树中包含n个结点（编号1~n）和n-1条无向边。请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。 输入格式 第一行包含整数n，表示树的结点数。接下来n-1行，每行包含两个整数a和b，表示点a和点b之前存在一条边。 输出格式 输出一个整数m，表示重心的所有的子树中最大的子树的结点数目。 数据范围 1≤n≤105 输入样例 9 1 21 71 42 82 54 33 94 6 输出样例： 4 解题思路： 这道题就是树的深度优先遍历，我们只需套用模板，遍历每个点的同时，返回该子树的点的个数，以及计算去掉该点时连通块点的最大值即可，最后用ans取去掉每个点之后的最大联通块的最小值就是最后的答案。具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int h[N], e[N], ne[N], idx, n;int ans = N; //答案bool vis[N]; //判断是否遍历过void add(int a, int b) //邻接表存树与图&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;int dfs(int cur)&#123; vis[cur] = true; int res = 0, sum = 1; //res表示去掉cur这个节点，联通块点的最大值， sum表示该子树点的个数 for(int i = h[cur]; i != -1; i = ne[i])&#123; //遍历树 int u = e[i]; if(!vis[u])&#123; int s = dfs(u); res = max(res, s); sum += s; &#125; &#125; res = max(res, n - sum); // sum是该子树的点的个数， n - sum表示它的父节点所连接的联通块点的个数 ans = min(res, ans); //取最大连通块点的最小值 return sum;&#125;int main()&#123; int a, b; cin &gt;&gt; n; //初始化 memset(h, -1, sizeof h); memset(vis, false, sizeof vis); for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; a &gt;&gt; b; //建树，双向图 add(a, b); add(b, a); &#125; dfs(1); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","path":"2019/06/14/搜索/树的重心/","date":"06-14","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"树与图的深度优先遍历(dfs)","text":"树与图的深度优先遍历: 树其实也是图的一种图: 分为有向图和无向图图的储存: 第一种：邻接矩阵，就是一个二维数组，缺点：当点和边特别多的时候，存不下，一般用的比较少，而且非常浪费空间第二种：邻接表:由n个单链表组成，也可以用vector动态数组来实现，但vector有很大的缺点，当点和边非常大时，用vector动态数组的方法很容易超时，所以我们常用n个但链表的方式来存储图 邻接表如何存图呢：假设有这样一个图:那么我们可以给每个节点开一个单链表，如下图所示：这样我们就把图用邻接表的方法存了下来树与图深度优先遍历的大致流程：一条路走到黑，直到撞到南墙，走不通了，然后往回走，只要有分支就继续往下走树与图的遍历模板： 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int h[N], e[N], ne[N], idx, n;//这里跟单链表一样，只不过这里是N个头节点，H[N]bool vis[N]; //判断是否遍历过void add(int a, int b) //邻接表存树与图&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;void dfs(int cur)&#123; vis[cur] = true; for(int i = h[cur]; i != -1; i = ne[i])&#123; //遍历树 int u = e[i]; if(!vis[u])&#123; dfs(u); &#125; &#125;&#125;int main()&#123; int a, b; cin &gt;&gt; n; //初始化 memset(h, -1, sizeof h); memset(vis, false, sizeof vis); for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; a &gt;&gt; b; //建树，双向图 add(a, b); add(b, a); &#125; dfs(1); return 0;&#125; 这样我们就遍历了每个点。","path":"2019/06/14/搜索/树与图的深度优先遍历/","date":"06-14","excerpt":"","tags":[{"name":"dfs","slug":"dfs","permalink":"http://zhumenger.top/tags/dfs/"}]},{"title":"字符串哈希","text":"字符串哈希：简介：为了方便的找到某个字符串，我们可以把该字符串转化为一个数值，每一个字符串都有一个唯一确定的编号，这样在绝大多数情况下可以在O(1)的时间复杂度中完成对字符串元素的查找 字符串哈希函数：为每一个字符串赋予唯一确定的数值或编号。 题目描述 给定一个长度为n的字符串，再给定m个询问，每个询问包含四个整数l1,r1,l2,r2l1,r1,l2,r2，请你判断[l1,r1l1,r1]和[l2,r2l2,r2]这两个区间所包含的字符串子串是否完全相同。 字符串中只包含大小写英文字母和数字。 输入格式 第一行包含整数n和m，表示字符串长度和询问次数。 第二行包含一个长度为n的字符串，字符串中只包含大小写英文字母和数字。 接下来m行，每行包含四个整数l1,r1,l2,r2l1,r1,l2,r2，表示一次询问所涉及的两个区间。 注意，字符串的位置从1开始编号。 输出格式 对于每个询问输出一个结果，如果两个字符串子串完全相同则输出“Yes”，否则输出“No”。 每个结果占一行。 数据范围 1≤n,m≤1051≤n,m≤105 输入样例： 8 3aabbaabb1 3 5 71 3 6 81 2 1 2 输出样例： YesNoYes 代码如下： 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef unsigned long long ULL;const int N = 1e6 + 10, base = 131;ULL h[N], p[N];char s[N];ULL solve(int l, int r)&#123; return h[r] - h[l - 1] * p[r - l + 1];&#125;int main()&#123; int n, m; int a, b, c, d; cin &gt;&gt; n &gt;&gt; m; cin &gt;&gt; (s + 1); p[0] = 1; for(int i = 1; i &lt;= n; i++) &#123; h[i] = h[i - 1] * base + s[i] - 'a' + 1; p[i] = p[i - 1] * base; &#125; while(m--)&#123; cin &gt;&gt; a&gt;&gt; b &gt;&gt; c &gt;&gt; d; if(solve(a, b) == solve(c, d))cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/06/13/数据结构基础/字符串哈希/","date":"06-13","excerpt":"","tags":[{"name":"字符串哈希","slug":"字符串哈希","permalink":"http://zhumenger.top/tags/字符串哈希/"}]},{"title":"哈希表(散列表)","text":"简介： 哈希表又称为散列表，是实现字典操作的一种有效的数据结构。通过哈希函数将关键字映射到表中的某个位置上进行存放，以实现快速插入和查询的。时间复杂度可达到O(n).为什么要用到哈希：比如说有n(1&lt;=n&lt;=1e6)个数,当给你一个非常大的数时，为了方便查找这个数是否出现过，我们可以给这个数重新编号到1~n，这样我们就可以快速的找到想要的答案。 题目描述 维护一个集合，支持如下几种操作：“I x”，插入一个数x；“Q x”，询问数x是否在集合中出现过；现在要进行N次操作，对于每个询问操作输出对应的结果。 输入格式 第一行包含整数N，表示操作数量。接下来N行，每行包含一个操作指令，操作指令为”I x”，”Q x”中的一种。 输出格式 对于每个询问指令“Q x”，输出一个询问结果，如果x在集合中出现过，则输出“Yes”，否则输出“No”。每个结果占一行。 数据范围 1≤N≤105−109≤x≤109 输入样例： 5 I 1I 2I 3Q 2Q 5 输出样例： YesNo 题解： 拉链法： ​ 先找出编号的数据范围MOD，最好是一个质数，这样冲突的几率是最小的，让输入的数字x%mod，这样就可以让x重新编号到0~mod - 1， 有的时候我们得到的余数是一样的，我们可以以这个余数为head， 把这些余数相同的储存到一个链表当中，具体代码如下： 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10, mod = 100003;int h[N], e[N], ne[N], idx = 1;void insert(int x)&#123; int k = (x % mod + mod) % mod; //得到余数head e[idx] = x, ne[idx] = h[k], h[k] = idx++;//在以head为头结点的链表中插入数值&#125;bool Find(int x)&#123; int k = (x % mod + mod) % mod; for(int i = h[k]; i != -1; i = ne[i]) //在以head为头结点的链表中查找x if(e[i] == x)return true; return false;&#125;int main()&#123; int n, x; string s; memset(h, -1, sizeof h); cin &gt;&gt; n; while(n--)&#123; cin &gt;&gt; s &gt;&gt;x; if(s == \"I\")&#123; insert(x); &#125; else &#123; if(Find(x))cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; &#125; return 0;&#125; 开放寻址法： ​ 这种方法也是先让x对mod取模， 得到x应该去到哪个坑里，如果这个坑已经被占了，就继续往下遍历直到寻找到一个没有人的坑位，数据范围往往开到n的俩到三倍。 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 200003, Max = 0x3f3f3f3f;int h[N];int Find(int x)&#123; int k = (x % N + N) % N; //取模 while(h[k] != Max &amp;&amp; h[k] != x)&#123; //找到一个没有人的坑位 k++; if(k == N)k = 0; //如果到头了，就从0重新开始遍历，因为一共就只有n个数，所以肯定有剩余的 //坑位供x使用 &#125; return k; //返回坑位的下标&#125;int main()&#123; int n, x; string s; cin &gt;&gt; n; memset(h, Max, sizeof h);//初始化，开始的时候都没有人 while(n--)&#123; cin &gt;&gt; s &gt;&gt; x; if(s == \"I\")&#123; int k = Find(x); h[k] = x; //把x放到该坑位 &#125; else &#123; int k = Find(x); if(h[k] != Max)cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; &#125; &#125; return 0;&#125;","path":"2019/06/12/数据结构基础/哈希表-散列表/","date":"06-12","excerpt":"","tags":[{"name":"哈希","slug":"哈希","permalink":"http://zhumenger.top/tags/哈希/"}]},{"title":"最大异或对","text":"Acwing-&gt;143.最大异或对 题目描述在给定的N个整数A1，A2……AN中选出两个进行xor（异或）运算，得到的结果最大是多少？ 输入格式 第一行输入一个整数N。第二行输入N个整数A1～AN。 输出格式 输出一个整数表示答案。 数据范围 1≤N≤105,0≤Ai&lt;231 输入样例： 3 1 2 3 输出样例： 3 题解：异或+前缀+字典树其实来说,一个整数,是可以转化成为一个32位的二进制数,而也就可以变成长度为32位的二进制字符串.既然如此话,那么我们可以这么做,每一次检索的时候,我们都走与当前Ai的二进制位的数值相反的位置走,这样就可以让Xor值最大,如果说没有路可以走的话,那么就走相同的路.时间复杂度：位数*n，所以是O(32 * n) 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int a[N], trie[N * 32][5], idx;void insert(int x) //建树&#123; int p = 1; for(int i = 30; i &gt;= 0; i--)&#123; int u = x &gt;&gt; i &amp; 1; if(!trie[p][u])trie[p][u] = idx++; p = trie[p][u]; &#125;&#125;int search(int x)//找最大的&#123; int p = 1, ans = 0; for(int i = 30; i &gt;= 0; i--)&#123; int u = x &gt;&gt; i &amp;1; if(trie[p][u^1])&#123; p = trie[p][u^1]; ans +=(1 &lt;&lt; i); &#125; else p = trie[p][u]; &#125; return ans;&#125;int main()&#123; int n; cin &gt;&gt; n; idx =2; for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; a[i]; insert(a[i]); &#125; int res = 0; for(int i = 0; i &lt; n; i++)res = max(res, search(a[i])); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;","path":"2019/06/11/数据结构基础/最大异或对/","date":"06-11","excerpt":"","tags":[{"name":"Trie","slug":"Trie","permalink":"http://zhumenger.top/tags/Trie/"}]},{"title":"Trie-字典树","text":"Trie(字典树): 一种用于实现字符串快速检索的多叉树结构 Trie插入： 当需要插入一个字符串s时，我们令一个指针P起始指向根节点。然后，依次扫描S中的每个字符c：若P的c字符指针指向一个已经存在的节点Q，则令P = Q。若P的c字符指针指向空，则新建一个节点Q，令P的c字符指针指向Q，然后令P = Q。当S中的字符扫描完毕时，在当前节点P上标记它是一个字符串的结尾。 检索： 当需要检索一个字符串S在Trie中是否存在时，我们令一个指针P起初指向根节点，然后依次扫描S中的每个字符c：若P的c字符指针指向空，则说明S没有被插入过Trie，结束检索。若P的c字符指针指向一个已经存在的节点Q，则令P = Q。当S中的字符扫描完毕时，若当前节点P被标记为一个字符串的结尾，则说明S在Trie中存在，否则说明S没有被插入过Trie。 问题描述 “I x”向集合中插入一个字符串x；“Q x”询问一个字符串在集合中出现了多少次。共有N个操作，输入的字符串总长度不超过 105，字符串仅包含小写英文字母。 输入格式 第一行包含整数N，表示操作数。接下来N行，每行包含一个操作指令，指令为”I x”或”Q x”中的一种。 输出格式 对于每个询问指令”Q x”，都要输出一个整数作为结果，表示x在集合中出现的次数。每个结果占一行。 数据范围 1≤N≤2∗104 输入样例： 5 I abcQ abcQ abI abQ ab 输出样例： 1 01 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e6 + 10;int trie[N][26], cnt[N], idx;char str[N], c;void insert(char *str)&#123; int len = strlen(str), p = 1; //从根节点开始 for(int i = 0; i &lt; len; i++)&#123; int u = str[i] - 'a'; if(!trie[p][u])//如果没有节点，便创造一个节点 trie[p][u] = idx++; //对每个字符串进行编号 p = trie[p][u]; //p等于该节点，继续往下遍历 &#125; cnt[p]++;// 统计编号为p的字符串的个数&#125;int search(char *str)&#123; int len = strlen(str), p = 1; for(int i = 0; i &lt; len; i++)&#123; int u = str[i] - 'a'; if(!trie[p][u])return 0; //如果该节点为空，说明该字符串没有出现 p = trie[p][u]; &#125; return cnt[p];&#125;int main()&#123; int n; cin &gt;&gt; n; idx = 1; while(n--)&#123; cin &gt;&gt; c &gt;&gt; str; if(c == 'I')insert(str); else cout &lt;&lt; search(str) &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/06/11/数据结构基础/Trie-字典树/","date":"06-11","excerpt":"","tags":[{"name":"Trie","slug":"Trie","permalink":"http://zhumenger.top/tags/Trie/"}]},{"title":"单链表","text":"题目描述实现一个单链表，链表初始为空，支持三种操作： (1) 向链表头插入一个数； (2) 删除第k个插入的数后面的数； (3) 在第k个插入的数后插入一个数 现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。 注意:题目中第k个插入的数并不是指当前链表的第k个数。例如操作过程中一共插入了n个数，则按照插入的时间顺序，这n个数依次为：第1个插入的数，第2个插入的数，…第n个插入的数。 输入格式 第一行包含整数M，表示操作次数。接下来M行，每行包含一个操作命令，操作命令可能为以下几种：(1) “H x”，表示向链表头插入一个数x。(2) “D k”，表示删除第k个输入的数后面的数（当k为0时，表示删除头结点）。(3) “I k x”，表示在第k个输入的数后面插入一个数x（此操作中k均大于0）。 输出格式 共一行，将整个链表从头到尾输出。 数据范围 1≤M≤100000所有操作保证合法。 输入样例： 10H 9I 1 1D 1D 0H 6I 3 6I 4 5I 4 5I 3 4D 6 输出样例： 6 4 6 5 1.单链表的简单介绍 单链表是一种链式存取的数据结构，用一组任意地址空间（地址空间即存储单元）来存放线性表的数据元素。单链表中的数据是以节点的形式来表示，而节点是用结构体来描述，每个节点都是由元素和指针构成，即该结构体中包含两个成员变量：存放元素的成员变量和存放下一个节点地址的成员变量。 2.顺序表与链表的区别 顺序表的特点为：逻辑相邻的两节点其物理地址也是相邻的；链表的特点为：逻辑相邻的两节点其物理地址不相邻。顺序表的存储方式是：节点元素连续存放在存储单元；链表的存储方式是：节点元素随机存放在存储单元。 链表的插入和删除操作：代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int head; //表示头结点int idx; //表示当前是第几个数int e[N]; //表示第i个数所存储的值int ne[N]; //i的下一个节点void init()&#123; head = -1; //初始化 idx = 0; //下标从0开始&#125;//插入到头结点//1.先用e[idx]存储该值//2.将ne[idx]即第idx个数的下一个节点指向头结点//3.头结点head更新为idx;//4.idx++;void add_to_head(int x)&#123; e[idx] = x, ne[idx] = head, head = idx, idx++; &#125;// 将x插入到第k个数的后面//1.先用e[idx]存储该值x//2.将ne[idx]即第idx个数的下一个节点指向第k个数的下一个节点//3.将ne[k]指向idx;//4.idx++;void add(int k, int x)&#123; e[idx] = x, ne[idx] = ne[k], ne[k] = idx, idx++;&#125;//删除第k个数后面的数//直接让ne[k] = ne[ne[k]]即可void move(int k)&#123; ne[k] = ne[ne[k]];&#125;int main()&#123; int t; init(); cin &gt;&gt; t; while(t--)&#123; char c; int k, x; cin &gt;&gt; c; if(c == 'H')&#123; cin &gt;&gt; x; add_to_head(x); &#125; else if(c == 'D')&#123; cin &gt;&gt; k; if(!k)head = ne[head]; //如果k == 0, 要删除头结点，即让head等于下一个节点 else move(k - 1); &#125; else if(c == 'I')&#123; cin &gt;&gt; k &gt;&gt; x; add(k - 1, x); &#125; &#125; for(int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; ' ' ; cout &lt;&lt; endl; return 0;&#125;","path":"2019/06/10/数据结构基础/单链表/","date":"06-10","excerpt":"","tags":[{"name":"单链表","slug":"单链表","permalink":"http://zhumenger.top/tags/单链表/"}]},{"title":"直方图中最大的矩形（单调栈2）","text":"题目描述直方图是由在公共基线处对齐的一系列矩形组成的多边形。 矩形具有相等的宽度，但可以具有不同的高度。 例如，图例左侧显示了由高度为2,1,4,5,1,3,3的矩形组成的直方图，矩形的宽度都为1:通常，直方图用于表示离散分布，例如，文本中字符的频率。 现在，请你计算在公共基线处对齐的直方图中最大矩形的面积。 图例右图显示了所描绘直方图的最大对齐矩形。 输入格式 输入包含几个测试用例。每个测试用例占据一行，用以描述一个直方图，并以整数n开始，表示组成直方图的矩形数目。然后跟随n个整数h1，…，hn。这些数字以从左到右的顺序表示直方图的各个矩形的高度。每个矩形的宽度为1。同行数字用空格隔开。当输入用例为n=0时，结束输入，且该用例不用考虑。 输出格式 对于每一个测试用例，输出一个整数，代表指定直方图中最大矩形的区域面积。每个数据占一行。请注意，此矩形必须在公共基线处对齐。 数据范围 1≤n≤100000,0≤hi≤1000000000 输入样例： 7 2 1 4 5 1 3 34 1000 1000 1000 10000 输出样例： 8 4000 题解： 以H[ i ]为高的矩形向左右扩展，找到能够到达的最远距离，即找到左右边界第一个小于H[ i ]的位置， 实际上就是一道单调栈的问题，用一个栈来维护一个单调递增的序列，如果栈中的某个元素比当前的数值的小，那么该元素之后的元素肯定是用不到了，所以就可以直接丢出栈， 并将该值加入栈中，遍历一遍，用ans记录最大值即可 代码如下: 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e5 + 10;int q[N], l[N], r[N], a[N], t;int n;void get(int *l)&#123; t = 0; a[0] = -1; q[0] = 0; for(int i = 1; i &lt;= n; i++)&#123; while(a[i] &lt;= a[q[t]])t--; l[i] = q[t] + 1; q[++t] = i; &#125;&#125;int main()&#123; while(cin &gt;&gt; n &amp;&amp; n)&#123; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; get(l); reverse(a + 1, a + 1 + n); get(r); reverse(a + 1, a + 1 + n); long long int ans = 0; for(int i = 1; i &lt;= n; i++)&#123; ans = max(ans, (long long)a[i] * (n - r[n - i + 1] +1 - l[i] + 1)); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;","path":"2019/06/10/数据结构基础/直方图中最大的矩形（单调栈2）/","date":"06-10","excerpt":"","tags":[{"name":"栈","slug":"栈","permalink":"http://zhumenger.top/tags/栈/"},{"name":"单调栈","slug":"单调栈","permalink":"http://zhumenger.top/tags/单调栈/"}]},{"title":"堆","text":"堆：一种支持插入，删除，查询最值的数据结构，是一颗完全二叉树，实际上就是一个优先队列priority_queue,这里我们用数组的实现这个堆大根堆：树中的任意一个节点的权值都小于等于其父节点小根堆：树中的任意一个节点的权值都大于等于其父节点如何实现堆： 直接用一个数组来保存二叉堆， 逐层的从左到右依次编号，将此编号作为节点在数组中存储的位置。所以，父亲点编号等于子节点编号除以2，左子节点编号等于父节点编号乘以2，又子节点等于父节点编号乘2加1 堆的基本操作： 1求集合中的最小值：h[ 1 ]2.插入一个数：h[++n] = x;up(n); //up函数将x向上调整，找到x的位置，保证堆的有序性3.删除最小值：h[1] = h[n–];down(1) //down函数，将x向下调整，找到x的位置，保证堆的有序性4.删除任意一个元素：h[x] = h[n–];down(x);up(x);//因为不确定x的大小，所以可能是向上调整，也可能是向下调整，这俩个函数虽然都写上了，但实际上只会执行一个，5.修改任意一个元素：h[k] = x;down(k);up(k)//跟4同理时间复杂度：与堆的高度有关，所以是O（logN）代码如下： 题目描述 输入一个长度为n的整数数列，从小到大输出前m小的数。 输入格式 第一行包含整数n和m。第二行包含n个整数，表示整数数列。 输出格式 共一行，包含m个整数，表示整数数列中前m小的数。 数据范围 1≤m≤n≤105，1≤数列中元素≤109 输入样例： 5 34 5 1 3 2 输出样例： 1 2 3 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int h[N], n ,m;void down(int p) //向上调整&#123; int s = 2 * p; //子节点 while(s &lt;= n)&#123; if(s &lt; n &amp;&amp; h[s] &gt; h[s + 1])s++; //找到左右子节点的最小值 if(h[s] &lt; h[p])&#123; //如果子节点比父节点小 swap(h[s], h[p]); //则交换 p = s; //继续向下调整 s = 2 * p; &#125; else break; &#125;&#125;void up(int p) //向上调整，&#123; while(p &gt; 1)&#123; if(h[p] &lt; h[p / 2])&#123; //如果子节点小于父节点 swap(h[p], h[p / 2]); //则交换 p /= 2; //继续向上调整 &#125; else break; &#125;&#125;int main()&#123; cin&gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; h[i]; for(int i = n / 2; i &gt;= 1; i--)down(i); while(m--)&#123; cout &lt;&lt; h[1] &lt;&lt; ' '; h[1] = h[n--]; down(1); &#125; return 0;&#125;","path":"2019/06/10/数据结构基础/堆/","date":"06-10","excerpt":"","tags":[{"name":"堆","slug":"堆","permalink":"http://zhumenger.top/tags/堆/"}]}]}